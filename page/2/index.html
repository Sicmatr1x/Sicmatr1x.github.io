<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Sicmatr1x"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Sicmatr1x</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['理智是慢慢黑夜里的一个微小的火花，是疯狂的世界里的一个珍贵的例外。', 'Reason is a tiny spark in the dark night, a precious exception in the crazy world.', '给岁月以文明而非给文明以岁月。'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-SpringBoot-原理初探"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/23/SpringBoot-%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"
    >SpringBoot-原理初探</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/23/SpringBoot-%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/" class="article-date">
  <time datetime="2020-03-23T07:37:04.000Z" itemprop="datePublished">2020-03-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><h4 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>是SpringBoot的启动场景</p>
<p>比如使用<code>spring-boot-starter-web</code>，他会帮我们自动导入web环境所有的依赖</p>
<p>SpringBoot会将所有的场景都变成一个个的启动器，我们要使用什么功能就只需要引入对应的启动器即可</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter" target="_blank" rel="noopener">Starters 启动器列表</a></p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><pre><code>@SpringBootConfiguration: springboot的配置
  @Configuration: Spring的配置类
    @Component: 是Spring的组件
@EnableAutoConfiguration: 自动配置
  @AutoConfigurationPackage: 自动配置包
    @Import(AutoConfigurationPackages.Registrar.class): 自动配置包注册
  @Import(AutoConfigurationImportSelector.class): 自动配置导入选择</code></pre><p>org/springframework/boot/autoconfigure/AutoConfigurationImportSelector.java</p>
<pre><code class="java">    protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,
            AnnotationMetadata annotationMetadata) {
        //...
    // 获取所有配置
        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
        //...
    }


  protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
                getBeanClassLoader());
        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
                + &quot;are using a custom packaging, make sure that file is correct.&quot;);
        return configurations;
  }</code></pre>
<p>META-INF/spring.factories: 自动配置的核心文件</p>
<img src="截屏spring.factories.png">

<p>org/springframework/core/io/support/SpringFactoriesLoader.java</p>
<pre><code class="java">    public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) {
        String factoryTypeName = factoryType.getName();
        return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
    }

    private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);
        if (result != null) {
            return result;
        }

        try {
            Enumeration&lt;URL&gt; urls = (classLoader != null ?
                    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : // FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;
                    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
            result = new LinkedMultiValueMap&lt;&gt;();
            while (urls.hasMoreElements()) { // 判断有没有更多的元素
                URL url = urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource); // 所有的资源加载到配置类中
                for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {
                    String factoryTypeName = ((String) entry.getKey()).trim();
                    for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {
                        result.add(factoryTypeName, factoryImplementationName.trim());
                    }
                }
            }
            cache.put(classLoader, result);
            return result;
        }
        catch (IOException ex) {
            throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +
                    FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
        }
    }
</code></pre>
<p>结论：springboot所有的自动配置都是在启动的时候扫描并加载：<code>spring.factories</code>中的所有的自动配置类，但是不一定全部都生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功了</p>
<ol>
<li>springboot在启动的时候从类路径下<code>META-INF/spring.factories</code>获取指定的值</li>
<li>将这些配置的类导入容器，自动配置就会生效，帮我们进行自动配置</li>
<li>以前需要我们配置的东西，现在springboot帮我们做了</li>
<li>整合javaEE，解决方案和自动配置的东西都在<code>spring-boot-test-autoconfigure-2.2.5.RELEASE.jar</code>这个包下</li>
<li>它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器了</li>
<li><code>spring.factories</code>中存在许多xxxAutoConfiguration的文件(@Bean)，就是这些类给容器中导入类这个场景需要的所有组件，并自动配置</li>
<li>有了自动配置类(@Configuration)，免去了我们手动配置</li>
</ol>
<h4 id="application配置文件"><a href="#application配置文件" class="headerlink" title="application配置文件"></a>application配置文件</h4><p>如何知道可以在配置文件中配置哪些项目？</p>
<ol>
<li><code>META-INF/spring.factories</code>下存在被加载的配置类</li>
<li>以<code>HttpEncodingAutoConfiguration</code>为例，进入<code>HttpEncodingAutoConfiguration.java</code></li>
<li><code>@EnableConfigurationProperties(HttpProperties.class)</code>可以看到该类关联了<code>HttpProperties.class</code>做为Properties</li>
<li>该类里面的属性为<code>@ConfigurationProperties(prefix = &quot;spring.http&quot;)</code>配置的前缀后的属性</li>
</ol>
<pre><code class="java">//从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;)
public class HttpProperties {
    //...
}</code></pre>
<h2 id="主启动类运行原理"><a href="#主启动类运行原理" class="headerlink" title="主启动类运行原理"></a>主启动类运行原理</h2><pre><code class="java">@SpringBootApplication // 标志该类为springboot启动类
public class SpringBootDemoApplication {

    public static void main(String[] args) {
    // 该方法返回一个ConfigurableApplicationContext对象
        SpringApplication.run(SpringBootDemoApplication.class, args);
    }

}</code></pre>
<p>类<code>SpringApplication</code>做了以下事情：</p>
<ol>
<li>推动应用的类型是普通项目还是web项目</li>
<li>查找并加载所有可用的初始化器，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，设置到listeners属性中</li>
<li>推断并设置main方法的定义类，找到运行的主类</li>
</ol>
<h2 id="静态资源加载"><a href="#静态资源加载" class="headerlink" title="静态资源加载"></a>静态资源加载</h2><p><code>WebMvcAutoConfiguration.java</code></p>
<pre><code class="java">        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
            if (!this.resourceProperties.isAddMappings()) { // 判断是否有自定义静态文件路径
                logger.debug(&quot;Default resource handling disabled&quot;);
                return;
            }
            Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
            CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
            if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
                customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
            }
            String staticPathPattern = this.mvcProperties.getStaticPathPattern();
            if (!registry.hasMappingForPattern(staticPathPattern)) {
                customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                        .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
            }
        }</code></pre>
<p><code>WebMvcProperties.java</code></p>
<pre><code class="java">    private String staticPathPattern = &quot;/**&quot;;

    public String getStaticPathPattern() {
        return this.staticPathPattern;
    }</code></pre>
<p><code>ResourceProperties.java</code></p>
<pre><code class="java">    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { &quot;classpath:/META-INF/resources/&quot;,
            &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; };

    /**
     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
     * /resources/, /static/, /public/].
     */
    private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</code></pre>
<h4 id="静态资源加载方法"><a href="#静态资源加载方法" class="headerlink" title="静态资源加载方法"></a>静态资源加载方法</h4><ol>
<li>webjars<ul>
<li>映射到：<code>localhost:8080/webjars/</code></li>
</ul>
</li>
<li>public, static, /**, resources目录下<ul>
<li>映射到：<code>localhost:8080/</code></li>
</ul>
</li>
</ol>
<h4 id="静态资源加载路径优先级"><a href="#静态资源加载路径优先级" class="headerlink" title="静态资源加载路径优先级"></a>静态资源加载路径优先级</h4><p>resources &gt; static(默认) &gt; public</p>
<h4 id="自定义静态资源路径"><a href="#自定义静态资源路径" class="headerlink" title="自定义静态资源路径"></a>自定义静态资源路径</h4><p>application.properties</p>
<pre><code class="properties">spring.mvc.static-path-pattern=/hello,classpath:/test/</code></pre>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p><code>WebMvcAutoConfiguration.java</code>:</p>
<pre><code class="java">        @Bean
        @ConditionalOnMissingBean
        @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
        public LocaleResolver localeResolver() {
            // 用户配了就用用户配置，否则使用默认配置
            if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
                return new FixedLocaleResolver(this.mvcProperties.getLocale());
            }
            AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
            localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
            return localeResolver;
        }</code></pre>
<p>可以看到这里使用到了<code>AcceptHeaderLocaleResolver</code>这个类来进行国际化解析</p>
<pre><code class="java">public class AcceptHeaderLocaleResolver implements LocaleResolver {
    //...
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        Locale defaultLocale = getDefaultLocale();
        if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) {
            return defaultLocale;
        }
        Locale requestLocale = request.getLocale();
        List&lt;Locale&gt; supportedLocales = getSupportedLocales();
        if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) {
            return requestLocale;
        }
        Locale supportedLocale = findSupportedLocale(request, supportedLocales);
        if (supportedLocale != null) {
            return supportedLocale;
        }
        return (defaultLocale != null ? defaultLocale : requestLocale);
    }
    //...
}</code></pre>
<h3 id="配置自己的国际化解析器"><a href="#配置自己的国际化解析器" class="headerlink" title="配置自己的国际化解析器"></a>配置自己的国际化解析器</h3><p>和<code>AcceptHeaderLocaleResolver</code>一样需要继承<code>LocaleResolver</code>类，并实现<code>resolveLocale</code>和<code>setLocale</code>这两个方法</p>
<p><code>com/sicmatr1x/config/MyLocaleResolver.java</code>:</p>
<pre><code class="java">package com.sicmatr1x.config;

import java.util.Locale;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

public class MyLocaleResolver implements LocaleResolver {

  // 解析请求
  @Override
  public Locale resolveLocale(HttpServletRequest request) {
    // 获取请求中的语言参数
    String language = request.getParameter(&quot;l&quot;);
    Locale locale = Locale.getDefault(); // 如果没有就使用默认的

    // 若请求链接携带了国际化参数
    if (!StringUtils.isEmpty(language)) {
      String[] split = language.split(&quot;_&quot;); // zh_CN
      // 国家，地区
      locale = new Locale(split[0], split[1]);
    }
    return locale;
  }

  @Override
  public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

  }
}</code></pre>
<p>然后需要到<code>MyMvcConfig</code>中去注册即可</p>
<p><code>com/sicmatr1x/config/MyMvcConfig.java</code>:</p>
<pre><code class="java">@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

  @Override
  public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);
    registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;);

  }

  @Bean
  public LocaleResolver localeResolver() {
    return new MyLocaleResolver();
  }
}</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Microservices微服务学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/23/Microservices%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0/"
    >Microservices 微服务学习</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/23/Microservices%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-03-23T02:16:04.000Z" itemprop="datePublished">2020-03-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Martin Fowler 微服务论文</a></li>
<li><a href="https://www.jianshu.com/p/1f68d8fc6dae" target="_blank" rel="noopener">Martin Fowler 微服务论文翻译</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-全文搜索ElasticSearch"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/15/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2ElasticSearch/"
    >全文搜索ElasticSearch</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/15/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2ElasticSearch/" class="article-date">
  <time datetime="2020-03-15T03:52:04.000Z" itemprop="datePublished">2020-03-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>ElasticSearch是高度可扩展的开源全文搜索和分析引擎，可以快速的、近实时的对大数据进行存储、搜索和分析。</p>
<h2 id="全文搜索方法"><a href="#全文搜索方法" class="headerlink" title="全文搜索方法"></a>全文搜索方法</h2><h3 id="非结构化数据的检索"><a href="#非结构化数据的检索" class="headerlink" title="非结构化数据的检索"></a>非结构化数据的检索</h3><ol>
<li>顺序扫描法(Serial Scanning): 操作系统搜索文件、linux gurp命令</li>
<li>全文搜索(Full-text Search): 将非结构化数据转化为结构化数据，建立索引</li>
</ol>
<h3 id="全文搜索-Full-text-Search"><a href="#全文搜索-Full-text-Search" class="headerlink" title="全文搜索(Full-text Search)"></a>全文搜索(Full-text Search)</h3><ol>
<li>建立文本库</li>
<li>建立索引</li>
<li>执行搜索</li>
<li>过滤结果</li>
</ol>
<h3 id="基于Java的开源全文搜索引擎"><a href="#基于Java的开源全文搜索引擎" class="headerlink" title="基于Java的开源全文搜索引擎"></a>基于Java的开源全文搜索引擎</h3><ol>
<li>Lucene: 全文搜索引擎</li>
<li>ElasticSearch: 基于Lucene，使用内建的协调分布系统。只支持json格式</li>
<li>Solr: 使用了ZooKeeper的协调分布系统</li>
</ol>
<h3 id="ElasticSearch的特点"><a href="#ElasticSearch的特点" class="headerlink" title="ElasticSearch的特点"></a>ElasticSearch的特点</h3><ul>
<li>分布式：每个索引使用可配置数量的一个分片，每个分片可以有多个副本，在任何一个副本上执行读取和搜索操作。</li>
<li>高可用</li>
<li>多类型</li>
<li>多API：支持HTTP RESTFUL、支持Java</li>
<li>面向文档：不需要定义模式，NoSQL</li>
<li>异步写入：写入性能更好</li>
<li>近实时</li>
<li>基于Lucenne</li>
<li>开源：Apache协议</li>
</ul>
<p>重要概念：</p>
<ul>
<li>近实时：如果要做到真实时需要牺牲索引的效率，因为每次搜索之后都需要刷新数据，或者牺牲查询的效率。每隔n秒进行刷新，索引不写入磁盘，根据刷新策略来写入磁盘</li>
<li>集群：多个节点的集合，用来保存应用的全部数据并提供基于全部节点集成的索引的搜索功能，每个节点都有唯一的名称</li>
<li>节点</li>
<li>索引：在ElasticSearch中，索引为相似文档的集合，索引的内容与文档相关</li>
<li>类型：对索引中包含文档的进一步细分，一般根据文档的公共属性来划分</li>
<li>文档：是进行索引的基本单位，与索引中的类型是相对应的，使用json来表示</li>
<li>分片：对于分片中的数据需要建立一个副本，每个索引可以建成多个分片。主要用于水平分割内容，分布在多个节点上可以提高性能</li>
<li>副本：分片可以设置副本，分布在不同的节点上。</li>
</ul>
<h2 id="MAC下环境配置"><a href="#MAC下环境配置" class="headerlink" title="MAC下环境配置"></a>MAC下环境配置</h2><h3 id="下载ElasticSearch"><a href="#下载ElasticSearch" class="headerlink" title="下载ElasticSearch"></a>下载ElasticSearch</h3><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<h3 id="解压ElasticSearch"><a href="#解压ElasticSearch" class="headerlink" title="解压ElasticSearch"></a>解压ElasticSearch</h3><p>/Users/sicmatr1x/Develop/elasticsearch-7.6.1</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>使用管理员权限打开<code>/Users/sicmatr1x/.bash_profile</code></p>
<pre><code>export PATH=$PATH:/Users/sicmatr1x/Develop/elasticsearch-7.6.1/bin</code></pre><h3 id="运行ElasticSearch"><a href="#运行ElasticSearch" class="headerlink" title="运行ElasticSearch"></a>运行ElasticSearch</h3><pre><code class="shell">elasticsearch</code></pre>
<h3 id="测试ElasticSearch服务器"><a href="#测试ElasticSearch服务器" class="headerlink" title="测试ElasticSearch服务器"></a>测试ElasticSearch服务器</h3><pre><code>sicmatr1xMacBook-Pro:~ sicmatr1x$ curl http://localhost:9200
{
  &quot;name&quot; : &quot;sicmatr1xMacBook-Pro.local&quot;,
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;cluster_uuid&quot; : &quot;mIhriR4FTWquZLqg_7UBiA&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;7.6.1&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;tar&quot;,
    &quot;build_hash&quot; : &quot;aa751e09be0a5072e8570670309b1f12348f023b&quot;,
    &quot;build_date&quot; : &quot;2020-02-29T00:15:25.529771Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.4.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}</code></pre><h2 id="ElasticSearch与Spring-Boot集成"><a href="#ElasticSearch与Spring-Boot集成" class="headerlink" title="ElasticSearch与Spring Boot集成"></a>ElasticSearch与Spring Boot集成</h2><ul>
<li>ElasticSearch 2.4.4</li>
<li>Spring Data ElasticSearch 2.1.3.RELEASE</li>
<li>JNA 4.0.3 用于访问操作系统原生应用</li>
</ul>
<p>build.gradle</p>
<pre><code class="gradle">    // 添加  Spring Data Elasticsearch 的依赖
    compile(&#39;org.springframework.boot:spring-boot-starter-data-elasticsearch&#39;)

    // 添加  JNA 的依赖
    compile(&#39;net.java.dev.jna:jna:4.3.0&#39;)</code></pre>
<p>application.properties</p>
<pre><code class="properties"># Elasticsearch 服务地址
spring.data.elasticsearch.cluster-nodes=localhost:9300
# 设置连接超时时间
spring.data.elasticsearch.properties.transport.tcp.connect_timeout=120s</code></pre>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><h3 id="Received-message-from-unsupported-version-2-0-0-minimal-compatible-version-is-6-8-0"><a href="#Received-message-from-unsupported-version-2-0-0-minimal-compatible-version-is-6-8-0" class="headerlink" title="Received message from unsupported version: [2.0.0] minimal compatible version is: [6.8.0]"></a>Received message from unsupported version: [2.0.0] minimal compatible version is: [6.8.0]</h3><pre><code>java.lang.IllegalStateException: Received message from unsupported version: [2.0.0] minimal compatible version is: [6.8.0]
    at org.elasticsearch.transport.InboundMessage.ensureVersionCompatibility(InboundMessage.java:152) ~[elasticsearch-7.6.1.jar:7.6.1]
    at org.elasticsearch.transport.InboundMessage.access$000(InboundMessage.java:37) ~[elasticsearch-7.6.1.jar:7.6.1]
    at org.elasticsearch.transport.InboundMessage$Reader.deserialize(InboundMessage.java:70) ~[elasticsearch-7.6.1.jar:7.6.1]
    at org.elasticsearch.transport.InboundHandler.messageReceived(InboundHandler.java:114) ~[elasticsearch-7.6.1.jar:7.6.1]
    at org.elasticsearch.transport.InboundHandler.inboundMessage(InboundHandler.java:103) ~[elasticsearch-7.6.1.jar:7.6.1]
    at org.elasticsearch.transport.TcpTransport.inboundMessage(TcpTransport.java:667) [elasticsearch-7.6.1.jar:7.6.1]</code></pre><p>原因：spring boot是1.3.x版本，而es采用了2.x版本。在es的2.x版本去除了一些类，而这些类在spring boot的1.3.x版本中仍然被使用，导致此错误。</p>
<p>解决：依照问题1中的版本对应关系，启动特定版本的es即可。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-MAC-开发环境配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/07/MAC-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
    >MAC 开发环境配置</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/07/MAC-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2020-03-07T04:39:04.000Z" itemprop="datePublished">2020-03-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="MAC-设置环境变量path的几种方法"><a href="#MAC-设置环境变量path的几种方法" class="headerlink" title="MAC 设置环境变量path的几种方法"></a>MAC 设置环境变量path的几种方法</h2><p>Mac系统的环境变量，加载顺序为：</p>
<ol>
<li>/etc/profile: 系统级别的，系统启动就会加载</li>
<li>/etc/paths: 系统级别的，系统启动就会加载(全局建议修改这个文件)</li>
<li>~/.bash_profile: 这级开始往下为当前用户级的环境变量，若其中前面的文件存在则不继续往下读取(用户级建议修改这个文件)</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
<li>~/.bashrc</li>
</ol>
<pre><code>export M2_HOME=/Users/sicmatr1x/Documents/Develop/MAVEN/apache-maven-3.5.0
export PATH=$PATH:$M2_HOME/bin</code></pre><p>意思是在PATH变量后面加多一个目录，这个目录的值来自<code>M2_HOME</code>这个变量</p>
<p>查看变量值可以使用:</p>
<pre><code>sicmatr1xMacBook-Pro:~ sicmatr1x$ echo $M2_HOME
/Users/sicmatr1x/Documents/Develop/MAVEN/apache-maven-3.5.0</code></pre><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><pre><code>brew install mysql</code></pre><pre><code>To connect run:
    mysql -uroot

To have launchd start mysql now and restart at login:
  brew services start mysql
Or, if you don&#39;t want/need a background service you can just run:
  mysql.server start</code></pre><p>使用密码登录</p>
<pre><code>mysql -uroot -p</code></pre><!-- Friday13 -->

<p>执行安全设置</p>
<pre><code>mysql_secure_installation</code></pre><p>登录</p>
<pre><code>mysql -u root -p</code></pre><pre><code class="sql">create database blog default charset utf8 collate utf8_general_ci;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91/" rel="tag">踩坑</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-SpringBoot-踩坑"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/10/SpringBoot-%E8%B8%A9%E5%9D%91/"
    >SpringBoot-踩坑</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/02/10/SpringBoot-%E8%B8%A9%E5%9D%91/" class="article-date">
  <time datetime="2020-02-10T04:39:04.000Z" itemprop="datePublished">2020-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h3><h4 id="yml方式"><a href="#yml方式" class="headerlink" title="yml方式"></a>yml方式</h4><p>可将多个环境的配置放在一个<code>application.yml</code>文件里，使用<code>---</code>来进行分割:</p>
<pre><code class="yml">server:
  port: 8090
spring:
  profiles:
    active: dev

---
server:
  port: 8092
spring:
  profiles: dev
---
server:
  port: 8091
spring:
  profiles: prd
</code></pre>
<p>使用active属性来进行环境切换</p>
<hr>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><h3 id="MySQL-相关"><a href="#MySQL-相关" class="headerlink" title="MySQL 相关"></a>MySQL 相关</h3><h4 id="java-sql-SQLException-Unable-to-load-authentication-plugin-39-caching-sha2-password-39"><a href="#java-sql-SQLException-Unable-to-load-authentication-plugin-39-caching-sha2-password-39" class="headerlink" title="java.sql.SQLException: Unable to load authentication plugin &#39;caching_sha2_password&#39;."></a><code>java.sql.SQLException: Unable to load authentication plugin &#39;caching_sha2_password&#39;.</code></h4><p><em>出错原因</em>：</p>
<p>mysql 8.0 默认使用 caching_sha2_password 身份验证机制，而之前的版本默认使用 mysql_native_password 身份验证机制</p>
<p><em>解决办法</em>：</p>
<p>修改加密规则 ：</p>
<pre><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</code></pre><p>刷新权限：</p>
<pre><code>FLUSH PRIVILEGES;</code></pre><p>重置密码：</p>
<pre><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Friday13&#39;;</code></pre><h4 id="Unknown-system-variable-39-query-cache-size-39"><a href="#Unknown-system-variable-39-query-cache-size-39" class="headerlink" title="Unknown system variable &#39;query_cache_size&#39;"></a><code>Unknown system variable &#39;query_cache_size&#39;</code></h4><p><em>出错原因</em>：</p>
<p>mysql-connecter-java的版本过低，很显然是数据库驱动程序与数据库版本不对应</p>
<p><em>解决办法</em>：</p>
<p>如 mybatis使用 mysql-5.1.14的驱动程序，而mybatis配置的数据源连接的是 mysql-8.0.11 ，修改 pom文件即可</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.11&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<pre><code class="gradle">// 依赖关系
dependencies {
    // 添加 MySQL连接驱动 的依赖
    compile(&#39;mysql:mysql-connector-java:8.0.11&#39;)
}</code></pre>
<p>官方的说法是 :</p>
<p>The query cache is deprecated as of MySQL 5.7.20, and is removed in MySQL 8.0. Deprecation includes query_cache_size.</p>
<p>意思是query cache在MySQL5.7.20就已经过时了，而在MySQL8.0之后就已经被移除了。</p>
<p>下表从官网总结了可用的Connector / JDBC版本，以及JDBC驱动程序类型的详细信息，支持的JDBC API版本，支持的MySQL服务器版本，支持的JRE，构建所需的JDK以及每个连接器的支持状态/ JDBC版本</p>
<p><img src="MySQL-JDK-JRE版本对照表.png"></img></p>
<h4 id="运行程序不报错，单元测试报错java-lang-IllegalStateException-Failed-to-load-ApplicationContext"><a href="#运行程序不报错，单元测试报错java-lang-IllegalStateException-Failed-to-load-ApplicationContext" class="headerlink" title="运行程序不报错，单元测试报错java.lang.IllegalStateException: Failed to load ApplicationContext"></a>运行程序不报错，单元测试报错<code>java.lang.IllegalStateException: Failed to load ApplicationContext</code></h4><pre><code>Failed to load ApplicationContext
java.lang.IllegalStateException: Failed to load ApplicationContext
    at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124)
    at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83)
    at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189)
    at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131)
    at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230)
    ...
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;entityManagerFactory&#39; defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628)</code></pre><p><em>出错原因</em>：</p>
<p>有bean没有加上jpa注解</p>
<h4 id="SpringBoot无法访问-static下静态资源"><a href="#SpringBoot无法访问-static下静态资源" class="headerlink" title="SpringBoot无法访问/static下静态资源"></a>SpringBoot无法访问/static下静态资源</h4><p><em>出错原因</em>：</p>
<p><code>@EnableWebMvc</code>注解导致了<code>WebMvcAutoConfiguration</code>类没有生效</p>
<p><em>原因分析</em>：</p>
<p>SpringBoot 访问静态资源的规则，都在<code>WebMvcAutoConfiguration</code>自动配置类中</p>
<p><code>WebMvcAutoConfiguration.java</code>:</p>
<pre><code class="java">    @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
            if (!this.resourceProperties.isAddMappings()) {
                logger.debug(&quot;Default resource handling disabled&quot;);
                return;
            }
            Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
            CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
            if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
                customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
            }
            String staticPathPattern = this.mvcProperties.getStaticPathPattern();
            if (!registry.hasMappingForPattern(staticPathPattern)) {
                customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                        .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
            }
        }</code></pre>
<p><code>ResourceProperties.java</code>:</p>
<pre><code class="java">    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { &quot;classpath:/META-INF/resources/&quot;,
            &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; };

    /**
     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
     * /resources/, /static/, /public/].
     */
    private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;

  //...

    public String[] getStaticLocations() {
        return this.staticLocations;
    }</code></pre>
<p>默认按照该(<code>CLASSPATH_RESOURCE_LOCATIONS</code>)加载顺序，加载静态资源文件</p>
<p>继续看<code>WebMvcAutoConfiguration.java</code>:</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
        ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
  //...
}</code></pre>
<p>发现有以下注解<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>: 在WebMvcConfigurationSupport.class这个类没有的情况下，才会走SpringBoot的Web自动配置</p>
<p><code>@EnableWebMvc.java</code>:</p>
<pre><code class="java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}</code></pre>
<p><code>DelegatingWebMvcConfiguration.java</code>:</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
  //...
}</code></pre>
<p>可以看到<code>@EnableWebMvc</code>注解加载了<code>DelegatingWebMvcConfiguration.class</code>类，而这个类又继承了<code>WebMvcConfigurationSupport</code>类</p>
<p><em>解决办法</em>：去掉<code>@EnableWebMvc</code>注解</p>
<blockquote>

<p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type WebMvcConfigurer but without <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
</blockquote>

<p><em>官方解释</em>：<a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-auto-configuration</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91/" rel="tag">踩坑</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-JavaScript 设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/06/JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >JavaScript 设计模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/12/06/JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2019-12-06T09:11:36.000Z" itemprop="datePublished">2019-12-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>
</li>
<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用。应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>
</li>
<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改。当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>
</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<pre><code class="js">function SetManager(name) {
    this.manager = name;
}

SetManager.prototype.getName = function() {
    console.log(this.manager);
};

var SingletonSetManager = (function() {
    var manager = null;

    return function(name) {
        if (!manager) {
            manager = new SetManager(name);
        }

        return manager;
    }
})();

SingletonSetManager(&#39;a&#39;).getName(); // a
SingletonSetManager(&#39;b&#39;).getName(); // a
SingletonSetManager(&#39;c&#39;).getName(); // a</code></pre>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<p>将算法的使用和算法的实现分离开来。</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<p>第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。</p>
<p>第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context 中要维持对某个策略对象的引用</p>
<pre><code class="js">// 加权映射关系
var levelMap = {
    S: 10,
    A: 8,
    B: 6,
    C: 4
};

// 组策略
var scoreLevel = {
    basicScore: 80,

    S: function() {
        return this.basicScore + levelMap[&#39;S&#39;]; 
    },

    A: function() {
        return this.basicScore + levelMap[&#39;A&#39;]; 
    },

    B: function() {
        return this.basicScore + levelMap[&#39;B&#39;]; 
    },

    C: function() {
        return this.basicScore + levelMap[&#39;C&#39;]; 
    }
}

// 调用
function getScore(level) {
    return scoreLevel[level] ? scoreLevel[level]() : 0;
}

console.log(
    getScore(&#39;S&#39;),
    getScore(&#39;A&#39;),
    getScore(&#39;B&#39;),
    getScore(&#39;C&#39;),
    getScore(&#39;D&#39;)
); // 90 88 86 84 0</code></pre>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。</p>
<p>替身对象对请求做出一些处理之后， 再把请求转交给本体对象</p>
<p>代理和本体的接口具有一致性，本体定义了关键功能，而代理是提供或拒绝对它的访问，或者在访问本体之前做一 些额外的事情</p>
<p>代理模式主要有三种：保护代理、虚拟代理、缓存代理</p>
<pre><code class="js">// 主体，发送消息
function sendMsg(msg) {
    console.log(msg);
}

// 代理，对消息进行过滤
function proxySendMsg(msg) {
    // 无消息则直接返回
    if (typeof msg === &#39;undefined&#39;) {
        console.log(&#39;deny&#39;);
        return;
    }

    // 有消息则进行过滤
    msg = (&#39;&#39; + msg).replace(/泥\s*煤/g, &#39;&#39;);

    sendMsg(msg);
}


sendMsg(&#39;泥煤呀泥 煤呀&#39;); // 泥煤呀泥 煤呀
proxySendMsg(&#39;泥煤呀泥 煤&#39;); // 呀
proxySendMsg(); // deny</code></pre>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<p>在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</p>
<pre><code class="js">function each(obj, cb) {
    var value;

    if (Array.isArray(obj)) {
        for (var i = 0; i &lt; obj.length; ++i) {
            value = cb.call(obj[i], i, obj[i]);

            if (value === false) {
                break;
            }
        }
    } else {
        for (var i in obj) {
            value = cb.call(obj[i], i, obj[i]);

            if (value === false) {
                break;
            }
        }
    }
}

each([1, 2, 3], function(index, value) {
    console.log(index, value);
});

each({a: 1, b: 2}, function(index, value) {
    console.log(index, value);
});

// 0 1
// 1 2
// 2 3

// a 1
// b 2</code></pre>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><p>也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知</p>
<p>取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。</p>
<p>与传统的发布-订阅模式实现方式（将订阅者自身当成引用传入发布者）不同，在JS中通常使用注册回调函数的形式来订阅</p>
<pre><code class="js">// 订阅
document.body.addEventListener(&#39;click&#39;, function() {
    console.log(&#39;click1&#39;);
}, false);

document.body.addEventListener(&#39;click&#39;, function() {
    console.log(&#39;click2&#39;);
}, false);

// 发布
document.body.click(); // click1  click2</code></pre>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系</p>
<p>命令（command）指的是一个执行某些特定事情的指令</p>
<p>命令中带有execute执行、undo撤销、redo重做等相关命令方法，建议显示地指示这些方法名</p>
<pre><code class="js">// 自增
function IncrementCommand() {
    // 当前值
    this.val = 0;
    // 命令栈
    this.stack = [];
    // 栈指针位置
    this.stackPosition = -1;
};

IncrementCommand.prototype = {
    constructor: IncrementCommand,

    // 执行
    execute: function() {
        this._clearRedo();

        // 定义执行的处理
        var command = function() {
            this.val += 2;
        }.bind(this);

        // 执行并缓存起来
        command();

        this.stack.push(command);

        this.stackPosition++;

        this.getValue();
    },

    canUndo: function() {
        return this.stackPosition &gt;= 0;
    },

    canRedo: function() {
        return this.stackPosition &lt; this.stack.length - 1;
    },

    // 撤销
    undo: function() {
        if (!this.canUndo()) {
            return;
        }

        this.stackPosition--;

        // 命令的撤销，与执行的处理相反
        var command = function() {
            this.val -= 2;
        }.bind(this);

        // 撤销后不需要缓存
        command();

        this.getValue();
    },

    // 重做
    redo: function() {
        if (!this.canRedo()) {
            return;
        }

        // 执行栈顶的命令
        this.stack[++this.stackPosition]();

        this.getValue();
    },

    // 在执行时，已经撤销的部分不能再重做
    _clearRedo: function() {
        this.stack = this.stack.slice(0, this.stackPosition + 1);
    },

    // 获取当前值
    getValue: function() {
        console.log(this.val);
    }
};</code></pre>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>是用小的子对象来构建更大的 对象，而这些小的子对象本身也许是由更小 的“孙对象”构成的。</p>
<p>可以用树形结构来表示这种“部分- 整体”的层次结构。</p>
<p>调用组合对象 的execute方法，程序会递归调用组合对象 下面的叶对象的execute方法</p>
<p>但要注意的是，组合模式不是父子关系，它是一种HAS-A（聚合）的关系，将请求委托给它所包含的所有叶对象。基于这种委托，就需要保证组合对象和叶对象拥有相同的接口</p>
<p>此外，也要保证用一致的方式对待 列表中的每个叶对象，即叶对象属于同一类，不需要过多特殊的额外操作</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。</p>
<p>在抽象父类中封装子类的算法框架，它的 init方法可作为一个算法的模板，指导子类以何种顺序去执行哪些方法。</p>
<p>由父类分离出公共部分，要求子类重写某些父类的（易变化的）抽象方法</p>
<p>模板方法模式一般的实现方式为继承</p>
<p>以运动作为例子，运动有比较通用的一些处理，这部分可以抽离开来，在父类中实现。具体某项运动的特殊性则有自类来重写实现。</p>
<p>最终子类直接调用父类的模板函数来执行</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/06/Redis/"
    >Redis</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/12/06/Redis/" class="article-date">
  <time datetime="2019-12-06T09:02:36.000Z" itemprop="datePublished">2019-12-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
<h2 id="缓存中间件-Memcache和Redis的区别"><a href="#缓存中间件-Memcache和Redis的区别" class="headerlink" title="缓存中间件 Memcache和Redis的区别"></a>缓存中间件 <a href="https://www.memcached.org/" target="_blank" rel="noopener">Memcache</a>和<a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>的区别</h2><ul>
<li>Memcache：代码层次类似Hash<ul>
<li>支持简单数据类型</li>
<li>不支持数据持久化存储</li>
<li>不支持主从</li>
<li>不支持分片</li>
</ul>
</li>
<li>Redis：<ul>
<li>数据类型丰富<ul>
<li>string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</li>
</ul>
</li>
<li>支持数据持久化存储</li>
<li>支持主从</li>
<li>支持分片</li>
</ul>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>启动服务器：</p>
<pre><code>redis-server.exe redis.windows.conf</code></pre><p>连接服务器：</p>
<pre><code>redis-cli.exe -h 127.0.0.1 -p 6379</code></pre><p>键值对操作：</p>
<pre><code>set myKey abc
get myKey
DEL myKey</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。</p>
<h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><p>Redis CONFIG 命令格式如下:<code>CONFIG GET CONFIG_SETTING_NAME</code></p>
<pre><code>CONFIG GET loglevel</code></pre><h4 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h4><p>CONFIG SET 命令基本语法：<code>CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</code></p>
<pre><code>CONFIG SET loglevel &quot;notice&quot;</code></pre><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><h4 id="Q-从海量Key里查询出某一固定前缀的Key"><a href="#Q-从海量Key里查询出某一固定前缀的Key" class="headerlink" title="Q: 从海量Key里查询出某一固定前缀的Key"></a>Q: 从海量Key里查询出某一固定前缀的Key</h4><ul>
<li>摸清数据规模，问清楚边界</li>
</ul>
<p>使用指令 <code>KEYS pattern</code> 可以查找所有符合给定模式pattern的key</p>
<pre><code>KEYS pattern
KEYS tes*</code></pre><p>缺点：</p>
<ul>
<li>KEYS指令一次性返回所有匹配的key可能会因为key数量过大使服务器卡顿</li>
</ul>
<p>解决：使用SCAN指令无阻塞提取</p>
<pre><code>SCAN cursor [MATCH pattern] [COUNT count]</code></pre><ul>
<li>SCAN指令使用到了一个基于游标的迭代器，需要基于上一次的游标来延续之前的迭代过程</li>
<li>以0作为游标的开始来开启新的迭代，直到命令返回游标0完成一次遍历</li>
</ul>
<p>缺点：一次返回的数量不可控，只能是大概率符合count参数。可能会返回重复的key，可以使用Set来接返回的数据</p>
<p>从0开始迭代匹配<code>tes*</code>的key，一次返回10条结果，把上一次返回的结果中的位置设置成下一次的cursor</p>
<pre><code>SCAN 0 match tes* count 10</code></pre><h4 id="Q-使用Redis实现分布式锁"><a href="#Q-使用Redis实现分布式锁" class="headerlink" title="Q: 使用Redis实现分布式锁"></a>Q: 使用Redis实现分布式锁</h4><p>特性：</p>
<ul>
<li>互斥性：任意时刻只能有一个客户端获取锁</li>
<li>安全性：锁只能被持有该锁的客户端删除</li>
<li>死锁：若获取锁的客户端宕机则可能会导致死锁</li>
<li>容错：部分redis结点宕机时，客户端仍要能够获取锁和释放锁</li>
</ul>
<p>可以使用指令SETNX key value: 如果key不存在，则创建并赋值</p>
<ul>
<li>时间复杂度O(1)</li>
<li>返回值：1:成功, 0:失败</li>
</ul>
<pre><code>setnx locknx test</code></pre><p>客户端可以先set locknx然后执行对应操作，此时如果有其它客户端想要获得锁会set不成功</p>
<p>缺点：存在长期有效问题，即不会过期</p>
<p>解决方法：使用有过期时间的指令：EXPIRE key seconds</p>
<pre><code>setnx locknx test
expire locknx 2</code></pre><p>缺点：若程序执行完setnx locknx就挂了，就不会设置超时时间也不会释放锁</p>
<p>解决方法：使用指令 SET key value [EX seconds] [PX milliseconds] [NX|XX]</p>
<ul>
<li>EX second: 设置键的过期时间为 second秒</li>
<li>PX millisecond: 设置键的过期时间为 millisecond毫秒</li>
<li>NX: 只在键不存在时，才对键进行设置操作</li>
<li>XX: 只在键已经存在时，才对键进行设置操作</li>
<li>SET操作完成时，返回OK，否则返回nil</li>
</ul>
<pre><code>set locktarget 12345 ex 10 nx</code></pre><h4 id="Q-大量key同时过期的注意事项"><a href="#Q-大量key同时过期的注意事项" class="headerlink" title="Q: 大量key同时过期的注意事项"></a>Q: 大量key同时过期的注意事项</h4><p>大量key集中过期时，由于清除大量的key很耗时，会出现短暂卡顿现象</p>
<p>解决方案：</p>
<ul>
<li>在设置key过期时间的时候加一个随机偏移时间</li>
</ul>
<h4 id="Q-如何使用Redis做异步队列"><a href="#Q-如何使用Redis做异步队列" class="headerlink" title="Q: 如何使用Redis做异步队列"></a>Q: 如何使用Redis做异步队列</h4><p>使用List作为队列，RPUSH生产消息，LPOP消费消息</p>
<pre><code>rpush testlist aaa
rpush testlist bbb
rpush testlist ccc
lpop testlist
lpop testlist</code></pre><p>缺点：</p>
<ul>
<li>没有等待队列里有值就直接消费</li>
</ul>
<p>解决：</p>
<ol>
<li>通过在应用层引入Sleep机制去调用LPOP重试</li>
<li>或使用指令BLPOP key [key…] timeout: 阻塞直到队列有消息或超时<ul>
<li>缺点：只能供一个消费者消费<ul>
<li>解决：使用pub/sub主题订阅者模式<ul>
<li>缺点：消息的发布是无状态的，无法保证可达</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<p>Redis底层数据类型基础：</p>
<ul>
<li>简单动态字符串</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>数据集合</li>
<li>压缩列表</li>
<li>对象</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string 类型是二进制安全的(可以包含任何数据，比如jpg)。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<pre><code>SET chinese &quot;中文&quot;
get chinese</code></pre><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<p>HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。每个 hash 可以存储 232 -1 键值对（40多亿）。</p>
<pre><code>HMSET test field1 &quot;Hello&quot; field2 &quot;World&quot;
HGET test field1
HGET test field2</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)</p>
<pre><code>lpush testList redis
lpush testList mongodb
lpush testList rabitmq
lrange testList 0 10</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<p>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p>
<pre><code>sadd testSet redis
sadd testSet mongodb
sadd testSet rabitmq
sadd testSet rabitmq
smembers testSet</code></pre><h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<pre><code>zadd testZset 0 redis
zadd testZset 0.3 mongodb
zadd testZset 0.1 rabitmq
zadd testZset 9.9 solace
ZRANGEBYSCORE testZset 0 1000</code></pre><h3 id="各数据结构的应用场景"><a href="#各数据结构的应用场景" class="headerlink" title="各数据结构的应用场景"></a>各数据结构的应用场景</h3><table class="reference">
<thead><tr>
<th>类型</th>
<th>简介</th>
<th>特性</th>
<th>场景</th>
</tr></thead>
<tbody>
<tr>
<td>String(字符串)</td>
<td>二进制安全</td>
<td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
<td>---</td>
</tr>
<tr>
<td>Hash(字典)</td>
<td>键值对集合,即编程语言中的Map类型</td>
<td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
<td>存储、读取、修改用户属性</td>
</tr>
<tr>
<td>List(列表)</td>
<td>链表(双向链表)</td>
<td>增删快,提供了操作某一段元素的API</td>
<td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td>
</tr>
<tr>
<td>Set(集合)</td>
<td>哈希表实现,元素不重复</td>
<td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
<td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td>
</tr>
<tr>
<td>Sorted Set(有序集合)</td>
<td>将Set中的元素增加一个权重参数score,元素按score有序排列</td>
<td>数据插入集合时,已经进行天然排序</td>
<td>1、排行榜 2、带权重的消息队列</td>
</tr>
</tbody>
</table>

<h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><p>启动 redis 客户端：</p>
<pre><code>redis-cli</code></pre><pre><code>PING</code></pre><p>连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p>
<pre><code>redis-cli -h host -p port -a password
redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</code></pre><h3 id="Redis-keys-命令"><a href="#Redis-keys-命令" class="headerlink" title="Redis keys 命令"></a>Redis keys 命令</h3><ol>
<li>DEL key<ul>
<li>该命令用于在 key 存在时删除 key。</li>
</ul>
</li>
<li>DUMP key <ul>
<li>序列化给定 key ，并返回被序列化的值。</li>
</ul>
</li>
<li>EXISTS key <ul>
<li>检查给定 key 是否存在。</li>
</ul>
</li>
<li>EXPIRE key seconds<ul>
<li>为给定 key 设置过期时间，以秒计。</li>
</ul>
</li>
<li>EXPIREAT key timestamp <ul>
<li>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</li>
</ul>
</li>
<li>PEXPIRE key milliseconds <ul>
<li>设置 key 的过期时间以毫秒计。</li>
</ul>
</li>
<li>PEXPIREAT key milliseconds-timestamp <ul>
<li>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</li>
</ul>
</li>
<li>KEYS pattern <ul>
<li>查找所有符合给定模式( pattern)的 key 。</li>
</ul>
</li>
<li>MOVE key db <ul>
<li>将当前数据库的 key 移动到给定的数据库 db 当中。</li>
</ul>
</li>
<li>PERSIST key <ul>
<li>移除 key 的过期时间，key 将持久保持。</li>
</ul>
</li>
<li>PTTL key <ul>
<li>以毫秒为单位返回 key 的剩余的过期时间。</li>
</ul>
</li>
<li>TTL key <ul>
<li>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</li>
</ul>
</li>
<li>RANDOMKEY <ul>
<li>从当前数据库中随机返回一个 key 。</li>
</ul>
</li>
<li>RENAME key newkey <ul>
<li>修改 key 的名称</li>
</ul>
</li>
<li>RENAMENX key newkey <ul>
<li>仅当 newkey 不存在时，将 key 改名为 newkey 。</li>
</ul>
</li>
<li>TYPE key <ul>
<li>返回 key 所储存的值的类型。</li>
</ul>
</li>
</ol>
<h3 id="Redis-字符串命令"><a href="#Redis-字符串命令" class="headerlink" title="Redis 字符串命令"></a>Redis 字符串命令</h3><ol>
<li>SET key value <ul>
<li>置指定 key 的值</li>
</ul>
</li>
<li>GET key <ul>
<li>取指定 key 的值。</li>
</ul>
</li>
<li>GETRANGE key start end <ul>
<li>回 key 中字符串值的子字符</li>
</ul>
</li>
<li>GETSET key value<ul>
<li>给定 key 的值设为 value ，并返回 key 的旧值(old value)。</li>
</ul>
</li>
<li>GETBIT key offset<ul>
<li>key 所储存的字符串值，获取指定偏移量上的位(bit)。</li>
</ul>
</li>
<li>MGET key1 [key2..]<ul>
<li>取所有(一个或多个)给定 key 的值。</li>
</ul>
</li>
<li>SETBIT key offset value<ul>
<li>key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</li>
</ul>
</li>
<li>SETEX key seconds value<ul>
<li>值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</li>
</ul>
</li>
<li>SETNX key value<ul>
<li>有在 key 不存在时设置 key 的值。</li>
</ul>
</li>
<li>SETRANGE key offset value<ul>
<li>value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</li>
</ul>
</li>
<li>STRLEN key<ul>
<li>回 key 所储存的字符串值的长度。</li>
</ul>
</li>
<li>MSET key value [key value …]<ul>
<li>时设置一个或多个 key-value 对。</li>
</ul>
</li>
<li>MSETNX key value [key value …] <ul>
<li>时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</li>
</ul>
</li>
<li>PSETEX key milliseconds value<ul>
<li>个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</li>
</ul>
</li>
<li>INCR key<ul>
<li>key 中储存的数字值增一。</li>
</ul>
</li>
<li>INCRBY key increment<ul>
<li>key 所储存的值加上给定的增量值（increment） 。</li>
</ul>
</li>
<li>INCRBYFLOAT key increment<ul>
<li>key 所储存的值加上给定的浮点增量值（increment） 。</li>
</ul>
</li>
<li>DECR key<ul>
<li>key 中储存的数字值减一。</li>
</ul>
</li>
<li>DECRBY key decrement<ul>
<li>key 所储存的值减去给定的减量值（decrement） 。</li>
</ul>
</li>
<li>APPEND key value<ul>
<li>果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</li>
</ul>
</li>
</ol>
<h3 id="Redis-hash-命令"><a href="#Redis-hash-命令" class="headerlink" title="Redis hash 命令"></a>Redis hash 命令</h3><ol>
<li>HDEL key field1 [field2] <ul>
<li>除一个或多个哈希表字段</li>
</ul>
</li>
<li>HEXISTS key field <ul>
<li>看哈希表 key 中，指定的字段是否存在。</li>
</ul>
</li>
<li>HGET key field <ul>
<li>取存储在哈希表中指定字段的值。</li>
</ul>
</li>
<li>HGETALL key <ul>
<li>取在哈希表中指定 key 的所有字段和值</li>
</ul>
</li>
<li>HINCRBY key field increment <ul>
<li>哈希表 key 中的指定字段的整数值加上增量 increment 。</li>
</ul>
</li>
<li>HINCRBYFLOAT key field increment <ul>
<li>哈希表 key 中的指定字段的浮点数值加上增量 increment 。</li>
</ul>
</li>
<li>HKEYS key <ul>
<li>取所有哈希表中的字段</li>
</ul>
</li>
<li>HLEN key <ul>
<li>取哈希表中字段的数量</li>
</ul>
</li>
<li>HMGET key field1 [field2] <ul>
<li>取所有给定字段的值</li>
</ul>
</li>
<li>HMSET key field1 value1 [field2 value2 ] <ul>
<li>时将多个 field-value (域-值)对设置到哈希表 key 中。</li>
</ul>
</li>
<li>HSET key field value <ul>
<li>哈希表 key 中的字段 field 的值设为 value 。</li>
</ul>
</li>
<li>HSETNX key field value <ul>
<li>有在字段 field 不存在时，设置哈希表字段的值。</li>
</ul>
</li>
<li>HVALS key <ul>
<li>取哈希表中所有值</li>
</ul>
</li>
<li>HSCAN key cursor [MATCH pattern] [COUNT count] <ul>
<li>代哈希表中的键值对。</li>
</ul>
</li>
</ol>
<h3 id="Redis-列表命令"><a href="#Redis-列表命令" class="headerlink" title="Redis 列表命令"></a>Redis 列表命令</h3><ol>
<li>BLPOP key1 [key2 ] timeout <ul>
<li>出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
</ul>
</li>
<li>BRPOP key1 [key2 ] timeout <ul>
<li>出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
</ul>
</li>
<li>BRPOPLPUSH source destination timeout <ul>
<li>列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
</ul>
</li>
<li>LINDEX key index <ul>
<li>过索引获取列表中的元素</li>
</ul>
</li>
<li>LINSERT key BEFORE|AFTER pivot value <ul>
<li>列表的元素前或者后插入元素</li>
</ul>
</li>
<li>LLEN key <ul>
<li>取列表长度</li>
</ul>
</li>
<li>LPOP key <ul>
<li>出并获取列表的第一个元素</li>
</ul>
</li>
<li>LPUSH key value1 [value2] <ul>
<li>一个或多个值插入到列表头部</li>
</ul>
</li>
<li>LPUSHX key value <ul>
<li>一个值插入到已存在的列表头部</li>
</ul>
</li>
<li>LRANGE key start stop <ul>
<li>取列表指定范围内的元素</li>
</ul>
</li>
<li>LREM key count value <ul>
<li>除列表元素</li>
</ul>
</li>
<li>LSET key index value <ul>
<li>过索引设置列表元素的值</li>
</ul>
</li>
<li>LTRIM key start stop <ul>
<li>一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</li>
</ul>
</li>
<li>RPOP key <ul>
<li>除列表的最后一个元素，返回值为移除的元素。</li>
</ul>
</li>
<li>RPOPLPUSH source destination <ul>
<li>除列表的最后一个元素，并将该元素添加到另一个列表并返回</li>
</ul>
</li>
<li>RPUSH key value1 [value2] <ul>
<li>列表中添加一个或多个值</li>
</ul>
</li>
<li>RPUSHX key value <ul>
<li>已存在的列表添加值</li>
</ul>
</li>
</ol>
<h3 id="Redis-集合命令"><a href="#Redis-集合命令" class="headerlink" title="Redis 集合命令"></a>Redis 集合命令</h3><ol>
<li>SADD key member1 [member2] <ul>
<li>集合添加一个或多个成员</li>
</ul>
</li>
<li>SCARD key <ul>
<li>取集合的成员数</li>
</ul>
</li>
<li>SDIFF key1 [key2] <ul>
<li>回给定所有集合的差集</li>
</ul>
</li>
<li>SDIFFSTORE destination key1 [key2] <ul>
<li>回给定所有集合的差集并存储在 destination 中</li>
</ul>
</li>
<li>SINTER key1 [key2] <ul>
<li>回给定所有集合的交集</li>
</ul>
</li>
<li>SINTERSTORE destination key1 [key2] <ul>
<li>回给定所有集合的交集并存储在 destination 中</li>
</ul>
</li>
<li>SISMEMBER key member <ul>
<li>断 member 元素是否是集合 key 的成员</li>
</ul>
</li>
<li>SMEMBERS key <ul>
<li>回集合中的所有成员</li>
</ul>
</li>
<li>SMOVE source destination member <ul>
<li>member 元素从 source 集合移动到 destination 集合</li>
</ul>
</li>
<li>SPOP key <ul>
<li>除并返回集合中的一个随机元素</li>
</ul>
</li>
<li>SRANDMEMBER key [count] <ul>
<li>回集合中一个或多个随机数</li>
</ul>
</li>
<li>SREM key member1 [member2] <ul>
<li>除集合中一个或多个成员</li>
</ul>
</li>
<li>SUNION key1 [key2] <ul>
<li>回所有给定集合的并集</li>
</ul>
</li>
<li>SUNIONSTORE destination key1 [key2] <ul>
<li>有给定集合的并集存储在 destination 集合中</li>
</ul>
</li>
<li>SSCAN key cursor [MATCH pattern] [COUNT count] <ul>
<li>代集合中的元素</li>
</ul>
</li>
</ol>
<h3 id="Redis-有序集合命令"><a href="#Redis-有序集合命令" class="headerlink" title="Redis 有序集合命令"></a>Redis 有序集合命令</h3><ol>
<li>ZADD key score1 member1 [score2 member2] <ul>
<li>有序集合添加一个或多个成员，或者更新已存在成员的分数</li>
</ul>
</li>
<li>ZCARD key <ul>
<li>取有序集合的成员数</li>
</ul>
</li>
<li>ZCOUNT key min max <ul>
<li>算在有序集合中指定区间分数的成员数</li>
</ul>
</li>
<li>ZINCRBY key increment member <ul>
<li>序集合中对指定成员的分数加上增量 increment</li>
</ul>
</li>
<li>ZINTERSTORE destination numkeys key [key …] <ul>
<li>算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li>
</ul>
</li>
<li>ZLEXCOUNT key min max <ul>
<li>有序集合中计算指定字典区间内成员数量</li>
</ul>
</li>
<li>ZRANGE key start stop [WITHSCORES] <ul>
<li>过索引区间返回有序集合指定区间内的成员</li>
</ul>
</li>
<li>ZRANGEBYLEX key min max [LIMIT offset count] <ul>
<li>过字典区间返回有序集合的成员</li>
</ul>
</li>
<li>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] <ul>
<li>过分数返回有序集合指定区间内的成员</li>
</ul>
</li>
<li>ZRANK key member <ul>
<li>回有序集合中指定成员的索引</li>
</ul>
</li>
<li>ZREM key member [member …] <ul>
<li>除有序集合中的一个或多个成员</li>
</ul>
</li>
<li>ZREMRANGEBYLEX key min max <ul>
<li>除有序集合中给定的字典区间的所有成员</li>
</ul>
</li>
<li>ZREMRANGEBYRANK key start stop <ul>
<li>除有序集合中给定的排名区间的所有成员</li>
</ul>
</li>
<li>ZREMRANGEBYSCORE key min max <ul>
<li>除有序集合中给定的分数区间的所有成员</li>
</ul>
</li>
<li>ZREVRANGE key start stop [WITHSCORES] <ul>
<li>回有序集中指定区间内的成员，通过索引，分数从高到底</li>
</ul>
</li>
<li>ZREVRANGEBYSCORE key max min [WITHSCORES] <ul>
<li>回有序集中指定分数区间内的成员，分数从高到低排序</li>
</ul>
</li>
<li>ZREVRANK key member <ul>
<li>回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li>
</ul>
</li>
<li>ZSCORE key member <ul>
<li>回有序集中，成员的分数值</li>
</ul>
</li>
<li>ZUNIONSTORE destination numkeys key [key …] <ul>
<li>算给定的一个或多个有序集的并集，并存储在新的 key 中</li>
</ul>
</li>
<li>ZSCAN key cursor [MATCH pattern] [COUNT count] <ul>
<li>代有序集合中的元素（包括元素成员和元素分值）</li>
</ul>
</li>
</ol>
<h3 id="Redis-HyperLogLog-命令"><a href="#Redis-HyperLogLog-命令" class="headerlink" title="Redis HyperLogLog 命令"></a>Redis HyperLogLog 命令</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<ol>
<li>PFADD key element [element …] <ul>
<li>加指定元素到 HyperLogLog 中。</li>
</ul>
</li>
<li>PFCOUNT key [key …] <ul>
<li>回给定 HyperLogLog 的基数估算值。</li>
</ul>
</li>
<li>PFMERGE destkey sourcekey [sourcekey …] <ul>
<li>多个 HyperLogLog 合并为一个 HyperLogLog</li>
</ul>
</li>
</ol>
<h3 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h3><ol>
<li>PSUBSCRIBE pattern [pattern …] <ul>
<li>阅一个或多个符合给定模式的频道。</li>
</ul>
</li>
<li>PUBSUB subcommand [argument [argument …]] <ul>
<li>看订阅与发布系统状态。</li>
</ul>
</li>
<li>PUBLISH channel message <ul>
<li>信息发送到指定的频道。</li>
</ul>
</li>
<li>PUNSUBSCRIBE [pattern [pattern …]] <ul>
<li>订所有给定模式的频道。</li>
</ul>
</li>
<li>SUBSCRIBE channel [channel …] <ul>
<li>阅给定的一个或多个频道的信息。</li>
</ul>
</li>
<li>UNSUBSCRIBE [channel [channel …]] <ul>
<li>退订给定的频道。</li>
</ul>
</li>
</ol>
<h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令<strong>依然被执行</strong>。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<ol>
<li>DISCARD <ul>
<li>消事务，放弃执行事务块内的所有命令。</li>
</ul>
</li>
<li>EXEC <ul>
<li>行所有事务块内的命令。</li>
</ul>
</li>
<li>MULTI <ul>
<li>记一个事务块的开始。</li>
</ul>
</li>
<li>UNWATCH <ul>
<li>消 WATCH 命令对所有 key 的监视。</li>
</ul>
</li>
<li>WATCH key [key …] <ul>
<li>视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li>
</ul>
</li>
</ol>
<h3 id="Redis-脚本命令"><a href="#Redis-脚本命令" class="headerlink" title="Redis 脚本命令"></a>Redis 脚本命令</h3><ol>
<li>EVAL script numkeys key [key …] arg [arg …] <ul>
<li>行 Lua 脚本。</li>
</ul>
</li>
<li>EVALSHA sha1 numkeys key [key …] arg [arg …] <ul>
<li>行 Lua 脚本。</li>
</ul>
</li>
<li>SCRIPT EXISTS script [script …] <ul>
<li>看指定的脚本是否已经被保存在缓存当中。</li>
</ul>
</li>
<li>SCRIPT FLUSH <ul>
<li>脚本缓存中移除所有脚本。</li>
</ul>
</li>
<li>SCRIPT KILL <ul>
<li>死当前正在运行的 Lua 脚本。</li>
</ul>
</li>
<li>SCRIPT LOAD script <ul>
<li>脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</li>
</ul>
</li>
</ol>
<h3 id="Redis-连接命令"><a href="#Redis-连接命令" class="headerlink" title="Redis 连接命令"></a>Redis 连接命令</h3><ol>
<li>AUTH password <ul>
<li>证密码是否正确</li>
</ul>
</li>
<li>ECHO message <ul>
<li>印字符串</li>
</ul>
</li>
<li>PING <ul>
<li>看服务是否运行</li>
</ul>
</li>
<li>QUIT <ul>
<li>闭当前连接</li>
</ul>
</li>
<li>SELECT index <ul>
<li>换到指定的数据库</li>
</ul>
</li>
</ol>
<pre><code>redis 127.0.0.1:6379&gt; AUTH PASSWORD
(error) ERR Client sent AUTH, but no password is set
redis 127.0.0.1:6379&gt; CONFIG SET requirepass &quot;mypass&quot;
OK
redis 127.0.0.1:6379&gt; AUTH mypass
Ok</code></pre><h3 id="Redis-服务器命令"><a href="#Redis-服务器命令" class="headerlink" title="Redis 服务器命令"></a>Redis 服务器命令</h3><ol>
<li>BGREWRITEAOF <ul>
<li>步执行一个 AOF（AppendOnly File） 文件重写操作</li>
</ul>
</li>
<li>BGSAVE <ul>
<li>后台异步保存当前数据库的数据到磁盘</li>
</ul>
</li>
<li>CLIENT KILL [ip:port] [ID client-id] <ul>
<li>闭客户端连接</li>
</ul>
</li>
<li>CLIENT LIST <ul>
<li>取连接到服务器的客户端连接列表</li>
</ul>
</li>
<li>CLIENT GETNAME <ul>
<li>取连接的名称</li>
</ul>
</li>
<li>CLIENT PAUSE timeout <ul>
<li>指定时间内终止运行来自客户端的命令</li>
</ul>
</li>
<li>CLIENT SETNAME connection-name <ul>
<li>置当前连接的名称</li>
</ul>
</li>
<li>CLUSTER SLOTS <ul>
<li>取集群节点的映射数组</li>
</ul>
</li>
<li>COMMAND <ul>
<li>取 Redis 命令详情数组</li>
</ul>
</li>
<li>COMMAND COUNT <ul>
<li>取 Redis 命令总数</li>
</ul>
</li>
<li>COMMAND GETKEYS <ul>
<li>取给定命令的所有键</li>
</ul>
</li>
<li>TIME <ul>
<li>回当前服务器时间</li>
</ul>
</li>
<li>COMMAND INFO command-name [command-name …] <ul>
<li>取指定 Redis 命令描述的数组</li>
</ul>
</li>
<li>CONFIG GET parameter <ul>
<li>取指定配置参数的值</li>
</ul>
</li>
<li>CONFIG REWRITE <ul>
<li>启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写</li>
</ul>
</li>
<li>CONFIG SET parameter value <ul>
<li>改 redis 配置参数，无需重启</li>
</ul>
</li>
<li>CONFIG RESETSTAT <ul>
<li>置 INFO 命令中的某些统计数据</li>
</ul>
</li>
<li>DBSIZE <ul>
<li>回当前数据库的 key 的数量</li>
</ul>
</li>
<li>DEBUG OBJECT key <ul>
<li>取 key 的调试信息</li>
</ul>
</li>
<li>DEBUG SEGFAULT <ul>
<li>Redis 服务崩溃</li>
</ul>
</li>
<li>FLUSHALL <ul>
<li>除所有数据库的所有key</li>
</ul>
</li>
<li>FLUSHDB <ul>
<li>除当前数据库的所有key</li>
</ul>
</li>
<li>INFO [section] <ul>
<li>取 Redis 服务器的各种信息和统计数值</li>
</ul>
</li>
<li>LASTSAVE <ul>
<li>回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</li>
</ul>
</li>
<li>MONITOR <ul>
<li>时打印出 Redis 服务器接收到的命令，调试用</li>
</ul>
</li>
<li>ROLE <ul>
<li>回主从实例所属的角色</li>
</ul>
</li>
<li>SAVE <ul>
<li>步保存数据到硬盘</li>
</ul>
</li>
<li>SHUTDOWN [NOSAVE] [SAVE] <ul>
<li>步保存数据到硬盘，并关闭服务器</li>
</ul>
</li>
<li>SLAVEOF host port <ul>
<li>当前服务器转变为指定服务器的从属服务器(slave server)</li>
</ul>
</li>
<li>SLOWLOG subcommand [argument] <ul>
<li>理 redis 的慢日志</li>
</ul>
</li>
<li>SYNC <ul>
<li>于复制功能(replication)的内部命令</li>
</ul>
</li>
</ol>
<h3 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h3><p>在 redis 安装目录中创建dump.rdb文件:</p>
<pre><code>SAVE</code></pre><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令:</p>
<pre><code>CONFIG GET dir</code></pre><h3 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h3><p>查看是否设置了密码验证：</p>
<pre><code>CONFIG get requirepass</code></pre><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p>
<p>你可以通过以下命令来修改该参数：</p>
<pre><code>CONFIG set requirepass &quot;Tuesday2&quot;</code></pre><p>登录：</p>
<pre><code>AUTH &quot;runoob&quot;</code></pre><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>Redis可以达到100000+QPS(Query Per Second, 每秒查询次数)</p>
<p>原理：</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li>
<li>数据结构简单，对数据操作简单</li>
<li>采用单线程，单线程也能处理高并发请求，避免频繁创建与销毁线程占用资源，避免了频繁的上下文切换和锁竞争</li>
<li>使用多路I/O复用模型，非阻塞IO</li>
</ul>
<p>Redis采用的I/O多路复用函数：epol/kqueue/evport/select</p>
<p>优先选择时间复杂度O(1)的I/O多路复用函数作为底层实现，若当前编译环境无其它更优的函数则默认调用select</p>
<p>基于react设计模式监听I/O事件</p>
<h3 id="多路I-O复用模型"><a href="#多路I-O复用模型" class="headerlink" title="多路I/O复用模型"></a>多路I/O复用模型</h3><p>FD(File Descriptor): 文件描述符</p>
<p>一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射。</p>
<h4 id="传统I-O复用模型"><a href="#传统I-O复用模型" class="headerlink" title="传统I/O复用模型"></a>传统I/O复用模型</h4><p><img src="IO&#32;model.png"></img></p>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><ol>
<li>RDB(快照)持久化：保存某个时间点的全量数据快照</li>
<li>AOF(Append-Only-File)持久化：保存写状态</li>
</ol>
<h3 id="RDB-快照-持久化：保存某个时间点的全量数据快照"><a href="#RDB-快照-持久化：保存某个时间点的全量数据快照" class="headerlink" title="RDB(快照)持久化：保存某个时间点的全量数据快照"></a>RDB(快照)持久化：保存某个时间点的全量数据快照</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。RDB是Redis默认的持久化方式，会在对应的目录下生产一个dump.rdb文件，重启会通过加载dump.rdb文件恢复数据。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>只有一个文件dump.rdb，方便持久化；</li>
<li>容灾性好，一个文件可以保存到安全的磁盘；</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化（使用- 单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) ；</li>
<li>如果数据集偏大，RDB的启动效率会比AOF更高。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>数据安全性低。</li>
<li>如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ul>
<h4 id="RDB-快照-持久化策略通过redis-conf来配置"><a href="#RDB-快照-持久化策略通过redis-conf来配置" class="headerlink" title="RDB(快照)持久化策略通过redis.conf来配置"></a>RDB(快照)持久化策略通过redis.conf来配置</h4><pre><code>save 900 1 # 900秒内如果有1条写入指令就触发一次快照
save 300 10 # 300秒内如果有10条写入指令就触发一次快照，若10&gt;变动数&gt;0，则会等到900秒后才备份
save 60 10000

stop-writes-on-bgsave-error yes # 当备份进程出错则主进程停止写入
rdbcompression yes # 在备份时压缩rdb文件再保存</code></pre><h4 id="rdb文件操作"><a href="#rdb文件操作" class="headerlink" title="rdb文件操作"></a>rdb文件操作</h4><p>手动持久化：</p>
<ul>
<li>SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕</li>
<li>BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程<ul>
<li>使用到了系统调用fork()：创建进程，实现了Copy-on-Write</li>
<li>Copy-on-Write(写时复制)：如果有多个调用者同时要求相同资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍保持不变</li>
</ul>
</li>
</ul>
<pre><code>SAVE
LASTSAVE
BGSAVE
LASTSAVE</code></pre><p>自动持久化：</p>
<ul>
<li>根据redis.conf配置里的 <code>SAVE m n</code>定时触发(用的是BGSAVE)</li>
<li>主从复制时，主节点自动触发</li>
<li>执行Debug Reload</li>
<li>执行Shutdown且没有开启AOF持久化</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存数据全部同步，数据量大时会因为I/O影响性能</li>
<li>可能会因为Redis挂掉而丢失当前至最近一次快照期间的数据</li>
</ul>
<h3 id="AOF-Append-Only-File-持久化：保存写状态"><a href="#AOF-Append-Only-File-持久化：保存写状态" class="headerlink" title="AOF(Append-Only-File)持久化：保存写状态"></a>AOF(Append-Only-File)持久化：保存写状态</h3><p>AOF持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。 默认情况下 Redis 没有开启 AOF持久化</p>
<ul>
<li>记录下除了查询以外的所有变更数据库状态的指令</li>
<li>以append的形式追加保存到AOF文件中(增量)</li>
</ul>
<p>优点：</p>
<ul>
<li>数据安全性更高，AOF持久化可以配置appendfsync属性</li>
<li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</li>
<li>AOF机制的rewrite模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF文件不断增大<ul>
<li>日志重写：<ol>
<li>调用fork()创建子进程</li>
<li>子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件</li>
<li>主进程持续把新的变动同时写到内存和原来的AOF里</li>
<li>主进程获取子进程重写AOF完成的信号，往新的AOF同步增量变动</li>
<li>使用新的AOF文件替换老AOF文件</li>
</ol>
</li>
</ul>
</li>
<li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。</li>
</ul>
<h4 id="AOF持久化策略通过redis-conf来配置"><a href="#AOF持久化策略通过redis-conf来配置" class="headerlink" title="AOF持久化策略通过redis.conf来配置"></a>AOF持久化策略通过redis.conf来配置</h4><p>默认情况下 Redis 没有开启 AOF持久化，可以通过设置 appendonly 参数开启：</p>
<pre><code>appendonly yes</code></pre><ul>
<li>appendfsync always：每次有数据修改发生时都会写入AOF文件</li>
<li>appendfsync everysec：每秒钟同步一次，将多个写命令同步到硬盘</li>
<li>appendfsync no：让操作系统决定何时进行同步</li>
</ul>
<h3 id="AOF-vs-RDB"><a href="#AOF-vs-RDB" class="headerlink" title="AOF vs RDB"></a>AOF vs RDB</h3><p>RDB：</p>
<ul>
<li>优点：全量数据快照，文件小，恢复快</li>
<li>缺点：无法保存最近一次快照之后的数据</li>
</ul>
<p>AOF：</p>
<ul>
<li>优点：可读性高，适合保存增量数据，数据不易丢失</li>
<li>缺点：文件体积大，恢复时间长</li>
</ul>
<h3 id="RDB-AOF混合持久化方式-Redis默认"><a href="#RDB-AOF混合持久化方式-Redis默认" class="headerlink" title="RDB-AOF混合持久化方式(Redis默认)"></a>RDB-AOF混合持久化方式(Redis默认)</h3><p>使用BGSAVE做镜像全量持久化，AOF做增量持久化</p>
<h4 id="通过redis-conf来配置"><a href="#通过redis-conf来配置" class="headerlink" title="通过redis.conf来配置"></a>通过redis.conf来配置</h4><pre><code>appendonly yes
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec # 配置文件写入方式：always一旦缓存区发生变化就及时写入, everysec每隔一秒写入, no由操作系统来觉得写入时间，一般是缓存区满时写入</code></pre><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><ul>
<li>Pipeline和Linux的管道机制类似</li>
<li>基于请求/响应模型，单个请求处理需要一一应答</li>
<li>Pipeline批量执行指令，节省多次IO往返时间</li>
<li>有顺序依赖的指令需要分批发送</li>
</ul>
<h2 id="Redis同步机制"><a href="#Redis同步机制" class="headerlink" title="Redis同步机制"></a>Redis同步机制</h2><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p>全同步过程：</p>
<ol>
<li>Slave发送sync命令到Master</li>
<li>Master启动一个后台进程，将Redis中的数据快照保存到文件中</li>
<li>Master将保存数据快照期间接受到的写命令缓存起来</li>
<li>Master完成写文件操作后，将文件发送给Slave</li>
<li>使用新的RDB文件替换掉就的RDB文件</li>
<li>Master将这期间收集的增量写命令发送给Slave端</li>
</ol>
<p>增量同步过程：</p>
<ol>
<li>Master接收到用户的操作指令，判断是否需要传播到Slave</li>
<li>将操作记录追加到AOF文件</li>
<li>将操作传播到其它Slave：<ol>
<li>对齐主从库</li>
<li>往响应缓存写入指令</li>
</ol>
</li>
<li>将缓存中的数据发送给Slave</li>
</ol>
<p>主从模式缺点：当Master挂掉之后将无法写入数据</p>
<h3 id="Redis-Sentinel-哨兵模式"><a href="#Redis-Sentinel-哨兵模式" class="headerlink" title="Redis Sentinel 哨兵模式"></a>Redis Sentinel 哨兵模式</h3><p>用于解决主从同步Master宕机后的主从切换问题：</p>
<ul>
<li>监控：检查主从服务器是否运行正常</li>
<li>提醒：通过API向管理员或其它应用程序发送故障通知</li>
<li>自动故障迁移：主从切换，自动选举一个Slave为Master</li>
</ul>
<h3 id="流言协议Gossip"><a href="#流言协议Gossip" class="headerlink" title="流言协议Gossip"></a>流言协议Gossip</h3><ul>
<li>每个节点都随机地与对方通信，最终所有节点的状态达成一致</li>
<li>种子节点定期随机向其它节点发送节点列表以及需要传播的消息</li>
<li>不保证信息一定会传递给所有节点，但是最终会趋于一致</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>如何从海量数据里快速找到所需？</p>
<p>分片：按照某种规则去划分数据，分散存储在多个节点上</p>
<p>缺点：常规的按照哈希划分无法实现节点的动态增减</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="一致性哈希算法：对2-32取模，将哈希值空间组织成虚拟的圆环"><a href="#一致性哈希算法：对2-32取模，将哈希值空间组织成虚拟的圆环" class="headerlink" title="一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环"></a>一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环</h4><hr>
<h2 id="集成到系统"><a href="#集成到系统" class="headerlink" title="集成到系统"></a>集成到系统</h2><h3 id="集成到-Java"><a href="#集成到-Java" class="headerlink" title="集成到 Java"></a>集成到 Java</h3><p>可以使用 jedis包</p>
<h3 id="集成到数据库"><a href="#集成到数据库" class="headerlink" title="集成到数据库"></a>集成到数据库</h3><h4 id="Redis-设置过期时间"><a href="#Redis-设置过期时间" class="headerlink" title="Redis 设置过期时间"></a>Redis 设置过期时间</h4><p>Redis可以对存储在缓存中的数据设置过期时间。作为一个缓存数据库，这是非常实用的功能。之前写过一篇前后端交互的文章讲过，Token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。而有一个好的方案其实就是将这些验证信息存入Redis设置过期时间，如果设置了存活时间30分钟，那么半小时之后这些数据就会从Redis中进行删除。那说到删除，Redis是如果做到对这些数据进行删除的呢：</p>
<ul>
<li>定期删除：Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 Key，检查其是否过期，如果过期就删除。为什么是随机抽取而不是检查所有key？因为你如果设置的key成千上万，每100毫秒都将所有存在的key检查一遍，会给CPU带来比较大的压力。</li>
<li>惰性删除 ：定期删除可能会导致很多过期 Key 到了时间并没有被删除掉。用户在获取key的时候，redis会检查一下，这个key如果设置过期时间那么是否过期了，如果过期就删除这个key。</li>
</ul>
<p>但是只是使用定期删除 + 惰性删除的删除机制还是存在一个致命问题：如果定期删除漏掉了很多过期 Key，而且用户长时间也没有使用到这些过期key，就会导致这些过期key堆积在内存里，导致Redis内存块被消耗殆尽。所以有了Redis内存淘汰机制的诞生。</p>
<hr>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存处理过程：接收到请求请求，先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</p>
<p>缓存雪崩：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</p>
<p>解决办法：</p>
<ul>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>简介：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p>解决办法：</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置30秒</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>简介： 缓存击穿是指缓存中没有但数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大</p>
<p>解决方法：</p>
<ul>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java复习笔记：多线程与并发第一章"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/13/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/"
    >Java复习笔记：多线程与并发第一章</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/11/13/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="article-date">
  <time datetime="2019-11-13T09:07:53.000Z" itemprop="datePublished">2019-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="基本概念回顾"><a href="#基本概念回顾" class="headerlink" title="基本概念回顾"></a>基本概念回顾</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><h4 id="进程和线程的由来"><a href="#进程和线程的由来" class="headerlink" title="进程和线程的由来"></a>进程和线程的由来</h4><ol>
<li>串行：早起的计算机只能执行串行任务，并且遇到用户输入的操作时便会阻塞</li>
<li>批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍无法并发执行</li>
<li>进程：进程独占内存空间，保存各自运行状态，相互不干扰且可以互相切换，为并发处理任务提供了可能</li>
<li>线程：共享进程的内存资源，相互间切换更便捷，支持更细粒度的任务控制，让进程内的子任务得以并发执行</li>
</ol>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述。进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</strong></p>
<p>所有与进程相关的资源都被记录在<a href="https://baike.baidu.com/item/PCB/16067368?fr=aladdin" target="_blank" rel="noopener">PCB(PCB Process Control Block)</a>中。</p>
<p>PCB:</p>
<ul>
<li>描述信息</li>
<li>控制信息</li>
<li>资源信息<ul>
<li>程序段</li>
<li>数据段</li>
</ul>
</li>
<li>CPU现场</li>
</ul>
<blockquote>
<p>它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
</blockquote>
<p>进程拥有完整的<a href="https://blog.csdn.net/u014379540/article/details/52263114" target="_blank" rel="noopener">虚拟内存地址空间</a>，而同一进程下的线程则共享该进程拥有的内存空间。</p>
<p>线程的组成：</p>
<ul>
<li>堆栈寄存器</li>
<li>程序计数器</li>
<li>TCB</li>
</ul>
<p>进程就是包括上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文。</p>
<img src="进程与线程.png">

<p>进程的颗粒度太大，每次都要有上下的调入，保存，调出。</p>
<p>假设存在进程A，其实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p>
<p>进程A得到CPU-&gt;CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p>
<p>这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<h3 id="Linux用户态和内核态转换"><a href="#Linux用户态和内核态转换" class="headerlink" title="Linux用户态和内核态转换"></a>Linux用户态和内核态转换</h3><h4 id="为什么需要转换"><a href="#为什么需要转换" class="headerlink" title="为什么需要转换"></a>为什么需要转换</h4><h4 id="内核态的多线程是如何通过轻量级线程来实现的"><a href="#内核态的多线程是如何通过轻量级线程来实现的" class="headerlink" title="内核态的多线程是如何通过轻量级线程来实现的"></a>内核态的多线程是如何通过轻量级线程来实现的</h4><h3 id="什么是系统中断"><a href="#什么是系统中断" class="headerlink" title="什么是系统中断"></a>什么是系统中断</h3><h2 id="Java中的进程和线程"><a href="#Java中的进程和线程" class="headerlink" title="Java中的进程和线程"></a>Java中的进程和线程</h2><h3 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h3><ul>
<li>运行一个程序会产生一个进程，进程包含至少一个线程</li>
<li>每个进程对应一个JVM实例，多个线程共享JVM里的堆</li>
<li>Java采用单线程编程模型，程序会自动创建主线程</li>
</ul>
<h3 id="Thread中的start和run方法的区别"><a href="#Thread中的start和run方法的区别" class="headerlink" title="Thread中的start和run方法的区别"></a>Thread中的<code>start</code>和<code>run</code>方法的区别</h3><p>使用<code>run</code>方法会继续使用主线程来执行重写的<code>run</code>方法里面的内容，而使用<code>start</code>方法则会开一个新线程来执行。</p>
<p>我们看一下start方法源码</p>
<blockquote>
<p>Thread.java</p>
</blockquote>
<pre><code class="java">/**
     * Causes this thread to begin execution; the Java Virtual Machine
     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
     * &lt;p&gt;
     * The result is that two threads are running concurrently: the
     * current thread (which returns from the call to the
     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
     * &lt;code&gt;run&lt;/code&gt; method).
     * &lt;p&gt;
     * It is never legal to start a thread more than once.
     * In particular, a thread may not be restarted once it has completed
     * execution.
     *
     * @exception  IllegalThreadStateException  if the thread was already
     *               started.
     * @see        #run()
     * @see        #stop()
     */
    public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group&#39;s list of threads
         * and the group&#39;s unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }

    private native void start0();</code></pre>
<p>可以看到在<code>start</code>方法里面主要是使用到了一个native的方法<code>start0()</code>，该方法调用到了外部的非Java的源码。</p>
<p>可以访问<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">OpenJKD</a>来查询</p>
<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/dd10fb830ea9/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">JKD8 Thread.c源码</a></p>
<blockquote>
<p>Thread.c</p>
</blockquote>
<pre><code class="c">#include &quot;jni.h&quot;
#include &quot;jvm.h&quot;

#include &quot;java_lang_Thread.h&quot;

#define THD &quot;Ljava/lang/Thread;&quot;
#define OBJ &quot;Ljava/lang/Object;&quot;
#define STE &quot;Ljava/lang/StackTraceElement;&quot;
#define STR &quot;Ljava/lang/String;&quot;

#define ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))

static JNINativeMethod methods[] = {
    {&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread},
    {&quot;stop0&quot;,            &quot;(&quot; OBJ &quot;)V&quot;, (void *)&amp;JVM_StopThread},
    {&quot;isAlive&quot;,          &quot;()Z&quot;,        (void *)&amp;JVM_IsThreadAlive},
    {&quot;suspend0&quot;,         &quot;()V&quot;,        (void *)&amp;JVM_SuspendThread},
    {&quot;resume0&quot;,          &quot;()V&quot;,        (void *)&amp;JVM_ResumeThread},
    {&quot;setPriority0&quot;,     &quot;(I)V&quot;,       (void *)&amp;JVM_SetThreadPriority},
    {&quot;yield&quot;,            &quot;()V&quot;,        (void *)&amp;JVM_Yield},
    {&quot;sleep&quot;,            &quot;(J)V&quot;,       (void *)&amp;JVM_Sleep},
    {&quot;currentThread&quot;,    &quot;()&quot; THD,     (void *)&amp;JVM_CurrentThread},
    {&quot;countStackFrames&quot;, &quot;()I&quot;,        (void *)&amp;JVM_CountStackFrames},
    {&quot;interrupt0&quot;,       &quot;()V&quot;,        (void *)&amp;JVM_Interrupt},
    {&quot;isInterrupted&quot;,    &quot;(Z)Z&quot;,       (void *)&amp;JVM_IsInterrupted},
    {&quot;holdsLock&quot;,        &quot;(&quot; OBJ &quot;)Z&quot;, (void *)&amp;JVM_HoldsLock},
    {&quot;getThreads&quot;,        &quot;()[&quot; THD,   (void *)&amp;JVM_GetAllThreads},
    {&quot;dumpThreads&quot;,      &quot;([&quot; THD &quot;)[[&quot; STE, (void *)&amp;JVM_DumpThreads},
    {&quot;setNativeName&quot;,    &quot;(&quot; STR &quot;)V&quot;, (void *)&amp;JVM_SetNativeThreadName},
};

#undef THD
#undef OBJ
#undef STE
#undef STR

JNIEXPORT void JNICALL
Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)
{
    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));
}</code></pre>
<p>可以看到<code>start0</code>方法调用到了<code>JVM_StartThread</code>方法，而该方法引自<code>jvm.h</code></p>
<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/b44df6c5942c/src/share/vm/prims/jvm.cpp" target="_blank" rel="noopener">JDK8 jvm.cpp源码</a></p>
<p>在jvm.cpp下的<code>JVM_StartThread</code>方法里有下面这句话用于创建一个线程</p>
<blockquote>
<p>jvm.cpp</p>
</blockquote>
<pre><code class="c">native_thread = new JavaThread(&amp;thread_entry, sz);</code></pre>
<p>搜索上面用于创建线程的方法传入的参数<code>thread_entry</code></p>
<pre><code class="c">static void thread_entry(JavaThread* thread, TRAPS) {
  HandleMark hm(THREAD);
  Handle obj(THREAD, thread-&gt;threadObj());
  JavaValue result(T_VOID);
  JavaCalls::call_virtual(&amp;result,
                          obj,
                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),
                          vmSymbols::run_method_name(),
                          vmSymbols::void_method_signature(),
                          THREAD);
}</code></pre>
<p>可以看到该方法最后会调用JVM虚拟机<code>JavaCalls::call_virtual</code>，并传入<code>run_method_name</code></p>
<p>综上所述：</p>
<ul>
<li>调用<code>start</code>方法会：Thread#start()-&gt;JVM_StartThread-&gt;thread_entry-&gt;Thread#run()<ul>
<li>在<code>thread_entry</code>时创建一个新的子线程并启动去运行Thread#run()里的方法体</li>
</ul>
</li>
<li>调用<code>run</code>方法会：Thread#run()<ul>
<li>当做一个普通的方法调用去调用Thread#run()里的方法体</li>
</ul>
</li>
</ul>
<h3 id="Thread和-Runnable是什么关系"><a href="#Thread和-Runnable是什么关系" class="headerlink" title="Thread和 Runnable是什么关系"></a>Thread和 Runnable是什么关系</h3><ul>
<li>Thread类实现了Runnable接口，使得run支持多线程</li>
<li>因为类的单一继承原则，推荐使用Runnable接口</li>
</ul>
<p>实现了Runnable接口是没有start方法的，需要把其对象作为参数去创建一个Thread对象再调用start方法启动</p>
<h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给<code>run()</code>方法传参</h3><ol>
<li>构造函数传参</li>
<li>成员变量传参</li>
<li>回调函数传参</li>
</ol>
<h3 id="处理线程的返回值"><a href="#处理线程的返回值" class="headerlink" title="处理线程的返回值"></a>处理线程的返回值</h3><ol>
<li>主线程等待法：让主线程循环等待直到子线程返回</li>
<li>使用Thread类的<code>join()</code>阻塞当前主线程以等待子线程处理完毕<pre><code class="java">public class Test implements Runnable {
 @Override
 void run() {
     try {
         Thread.currentThread.sleep(5000);
     } catch (InterruptedException e) {
         e.printStackTrace();
     }
     value = &quot;data&quot;;
 }
 public static void main(String[] args) throws InterruptedException {
     Test test = new Test();
     Thread t = new Thread(test);
     t.start();
     t.join();
     System.out.println(&quot;value:&quot; + cw.value);
 }
}</code></pre>
</li>
<li>通过Callable接口实现：通过FutureTask or 线程池获取</li>
</ol>
<pre><code class="java">// 通过FutureTask
public class MyCallable implements Callable&lt;String&gt; {
    @Override
    public String call() throws Exception{
        String value=&quot;test&quot;;
        System.out.println(&quot;ready to work&quot;);
        Thread.currentThread().sleep(5000);
        System.out.println(&quot;Task down&quot;);
        return value;
    }
}

public class FutureTaskDemo {
    public static void main(String[] args) throws InterruptedException {
        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyCallable());
        new Thread(task);
        if(!task.isDone()){
            System.out.println(&quot;task has not finished, please wait&quot;);
        }
        // 显示MyCallable里面的返回值
        System.out.println(&quot;task return:&quot; + task.get());
    }
}</code></pre>
<pre><code class="java">// 通过线程池
public class ThreadPoolDemo {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService newPool = Executors.newCachedThreadPool();
        Future&lt;String&gt; future = newPool.submit(new MyCallable());
        if (!task.isDone()) {
            System.out.println(&quot;task has not finished, please wait&quot;);
        }
        // 显示MyCallable里面的返回值
        try {
            System.out.println(&quot;task return:&quot; + task.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } finally {
            newPool.shutdown();
        }
    }
}</code></pre>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a><code>sleep</code>和<code>wait</code>的区别</h3><ul>
<li><code>sleep</code>是Thread类的方法，<code>wait</code>是Object类中定义的方法</li>
<li><code>sleep</code>方法可以在任何地方使用</li>
<li><code>wait</code>方法只能在<code>synchronized</code>方法或<code>synchronized</code>快中使用</li>
<li><code>Thread.sleep</code>只会让出CPU，不会导致锁行为的改变</li>
<li><code>Object.wait</code>不仅会让出CPU，还会释放已经占有的同步资源</li>
</ul>
<pre><code class="java">public class WaitSleepDemo {

  public static void main(String[] args) {
    final Object lock = new Object();
    new Thread(new Runnable() {
      @Override
      public void run() {
        System.out.println(&quot;thread A is waiting to get lock&quot;);
        synchronized (lock) {
          try {
            System.out.println(&quot;thread A get lock&quot;);
            Thread.sleep(20);
            System.out.println(&quot;thread A do wait lock&quot;);
            lock.wait(1000);
            System.out.println(&quot;thread A is done&quot;);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }).start();
    try {
      Thread.sleep(10);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    new Thread(new Runnable() {
      @Override
      public void run() {
        System.out.println(&quot;thread B is waiting to get lock&quot;);
        synchronized (lock) {
          try {
            System.out.println(&quot;thread B get lock&quot;);
            System.out.println(&quot;thread B sleeping 10 ms&quot;);
            Thread.sleep(10);
            System.out.println(&quot;thread B is done&quot;);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }).start();
  }
}</code></pre>
<pre><code>thread A is waiting to get lock
thread A get lock
thread B is waiting to get lock
thread A do wait lock
thread B get lock
thread B sleeping 10 ms
thread B is done
thread A is done</code></pre><p>观察输出可发现，在A获得锁之后B开始等待锁，而A开始wait之后B就获得了锁</p>
<h3 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a><code>notify</code>和<code>notifyAll</code>的区别</h3><p>锁池 EntryList：假设线程A已经拥有了某对象的锁，而其它线程B、C想要调用这个对象的某个<code>synchronized</code>方法(或块)之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。</p>
<p>等待池 WaitSet：假设线程A调用了某个对象的<code>wait()</code>方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。</p>
<ul>
<li><code>notifyAll</code>会让所有处于等待池中的线程全部进入锁池去竞争获取锁的机会</li>
<li><code>notify</code>会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li>
</ul>
<pre><code class="java">public class WaitSleepDemo {

  public static void main(String[] args) {
    final Object lock = new Object();
    new Thread(new Runnable() {
      @Override
      public void run() {
        System.out.println(&quot;thread A is waiting to get lock&quot;);
        synchronized (lock) {
          try {
            System.out.println(&quot;thread A get lock&quot;);
            Thread.sleep(20);
            System.out.println(&quot;thread A do wait lock&quot;);
            lock.wait();
            System.out.println(&quot;thread A is done&quot;);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }).start();
    try {
      Thread.sleep(10);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    new Thread(new Runnable() {
      @Override
      public void run() {
        System.out.println(&quot;thread B is waiting to get lock&quot;);
        synchronized (lock) {
          try {
            System.out.println(&quot;thread B get lock&quot;);
            System.out.println(&quot;thread B sleeping 10 ms&quot;);
            Thread.sleep(10);
            System.out.println(&quot;thread B is done&quot;);
            lock.notify(); // or lock.notifyAll();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }).start();
  }
}</code></pre>
<pre><code class="java">public class NotificationDemo {
  private volatile boolean go = false;
  private synchronized void go() {
    while (go == false) {
      System.out.println(Thread.currentThread() + &quot; is going to notify all or one thread waiting on&quot;);
      go = true;
      notify();
    }
  }
  private synchronized void shouldGo() throws InterruptedException {
    while (go != true) {
      System.out.println(Thread.currentThread() + &quot; is going to wait on this object&quot;);
      wait();
      System.out.println(Thread.currentThread() + &quot; is woken up&quot;);
    }
    go = false;
  }
  public static void main(String[] args) throws InterruptedException {
    final NotificationDemo test = new NotificationDemo();
    Runnable waitTask = new Runnable() {
      @Override
      public void run() {
        try {
          test.shouldGo();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; finished Execution&quot;);
      }
    };

    Runnable notifyTask = new Runnable() {
      @Override
      public void run() {
        test.go();
        System.out.println(Thread.currentThread().getName() + &quot; finished Execution&quot;);
      }
    };

    Thread t1 = new Thread(waitTask, &quot;WT1&quot;);
    Thread t2 = new Thread(waitTask, &quot;WT2&quot;);
    Thread t3 = new Thread(waitTask, &quot;WT3&quot;);
    Thread t4 = new Thread(notifyTask, &quot;NT1&quot;);

    t1.start();
    t2.start();
    t3.start();

    Thread.sleep(200);

    t4.start();
  }
}</code></pre>
<pre><code>Thread[WT1,5,main] is going to wait on this object
Thread[WT2,5,main] is going to wait on this object
Thread[WT3,5,main] is going to wait on this object
Thread[NT1,5,main] is going to notify all or one thread waiting on
Thread[WT1,5,main] is woken up
NT1 finished Execution
WT1 finished Execution</code></pre><ol>
<li>从输出来看前3行是WT1、WT2、WT3依次进入等待池，</li>
<li>之后NT1调用<code>notify</code>方法随机唤醒一个线程将其置入锁池，并修改<code>go = true;</code>跳出循环</li>
<li>这里是WT1被置入锁池，因为上一步中<code>go</code>的值被修改所以跳出循环，WT1获得锁并且修改了变量<code>go = false;</code>，然后因为NT1线程已经结束所以剩下两个线程WT2、WT3依然处于等待池。</li>
</ol>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><code>yield</code></h3><p>当调用<code>Thread.yield()</code>时会给线程调度器<code>scheduler</code>一个当前线程愿意让出CPU的使用的信号，但是调度去可能会无视该暗示。</p>
<blockquote>
<p>Thread.java</p>
</blockquote>
<pre><code class="java">    /**
     * A hint to the scheduler that the current thread is willing to yield
     * its current use of a processor. The scheduler is free to ignore this
     * hint.
     *
     * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
     * between threads that would otherwise over-utilise a CPU. Its use
     * should be combined with detailed profiling and benchmarking to
     * ensure that it actually has the desired effect.
     *
     * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
     * for debugging or testing purposes, where it may help to reproduce
     * bugs due to race conditions. It may also be useful when designing
     * concurrency control constructs such as the ones in the
     * {@link java.util.concurrent.locks} package.
     */
    public static native void yield();</code></pre>
<pre><code class="java">public class YieldDemo {
  public static void main(String[] args) {
    Runnable yieldTask = new Runnable() {
      @Override
      public void run() {
        for (int i = 0; i &lt;= 10; i++) {
          System.out.println(Thread.currentThread().getName() + i);
          if (i == 5) {
            Thread.yield();
          }
        }
      }
    };
    Thread t1 = new Thread(yieldTask, &quot;A&quot;);
    Thread t2 = new Thread(yieldTask, &quot;B&quot;);
    t1.start();
    t2.start();
  }
}</code></pre>
<p>输出：</p>
<pre><code>A0
B0
A1
B1
A2
B2
A3
B3
A4
B4
B5
A5
B6
B7
B8
B9
B10
A6
A7
A8
A9
A10</code></pre><p>可以看出当A线程执行到5时把CPU让给了B来执行，直到B执行到10把B让给A</p>
<h3 id="使用interrupt来中断线程"><a href="#使用interrupt来中断线程" class="headerlink" title="使用interrupt来中断线程"></a>使用<code>interrupt</code>来中断线程</h3><p>已被抛弃的方法：</p>
<ul>
<li><del><code>stop()</code></del>：过于暴力，被中断线程可能没有释放锁</li>
<li><del><code>suspend()</code></del>, <del><code>resume()</code></del></li>
</ul>
<p><code>interrupt()</code></p>
<ul>
<li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常</li>
<li>如果线程处于正常状态，那么线程会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li>
</ul>
<pre><code class="java">public class InterruptDemo {

  public static void main(String[] args) throws InterruptedException {
    Runnable interruptTask = new Runnable() {
      @Override
      public void run() {
        int i = 0;
        try {
          // 在正常运行任务时，经常检查本线程的中断标志位，如果设置了中断标志就自行停止线程
          while (!Thread.currentThread().isInterrupted()) {
            Thread.sleep(100);
            i++;
            System.out.println(Thread.currentThread().getName() + &quot; (&quot; + Thread.currentThread().getState()+ &quot;) loop:i=&quot; + i);
          }
        } catch (InterruptedException e) {
          // 在调用阻塞方法时正确处理InterruptedException异常
          System.out.println(Thread.currentThread().getName()+ &quot; (&quot; + Thread.currentThread().getState() + &quot;) catch InterruptedException&quot;);
        }
      }
    };
    Thread t1 = new Thread(interruptTask, &quot;t1&quot;);
    System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is new.&quot;);

    t1.start();
    System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is started.&quot;);

    Thread.sleep(300);
    t1.interrupt();
    System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is interrupted.&quot;);

    Thread.sleep(300);
    System.out.println(t1.getName() + &quot; (&quot; + t1.getState() + &quot;) is interrupted now.&quot;);
  }
}</code></pre>
<p>输出：</p>
<pre><code>t1 (NEW) is new.
t1 (RUNNABLE) is started.
t1 (RUNNABLE) loop:i=1
t1 (RUNNABLE) loop:i=2
t1 (RUNNABLE) catch InterruptedException
t1 (RUNNABLE) is interrupted.
t1 (TERMINATED) is interrupted now.</code></pre><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><blockquote>
<p>Thread.java</p>
</blockquote>
<pre><code class="java">    /**
     * A thread state.  A thread can be in one of the following states:
     * &lt;ul&gt;
     * &lt;li&gt;{@link #NEW}&lt;br&gt;
     *     A thread that has not yet started is in this state.
     *     &lt;/li&gt;
     * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
     *     A thread executing in the Java virtual machine is in this state.
     *     &lt;/li&gt;
     * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
     *     A thread that is blocked waiting for a monitor lock
     *     is in this state.
     *     &lt;/li&gt;
     * &lt;li&gt;{@link #WAITING}&lt;br&gt;
     *     A thread that is waiting indefinitely for another thread to
     *     perform a particular action is in this state.
     *     &lt;/li&gt;
     * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
     *     A thread that is waiting for another thread to perform an action
     *     for up to a specified waiting time is in this state.
     *     &lt;/li&gt;
     * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
     *     A thread that has exited is in this state.
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * A thread can be in only one state at a given point in time.
     * These states are virtual machine states which do not reflect
     * any operating system thread states.
     *
     * @since   1.5
     * @see #getState
     */
    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * &lt;p&gt;A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
         * on an object is waiting for another thread to call
         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
         *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
         * &lt;/ul&gt;
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }</code></pre>
<p>Java线程状态：</p>
<ol>
<li>新建(NEW)：创建后尚未启动的线程状态</li>
<li>运行(RUNNABLE)：包含Running(正在执行)和Ready(正在等待CPU分配时间片)<ul>
<li>Ready(正在等待CPU分配时间片)：其它线程调用了该对象的<code>start()</code>方法，该线程位于可运行线程池中，等待被线程调度选中，获取CPU使用权。</li>
<li>Running(正在执行)：就绪状态的线程在获得CPU时间片后变为运行中状态(running)</li>
</ul>
</li>
<li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片(timeslice)，执行程序代码</li>
<li>无限期等待(WAITING)：不会被分配CPU执行时间，需要被显示唤醒，进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)<ul>
<li>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</li>
<li>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</li>
<li><code>LockSupport.park()</code>方法</li>
</ul>
</li>
<li>限期等待(TIMED_WAITING)：在一定时间后会由系统自动唤醒<ul>
<li><code>Thread.sleep()</code>方法</li>
<li>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</li>
<li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li>
<li><code>LockSupport.parkNanos()</code>方法</li>
<li><code>LockSupport.parkUntil()</code>方法</li>
</ul>
</li>
<li>阻塞(BLOCKED)：等待获取排它锁，线程试图获取一个内部对象的<code>Monitor</code>（进入<code>synchronized</code>方法或<code>synchronized</code>块）但是其他线程已经抢先获取，那此线程被阻塞，知道其他线程释放<code>Monitor</code>并且线程调度器允许当前线程获取到<code>Monitor</code>，此线程就恢复到可运行状态。</li>
<li>结束(TERMINATED)：已终止线程的状态，线程已经结束执行</li>
</ol>
<img src="./线程的状态.png">

<img src="./等待队列.png">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000016197831?utm_source=tag-newest" target="_blank" rel="noopener">一文读懂Java线程状态转换</a></li>
</ul>
<p>下图为Oracle支持各个JDK版本所到的年限</p>
<img src="oracleJDK vs OpenJDK.png">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-比特币是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/30/%E6%AF%94%E7%89%B9%E5%B8%81%E6%98%AF%E4%BB%80%E4%B9%88/"
    >比特币是什么</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/10/30/%E6%AF%94%E7%89%B9%E5%B8%81%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2019-10-30T11:42:53.000Z" itemprop="datePublished">2019-10-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="使用简单的js代码来讲述比特币的工作原理"><a href="#使用简单的js代码来讲述比特币的工作原理" class="headerlink" title="使用简单的js代码来讲述比特币的工作原理"></a>使用简单的js代码来讲述比特币的工作原理</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>在一个含有N(N&gt;2)个人的小团体里建立一个通用的系统</li>
<li>该货币系统使用的货币没有实体媒介，即为数据形式存在</li>
<li>该转账操作需要通过互联网(或是团体里的局域网)来进行</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>假设存在一个有10个人的小团体，每个人都有自己的私有存储空间</p>
<pre><code class="js">const peopleList = []
for (let i = 0; i &lt; 10; i++) {
    peopleList.push({
        name: i,
        note: [],
        historyList: []
    })
}</code></pre>
<p>首先要假设每个人账户里面都有至少1000块来自系统(<code>-1</code>)，否则无法进行转账</p>
<pre><code class="js">for (let i = 0; i &lt; 10; i++) {
    for (let j = 0; j &lt; 10; j++) {
        peopleList[i].note.push({
            from: -1,
            to: j,
            money: 1000
        })
    }
}</code></pre>
<p>第3个人转100给第9个人：记做 3-&gt;9: 100，全部人记录下来这个事件</p>
<pre><code class="js">for (let i = 0; i &lt; 10; i++) {
    peopleList[i].note.push({
        from: 3,
        to: 9,
        money: 100
    })
}</code></pre>
<p>这样，一笔转账就被认为是完成了。</p>
<p>但是当转账的记录太多的时候每个人的存储空间就会出现不够用的情况，这个时候就要进行压缩操作。那么问题来了，压缩密钥怎么办，若是保存在一个人的手上肯定不行，所以就需要使用该网络中每个人都同意的唯一一把钥匙来密封它。通过密封，我们可以保证，一旦历史记录的备份已经被存入每一个人的文件夹，没有人能够对它作出任何更改。因此一旦压缩完成，那么这个压缩包就是绝对可信的。</p>
<p>这个压缩包的hash值被人们称为“矿”，同时也是工作证明。</p>
<p>一旦每个人都用尽自己的空间、无法记录进一步的交易，他们就开始卖力地计算历史交易记录的hash，使得它可以被藏入历史hash值列表<code>historyList</code>中。在网络中，每个人都进行这个计算，而最早算出hash值的那个人会向其他所有人宣布这个值。</p>
<pre><code class="js">const maxHistory = 10
let sealingNumber
if (peopleList[7].note.length &gt;= maxHistory) {
    sealingNumber = hash(JSON.stringify(peopleList[7].note))
    peopleList[7].note = []
}</code></pre>
<p>听到hash值之后，每个人都立即验证<code>check()</code>它是否能产生要求的输出值。如果是的，每个人都为他们的历史hash值列表<code>historyList</code>存入该值。</p>
<pre><code class="js">for (let i = 0; i &lt; 10; i++) {
    if (check(sealingNumber) === JSON.stringify(peopleList[i].note)) {
        peopleList[i].historyList.push(sealingNumber)
        peopleList[i].note = []
    }
}</code></pre>
<p>如果对某人，比如7来说，那个<code>sealingNumber</code>无法产生要求的输出值，怎么办？</p>
<p>可能的原因有：</p>
<ul>
<li>他获取到的<code>sealingNumber</code>与之前在网络中宣布的不同</li>
<li>他可能记录错了<code>note</code>数组</li>
</ul>
<p>他只能放弃自己错误的<code>sealingNumber</code>然后从网络里获取别人的<code>note</code>数组和<code>historyList</code>数组，否则他将被禁止进入网络</p>
<p>前面提到了hash值即<code>sealingNumber</code>也可以被称作矿，这是因为第一个计算出hash值的人将得到免费的金钱作为对他的努力（比如：付出的CPU算力和电力）的奖励。</p>
<p>下面假设奖励为1</p>
<pre><code class="js">const maxHistory = 10
let sealingNumber
if (peopleList[7].note.length &gt;= maxHistory) {
    sealingNumber = hash(JSON.stringify(peopleList[7].note))
    peopleList[7].note = []
    if (isFirst(sealingNumber)) {
        peopleList[7].note.push({
            from: -1,
            to: 7,
            money: 1
        })
    }
}

for (let i = 0; i &lt; 10; i++) {
    peopleList[i].note = []
    peopleList[i].historyList.push(sealingNumber)
    peopleList[i].note.push({
        from: -1,
        to: 7,
        money: 1
    })
}</code></pre>
<p>这就是比特币变为现实的方式。它是在区块链上被用来交易的第一种货币。同时，人们被奖励以比特币作为回报，以使在网络上，计算hash值努力会继续进行。</p>
<p>但是这里有个问题如果有人将很久之前的<code>note</code>数组和<code>historyList</code>数组中对应的一项同时进行修改在检查上面将会成本较高，但是我们可以将每一个<code>note</code>数组的最后一项改为上一个<code>historyList</code>数组的值也就是上一个<code>note</code>数组的hash值。这样，每一个hash值都依赖于它之前的<code>note</code>数组。因此，如果有人要修改一个<code>note</code>数组的历史记录，他将同样必须改变该页以后所有<code>note</code>数组的内容和hash值，以使这条链保持一致。</p>
<p>如果有人想要这么做的话那么他将会从改变的那个<code>note</code>数组开始计算hash值，但是计算也是需要消耗算力的，他的链增长速度肯定赶不上整个社区的链的增长速度，除非他拥有超越整个社区的算力，当然这都是后话了。有句话叫：在绝对的力量面前任何技巧都是花拳绣腿。</p>
<p>所以这保证了在一个网络中，最长的链就是可信的链。</p>
<pre><code class="js">const maxHistory = 10
let sealingNumber
if (peopleList[7].note.length &gt; maxHistory) {
    peopleList[7].note.push({
        from: null,
        to: null,
        money: peopleList[7].historyList[historyList.length - 1]
    })
    sealingNumber = hash(JSON.stringify(peopleList[7].note))
    peopleList[7].note = []
    if (isFirst(sealingNumber)) {
        peopleList[7].note.push({
            from: -1,
            to: 7,
            money: 1
        })
    }
}

for (let i = 0; i &lt; 10; i++) {
    peopleList[i].note = []
    peopleList[i].historyList.push(sealingNumber)
    peopleList[i].note.push({
        from: -1,
        to: 7,
        money: 1
    })
}</code></pre>
<p>万一，是6个人呢？</p>
<p>在这种情况下，这个协议将会变成一纸空文。使得整个社区变成这6个人的后花园。它就是人们所知的“51%攻击”。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitcoin/" rel="tag">Bitcoin</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Node.js Unit Test Framework"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/28/Node.js%20Unit%20Test%20Framework/"
    >Node.js Unit Test Framework</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/10/28/Node.js%20Unit%20Test%20Framework/" class="article-date">
  <time datetime="2019-10-28T09:13:04.000Z" itemprop="datePublished">2019-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>基于Node.js的 Unit Test Framework，用到了如下几个工具：</p>
<ul>
<li><a href="https://mochajs.org" target="_blank" rel="noopener">mocha</a>: Mocha is a feature-rich JavaScript test framework.</li>
<li><a href="https://sinonjs.org/" target="_blank" rel="noopener">sinon.js</a>: Standalone test spies, stubs and mocks for JavaScript.</li>
<li><a href="https://www.chaijs.com/" target="_blank" rel="noopener">chai.js</a>: Chai is a BDD / TDD assertion library.</li>
<li><a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">supertest</a>: Super-agent driven library for testing node.js HTTP servers using a fluent API.</li>
<li><a href="https://istanbul.js.org" target="_blank" rel="noopener">istanbul.js</a>: JavaScript test coverage made simple.</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="bash">npm install mocha -S
npm install sinon -S
npm install chai -S
npm install supertest -S
npm install istanbul -S</code></pre>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>在项目的根目录下创建test文件夹，如果项目是分层结构的话可以在test下创建子目录</li>
<li>添加mocha启动命令，参数为需要扫描的含有unit test文件的文件夹</li>
</ol>
<pre><code class="bash">mocha test/controller test/routes test/common test/service</code></pre>
<p>为方便起见可以将命令添加到package.json</p>
<pre><code class="json">  &quot;scripts&quot;: {
    &quot;unit-test&quot;: &quot;mocha test/controller test/routes test/common test/service&quot;
  }</code></pre>
<h2 id="编写-Unit-Test"><a href="#编写-Unit-Test" class="headerlink" title="编写 Unit Test"></a>编写 Unit Test</h2><p>为方便查看unit test运行结果，可以采用每一个js文件对应一个Unit Test文件，每一个function对应一个组的结构来编写</p>
<h3 id="Given-When-Then的case命名法"><a href="#Given-When-Then的case命名法" class="headerlink" title="Given-When-Then的case命名法"></a>Given-When-Then的case命名法</h3><p>Definition</p>
<p>The Given-When-Then formula is a template intended to guide the writing of acceptance tests for a User Story:</p>
<ul>
<li>Given: Set of preconditions</li>
<li>When: When an event occurs, or some action is carried out</li>
<li>Then: What outcome is achieved, or a particular set of observable consequences should obtain</li>
</ul>
<p>Example：测试对象是人</p>
<ul>
<li>Given：人的上下文预设：这是一个诗人</li>
<li>When：对人的操作：把这个人放在太平盛世中</li>
<li>Then：对人产生的结果：这个人将获得富足的生活</li>
<li>则test case命名为：Given_一个人职业是诗人_When_活在太平盛世_Then_这个人生活富足</li>
</ul>
<h3 id="一个-test-case的结构"><a href="#一个-test-case的结构" class="headerlink" title="一个 test case的结构"></a>一个 test case的结构</h3><p>一个test case分为3部分：</p>
<ol>
<li>mock函数部分</li>
<li>Given步骤: 准备测试数据部分</li>
<li>When步骤：调用测试函数</li>
<li>Then步骤：断言返回结果</li>
</ol>
<h3 id="mocha中Unit-Test的结构"><a href="#mocha中Unit-Test的结构" class="headerlink" title="mocha中Unit Test的结构"></a>mocha中Unit Test的结构</h3><pre><code class="js">describe(&#39;userController&#39;, function() {
  describe(&#39;#findUserByPaging()&#39;, function() {
    // 准备测试数据
    ...
    // mock or stub function if need
    let sandbox;
    beforeEach(function() {
      sandbox = sinon.createSandbox();
    });
    afterEach(function() {
      sandbox.restore()
    });
    // test case
    it(&#39;should return limit user list when given offset limit&#39;, (done) =&gt; {
      userController.findUserByPaging(searchCriteria).then((result) =&gt; {
        // Then
        assert.equal(result.success, true) // assert断言
        done() // 表示一个Test Case结束
      }).catch((err) =&gt; {
        done(err) // 表示一个Test Case结束
      })
    })
  })
})</code></pre>
<p>若断言不通过或者运行中抛出一个异常则会显示测试失败</p>
<h3 id="Test-Case-Example"><a href="#Test-Case-Example" class="headerlink" title="Test Case Example"></a>Test Case Example</h3><p>本例中用到的方法：</p>
<ul>
<li>mocha:<ul>
<li><code>describe()</code></li>
<li><code>done()</code></li>
</ul>
</li>
<li>sinon.js<ul>
<li><code>createSandbox()</code></li>
<li><code>stub</code></li>
</ul>
</li>
<li>chai.js<ul>
<li><code>assert.equal()</code></li>
<li><code>assert.deepEqual()</code></li>
</ul>
</li>
</ul>
<pre><code class="js">  describe(&#39;#findUserByPaging()&#39;, function() {
    let sandbox;
    // Given
    const searchResult = {
      &quot;totalCount&quot;: 1,
      &quot;data&quot;: [
        {
          &quot;userId&quot;: 1,
          &quot;userDomain&quot;: &quot;TESTUSER&quot;,
          &quot;userEmail&quot;: &quot;test.user@outlook.com&quot;,
          &quot;userTel&quot;: &quot;1234567890&quot;,
          &quot;userTeam&quot;: &quot;MBC&quot;,
          &quot;roleId&quot;: 1,
          &quot;roleName&quot;: &quot;Super Admin&quot;
        }
      ]
    }
    const searchCriteria = {
      userDomain: &#39;TESTUSER&#39;,
      offset: 0,
      limit: 10
    }
    const expectData = {
      &quot;data&quot;: [
        {
          &quot;role&quot;: [
            {
              &quot;roleId&quot;: 1,
              &quot;roleName&quot;: &quot;Super Admin&quot;
            }
          ],
          &quot;userDomain&quot;: &quot;TESTUSER&quot;,
          &quot;userEmail&quot;: &quot;test.user@outlook.com&quot;,
          &quot;userId&quot;: 1,
          &quot;userTeam&quot;: &quot;MBC&quot;,
          &quot;userTel&quot;: &quot;1234567890&quot;
        }
      ],
      &quot;limit&quot;: 10,
      &quot;offset&quot;: 0,
      &quot;totalCount&quot;: 1
    }
    // mock function
    beforeEach(function() {
      sandbox = sinon.createSandbox();
      sandbox.stub(UserRepo, &quot;findUserByPaging&quot;).withArgs(sinon.match.any).returns(searchResult)
    });
    afterEach(function() {
      sandbox.restore()
    });
    it(&#39;should return limit user list when given offset limit&#39;, (done) =&gt; {
      // When
      userController.findUserByPaging(searchCriteria).then((result) =&gt; {
        // Then
        assert.equal(result.success, true)
        assert.deepEqual(result.data, expectData)
        done()
      }).catch((err) =&gt; {
        done(err)
      })
    })
  })</code></pre>
<p>对应上述代码：</p>
<ul>
<li>Given部分给出了提供的数据，<code>searchCriteria</code>和<code>searchResult</code>对象</li>
<li>When部分调用了<code>findUserByPaging</code>方法</li>
<li>Then对返回结果进行了断言，判断了是否与预期结果<code>expectData</code>符合</li>
<li>本例中对<code>findUserByPaging</code>方法所调用到的<code>UserRepo</code>对象的<code>findUserByPaging</code>方法进行了打桩并使其返回了我们对其预期的返回数据<code>searchResult</code></li>
</ul>
<h4 id="mock-or-stub"><a href="#mock-or-stub" class="headerlink" title="mock or stub"></a>mock or stub</h4><p>如上述代码所示，使用到了sinon.js的<code>createSandbox</code>和<code>stub</code>方法</p>
<ul>
<li><a href="https://sinonjs.org/releases/v7.5.0/sandbox/" target="_blank" rel="noopener">sandbox</a></li>
<li><a href="https://sinonjs.org/releases/v7.5.0/stubs/" target="_blank" rel="noopener">stub</a></li>
</ul>
<blockquote>
<p>Default sandbox: Since <a href="mailto:sinon@5.0.0" target="_blank" rel="noopener">sinon@5.0.0</a>, the sinon object is a default sandbox. Unless you have a very advanced setup or need a special configuration, you probably want to just use that one.</p>
</blockquote>
<p>与直接使用<code>sinon.stub()</code>比起来使用<code>sandbox</code>要更安全，而且在部分情况下前者会出现stub不掉的情况，而后者则不会</p>
<pre><code class="js">&quot;test should call all subscribers, even if there are exceptions&quot; : function(){
    var message = &#39;an example message&#39;;
    var stub = sinon.stub().throws();
    var spy1 = sinon.spy();
    var spy2 = sinon.spy();

    PubSub.subscribe(message, stub);
    PubSub.subscribe(message, spy1);
    PubSub.subscribe(message, spy2);

    PubSub.publishSync(message, undefined);

    assert(spy1.called);
    assert(spy2.called);
    assert(stub.calledBefore(spy1));
}</code></pre>
<pre><code class="js">// Creates a new sandbox object with spies, stubs, and mocks.
var sandbox = sinon.createSandbox();
beforeEach(function() {
    sandbox = sinon.createSandbox();
    sandbox.stub(UserRepo, &quot;findUserByPaging&quot;).withArgs(sinon.match.any).returns(searchResult)
});
afterEach(function() {
    sandbox.restore()
});</code></pre>
<h4 id="使用-supertest来编写模拟HTTP请求的-Unit-Test"><a href="#使用-supertest来编写模拟HTTP请求的-Unit-Test" class="headerlink" title="使用 supertest来编写模拟HTTP请求的 Unit Test"></a>使用 supertest来编写模拟HTTP请求的 Unit Test</h4><pre><code class="js">  describe(&#39;/nj_dom_notification/users/page&#39;, function() {
    let sandbox;
    const data = [
      {
        &quot;userId&quot;: 1,
        &quot;userDomain&quot;: &quot;TESTUSER&quot;,
        &quot;userEmail&quot;: &quot;test.user@outlook.com&quot;,
        &quot;userTel&quot;: &quot;1234567890&quot;,
        &quot;userTeam&quot;: &quot;MBC&quot;,
        &quot;role&quot;: [
          {
            &quot;roleId&quot;: 1,
            &quot;roleName&quot;: &quot;Super Admin&quot;
          }
        ]
      }
    ]
    beforeEach(function() {
      sandbox = sinon.createSandbox();
      sandbox.stub(userController, &quot;findUserByPaging&quot;).callsFake(() =&gt; {
        return responseHelper.responsePageSuccess(data)
      })
    });
    afterEach(function() {
      sandbox.restore();
    });

    it(&#39;should get user list json when call findUserByPaging&#39;, (done) =&gt; {
      request(app)
        .get(&#39;/nj_dom_notification/users/page?userDomain=TESTUSER&amp;limit=10&amp;offset=0&#39;)
        .set(&#39;Accept&#39;, &#39;application/json&#39;)
        .expect(&#39;Content-Type&#39;, &#39;application/json; charset=utf-8&#39;)
        .expect(200, done)
        .expect(function(res) {
          assert.equal(res.body.success, true);
        })
    })
  })</code></pre>
<h4 id="使用-Istanbul-js来统计-Unit-Test的代码覆盖率"><a href="#使用-Istanbul-js来统计-Unit-Test的代码覆盖率" class="headerlink" title="使用 Istanbul.js来统计 Unit Test的代码覆盖率"></a>使用 Istanbul.js来统计 Unit Test的代码覆盖率</h4><pre><code class="json">{
 &quot;scripts&quot;: {
   &quot;unit-test-cov&quot;: &quot;istanbul cover node_modules/mocha/bin/_mocha -- test/controller test/routes test/common test/service&quot;
 }
}</code></pre>
<p>只需要在<code>istanbul cover</code>命令后面加上mocha的命令即可</p>
<p>若有不想统计的代码可以使用<code>/* istanbul ignore next */</code>注释来忽略掉，但是istanbul不支持文件忽略，只支持函数、选择条件级别的忽略。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TDD/" rel="tag">TDD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unit-test/" rel="tag">Unit test</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chai-js/" rel="tag">chai.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/istanbul-js/" rel="tag">istanbul.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mocha/" rel="tag">mocha</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sinon-js/" rel="tag">sinon.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/supertest/" rel="tag">supertest</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Sicmatr1x
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Sicmatr1x"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>