<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Sicmatr1x"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Sicmatr1x</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['理智是慢慢黑夜里的一个微小的火花，是疯狂的世界里的一个珍贵的例外。', 'Reason is a tiny spark in the dark night, a precious exception in the crazy world.', '给岁月以文明而非给文明以岁月。'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-JVM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/29/JVM/"
    >JVM</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/29/JVM/" class="article-date">
  <time datetime="2020-07-29T07:22:36.000Z" itemprop="datePublished">2020-07-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="基于栈的指令集架构与基于寄存器的指令集架构"><a href="#基于栈的指令集架构与基于寄存器的指令集架构" class="headerlink" title="基于栈的指令集架构与基于寄存器的指令集架构"></a>基于栈的指令集架构与基于寄存器的指令集架构</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p>
<p>基于栈式架构：</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li>
<li>不需要硬件支持</li>
</ul>
<p>基于寄存器架构：</p>
<ul>
<li>例如x86的二进制指令集</li>
<li>指令集架构完全依赖硬件</li>
<li>性能优秀，执行更高效</li>
<li>花费更少指令完成一项操作</li>
<li>通常为一地址指令、二地址指令、三地址指令。</li>
</ul>
<p>例如：计算2+3</p>
<p>基于栈：</p>
<pre><code>iconst_2 // 常量2入栈
istore_1
iconst_3 // 常量3入栈
istore_2
iload_1
iload_2
iadd  // 常量2，3出栈，执行相加
istore_0 // 结果5入栈</code></pre><p>基于寄存器：</p>
<pre><code>mov eax,2 // 将eax寄存器值设为2
add eax,3 // 使eax寄出器的值加3</code></pre><h3 id="反编译字节码案例"><a href="#反编译字节码案例" class="headerlink" title="反编译字节码案例"></a>反编译字节码案例</h3><p>StackStruTest.java</p>
<pre><code class="java">package com.sicmatr1x.java;

public class StackStruTest {
    public static void main(String[] args) {
        int i = 2;
        int j = 3;
        int k = i + j;
    }
}</code></pre>
<p>使用javap反编译指令反编译StackStruTest.class字节码文件：</p>
<pre><code>javap -v StackStruTest.class</code></pre><p>反编译结果：</p>
<pre><code>  Last modified 2020-7-30; size 486 bytes
  MD5 checksum 618bcdd36b54bf88b6efa145bd258086
  Compiled from &quot;StackStruTest.java&quot;
public class com.sicmatr1x.java.StackStruTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #22            // com/sicmatr1x/java/StackStruTest
   #3 = Class              #23            // java/lang/Object
   #4 = Utf8               &lt;init&gt;
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               Lcom/sicmatr1x/java/StackStruTest;
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               args
  #14 = Utf8               [Ljava/lang/String;
  #15 = Utf8               i
  #16 = Utf8               I
  #17 = Utf8               j
  #18 = Utf8               k
  #19 = Utf8               SourceFile
  #20 = Utf8               StackStruTest.java
  #21 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V
  #22 = Utf8               com/sicmatr1x/java/StackStruTest
  #23 = Utf8               java/lang/Object
{
  public com.sicmatr1x.java.StackStruTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/sicmatr1x/java/StackStruTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_2
         1: istore_1
         2: iconst_3
         3: istore_2
         4: iload_1
         5: iload_2
         6: iadd
         7: istore_3
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 2
        line 7: 4
        line 8: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            2       7     1     i   I
            4       5     2     j   I
            8       1     3     k   I
}
SourceFile: &quot;StackStruTest.java&quot;</code></pre><p>看code部分：</p>
<pre><code>Code:
    stack=2, locals=4, args_size=1
        0: iconst_2 // 定义常量2
        1: istore_1 // 保存到操作数1的栈中
        2: iconst_3 // 定义常量3
        3: istore_2 // 保存到操作数2的栈中
        4: iload_1 // 加载操作数1的值
        5: iload_2 // 加载操作数2的值
        6: iadd // 求和
        7: istore_3 // 保存到操作数3的栈中
        8: return</code></pre><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><ol>
<li>虚拟机的启动：JVM的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由JVM的具体实现指定的。</li>
<li>虚拟机的执行</li>
<li>虚拟机的终止：<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到异常或错误而异常终止</li>
<li>操作系统出现错误而导致JVM进程终止</li>
<li>某线程调用Runtime类或System类的exit方法或Runtime类的halt方法，并且Java安全管理器也允许这个词exit或halt操作</li>
<li>JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载JVM时JVM的退出情况</li>
</ul>
</li>
</ol>
<h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sum-Classic-VM"><a href="#Sum-Classic-VM" class="headerlink" title="Sum Classic VM"></a>Sum Classic VM</h3><p>世界上第一款商用Java虚拟机，虚拟机内部只提供了解释器</p>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>JDK1.2</p>
<p>准确式内存管理(Exact Memory Management)：虚拟机可以知道内存中某个位置的数据具体是什么类型</p>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>JDK1.3</p>
<p>是JDK6, JDK8默认虚拟机</p>
<h3 id="BEA的JRockit"><a href="#BEA的JRockit" class="headerlink" title="BEA的JRockit"></a>BEA的JRockit</h3><p>专注于服务器端应用</p>
<p>JRockit JVM是世界上最快的JVM</p>
<h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>IBM Techology for Java Virtual Machine简称IT4J，内部代号J9</p>
<h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC/CLDC Hotspot"></a>KVM和CDC/CLDC Hotspot</h3><p>目前移动领域地位尴尬，KVM简单、轻量、高度可移植，面向低端可移动设备</p>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>Azul VM和BEA Liquid VM与特定硬件平台绑定、软硬件配合的专有虚拟机</p>
<p>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，提供在巨大内存内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等</p>
<h3 id="BEA-Liquid-VM"><a href="#BEA-Liquid-VM" class="headerlink" title="BEA Liquid VM"></a>BEA Liquid VM</h3><p>BEA开发用于自家Hypervisor系统，不需要操作系统的支持，它本身实现了一个专用操作系统的必要功能</p>
<h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><p>JDK1.5, JDK1.6</p>
<p>由IBM于Intel联合开发</p>
<h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>基于OpenJDK HotSpot VM深度定制且开源的高性能服务器</p>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>是虚拟机但不是Java虚拟机，不能直接执行Java的class文件，美原油遵循Java虚拟机规范</p>
<p>基于寄存器架构，不是JVM的栈架构，执行dex(Dalvik Executable)文件，可由class文件转化来</p>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用(包括：Java, Scala, Groovy, Kotlin; C, C++, JavaScript, Ruby, Python, R等)</p>
<p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件。工作原理是将这些语言的源码或源码编译后的中间格式通过解释器转换成能被Graal VM接受的中间表示。</p>
<p>还提供Truffle工具集快速构建面向一种新语言的解释器。</p>
<h1 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><img src="./内存结构概述.png">

<img src="./内存结构.png">


<p>类加载子系统负责从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识</p>
<p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p>
<p>加载的类信息存放在叫做方法区的内存空间。除了类信息外，方法区还存放运行时常量池信息，可能还有字符串和数字常量</p>
<p>class file加载到JVM中被称为DNA元数据模板，放在方法区</p>
<h3 id="字节码文件-class"><a href="#字节码文件-class" class="headerlink" title="字节码文件.class"></a>字节码文件.class</h3><p>使用二进制查看器打开任意字节码文件可以观察到期开头4个字节用十六进制表示为<code>CA FE BA BE</code>(可记为咖啡宝贝)，这是字节码文件固定头部</p>
<h3 id="1-加载-Loading"><a href="#1-加载-Loading" class="headerlink" title="1. 加载 Loading"></a>1. 加载 Loading</h3><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的今天存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>可以从哪些地方加载.class文件呢：</p>
<ul>
<li>本地文件加载</li>
<li>网络获取，典型场景：web Applet</li>
<li>zip压缩包中读取</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>其它文件生成，例如：JSP应用</li>
<li>专有数据库提取.class文件，少见</li>
<li>加密文件中获取，可防止class文件被反编译</li>
</ul>
<h3 id="2-链接-Linking"><a href="#2-链接-Linking" class="headerlink" title="2. 链接 Linking"></a>2. 链接 Linking</h3><p>该阶段分为以下几步：</p>
<ol>
<li>验证(Verify)<ul>
<li>目的在于确保class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
</li>
</ul>
</li>
<li>准备(Prepare)<ul>
<li>为变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到java堆中</li>
</ul>
</li>
<li>解析(Resolve)<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>解析操作往往伴随JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li>
</ul>
</li>
</ol>
<h3 id="3-初始化-Initialization"><a href="#3-初始化-Initialization" class="headerlink" title="3. 初始化 Initialization"></a>3. 初始化 Initialization</h3><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需定义，是由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器<code>&lt;init&gt;()</code>，若一个类中没有静态变量和静态代码块则字节码文件中无<code>&lt;clinit&gt;()</code>方法</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ul>
<pre><code class="java">package com.sicmatr1x.java;

public class ClinitTest {
    private int a = 1;
    private static int c = 3;

    public static void main(String[] args) {
        int b = 2;
    }

    public ClinitTest() {
        a = 10;
        int d = 20;
    }
}</code></pre>
<p>反编译字节码文件可以看到存在<code>&lt;clinit&gt;()</code>和<code>&lt;init&gt;()</code></p>
<p><code>&lt;init&gt;</code>如下：</p>
<pre><code> 0 aload_0
 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;
 4 aload_0
 5 iconst_1
 6 putfield #2 &lt;com/sicmatr1x/java/ClinitTest.a&gt;
 9 aload_0
10 bipush 10
12 putfield #2 &lt;com/sicmatr1x/java/ClinitTest.a&gt;
15 bipush 20
17 istore_1
18 return</code></pre><p>可以看到先给a赋值10再给d赋值20</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>JVM支持两种类型的类加载器：</p>
<ol>
<li>引导类加载器(Bootstrap ClassLoader)</li>
<li>自定义类加载器(User-Defined ClassLoader)：所有派生于抽象类ClassLoader的类加载器都可划分为自定义类加载器</li>
</ol>
<p>启动类加载器(引导类加载器, Bootstrap ClassLoader)：</p>
<ul>
<li>使用C/C++语言实现，嵌套在JVM内部</li>
<li>用于加载Java的核心库(JAVA_HOME/jre/lib/rt.jar, resources.jar或sun.boot.class.path路径下的内容)</li>
<li>不继承于java.lang.ClassLoader，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并制定为他们的父类加载器</li>
<li>处于安全考虑，Bootstrap启动类加载器只加载包名为java, javax, sun等开头的类</li>
</ul>
<p>扩展类加载器(Extension ClassLoader)</p>
<ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录，也会自动由扩展类加载器加载。</li>
</ul>
<p>应用程序类加载器(系统类加载器, AppClassLoader)</p>
<ul>
<li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载器是程序中默认的类加载器，通常Java应用的类都由它来加载</li>
<li>通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取到该类加载器</li>
</ul>
<p>获取Bootstrap ClassLoader类加载器和Extension ClassLoader类加载器可以加载的路径和jar包</p>
<pre><code class="java">package com.sicmatr1x.java;

import sun.misc.Launcher;
import sun.misc.URLClassPath;

import java.net.URL;

public class ClassLoaderTest1 {
    public static void main(String[] args) {
        System.out.println(&quot;引导类加载器：&quot;);
        URLClassPath urlClassPath = Launcher.getBootstrapClassPath();
        URL[] urls = urlClassPath.getURLs();
        for (URL url : urls) {
            System.out.println(url.toExternalForm());
        }
        System.out.println(&quot;扩展类加载器：&quot;);
        String extDirs = System.getProperty(&quot;java.ext.dirs&quot;);
        for (String dir : extDirs.split(&quot;;&quot;)) {
            System.out.println(dir);
        }
    }
}
</code></pre>
<pre><code>引导类加载器：
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/resources.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/sunrsasign.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jsse.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/charsets.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jfr.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/classes
扩展类加载器：
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext
C:\Windows\Sun\Java\lib\ext</code></pre><p>用户自定义类加载器：</p>
<ul>
<li>什么时候需要用户自定义类加载器：<ul>
<li>隔离加载类：例如：确保应用中引用的jar包与中间件引用的第三方jar包不冲突</li>
<li>修改类加载方式：例如：需要时候动态加载</li>
<li>扩展加载源：例如：从数据库中加载</li>
<li>防止源码泄露</li>
</ul>
</li>
<li>用户自定义类加载器实现步骤：<ol>
<li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式实现自己的类加载器</li>
<li>在JDK1.2之前，自定义类加载器需要继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载器。JDK1.2之后不建议用户覆盖loadClass()方法，建议把自定义的类加载逻辑写在findClass()方法中</li>
<li>编写自定义类加载器时若无过于复杂的需求建议直接继承URLClassLoader类，这样可以避免自己去编写findClass()方法及获取字节码流的方式，是自定义类加载器编写更加简洁</li>
</ol>
</li>
</ul>
<pre><code class="java">package com.sicmatr1x.java;

import java.io.FileNotFoundException;

public class CustomClassLoader extends ClassLoader{
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {

        try {
            byte[] result = getClassFromCustomPath(name);
            if(result == null){
                throw new FileNotFoundException();
            }else{
                return defineClass(name,result,0,result.length);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        throw new ClassNotFoundException(name);
    }

    private byte[] getClassFromCustomPath(String name){
        //从自定义路径中加载指定类:细节略
        //如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。
        return null;
    }

    public static void main(String[] args) {
        CustomClassLoader customClassLoader = new CustomClassLoader();
        try {
            Class&lt;?&gt; clazz = Class.forName(&quot;One&quot;,true,customClassLoader);
            Object obj = clazz.newInstance();
            System.out.println(obj.getClass().getClassLoader());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>常用方法：</p>
<ul>
<li>getParent(): 返回该类加载器的超类加载器</li>
<li>loadClass(String name): 加载名称为name的类，返回结果为java.lang.Class类的实例</li>
<li>findClass(String name): 查找名称为name的类，返回结果为java.lang.Class类的实例</li>
<li>findLoadedClass(String name): 查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</li>
<li>defineClass(String name, byte[] b, int off, int len): 把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</li>
<li>resolveClass(Class&lt;?&gt; c): 连接指定的一个Java类</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>JVM对class文件采用按需加载的方式，即需要使用到该类时才会把class文件加载到内存生成class对象。而且在加载时JVM采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式。</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，若无法完成，之类加载器才会去加载。</li>
</ol>
<p>优点：</p>
<ul>
<li>避免类的重复加载：一旦一个类被父加载器加载则不会再被子加载器加载</li>
<li>保护程序安全，防止核心API被篡改：比如你自己定义一个java.lang.String就不会被AppClassLoader加载而是Bootstrap ClassLoader加载java的String</li>
</ul>
<p>沙箱安全机制：<br>自定义String类在加载的时候回率先使用引导类加载器加载，而引导类加载器会先加载JDK自带的文件rt.jar包中的java\lang\String.class，这样可以保证对java核心源代码的保护</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>JVM中表示两个class对象是否为同一个类存在的两个必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</li>
</ol>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><p>JVM知道一个类时由启动类加载器加载器加载的还是由用户类加载器加载的。若是由用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类到另一个类的时候，JVM需要保证这两个类的类加载器是相同的。</p>
<h3 id="类的主动使用与被动使用"><a href="#类的主动使用与被动使用" class="headerlink" title="类的主动使用与被动使用"></a>类的主动使用与被动使用</h3><p>主动使用的七种情况：</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供动态语言支持：<ul>
<li>java.lang,invoke.MethodHandle实例的解析结果</li>
<li>REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
</ol>
<p>除了主动使用的七种情况外都算被动使用</p>
<h2 id="运行时数据区-Runtime-Data-Area-内部结构"><a href="#运行时数据区-Runtime-Data-Area-内部结构" class="headerlink" title="运行时数据区(Runtime Data Area)内部结构"></a>运行时数据区(Runtime Data Area)内部结构</h2><p>运行时数据区的完整图</p>
<img src="image-20200705112416101.png">

<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<img src="image-20200705112601211.png">

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
<h4 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h4><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>
<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<p>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p>在JVM规范中，每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间都只有一个方法在执行，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，若为native方法则为undefined</p>
<h4 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h4><ol>
<li>使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？</li>
</ol>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后就需要知道从哪开始继续执行。JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<ol start="2">
<li>PC寄存器为什么会被设定为线程私有？</li>
</ol>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><p>首先栈是运行时的单位，而堆是存储的单位</p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<p>虚拟机栈包括多个栈帧，每个栈帧包括：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法返回地址</li>
</ul>
<h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackOverFlowError</code> 异常。</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<code>OutOfMemoryError</code> 异常。</p>
<h4 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h4><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度，可以设置到idea的VM Options里面</p>
<pre><code class="java">-Xss1m
-Xss1k</code></pre>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只用当前正在执行方法的栈帧(栈顶栈帧)是有效的，也被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（operand Stack）（或表达式栈）</li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<img src="image-20200705204836977.png">

<h3 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h3><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p>
<p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h4 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h4><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
<p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p>
<blockquote>
<p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>1ong和double则占据两个slot。</p>
</blockquote>
<p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p>
<p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p>
<img src="image-20200705212454445.png">

<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><p>变量的分类：</p>
<ul>
<li>按数据类型分：基本数据类型、引用数据类型</li>
<li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul>
<li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li>
<li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
<li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li>
</ul>
</li>
</ul>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈：Operand Stack</p>
<p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<img src="image-20200706090618332.png">

<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p>
<h4 id="反编译字节码解读示例"><a href="#反编译字节码解读示例" class="headerlink" title="反编译字节码解读示例"></a>反编译字节码解读示例</h4><pre><code class="java">package com.sicmatr1x.java;

public class OperandStackTest {
    public void testAddOperation() {
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
}</code></pre>
<pre><code>  Last modified 2020-8-5; size 459 bytes
  MD5 checksum 0c86be65af756c867db277302bedf1fa
  Compiled from &quot;OperandStackTest.java&quot;
public class com.sicmatr1x.java.OperandStackTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #20            // com/sicmatr1x/java/OperandStackTest
   #3 = Class              #21            // java/lang/Object
   #4 = Utf8               &lt;init&gt;
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               Lcom/sicmatr1x/java/OperandStackTest;
  #11 = Utf8               testAddOperation
  #12 = Utf8               i
  #13 = Utf8               B
  #14 = Utf8               j
  #15 = Utf8               I
  #16 = Utf8               k
  #17 = Utf8               SourceFile
  #18 = Utf8               OperandStackTest.java
  #19 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V
  #20 = Utf8               com/sicmatr1x/java/OperandStackTest
  #21 = Utf8               java/lang/Object
{
  public com.sicmatr1x.java.OperandStackTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/sicmatr1x/java/OperandStackTest;

  public void testAddOperation();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        15
         2: istore_1
         3: bipush        8
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: return
      LineNumberTable:
        line 5: 0
        line 6: 3
        line 7: 6
        line 8: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lcom/sicmatr1x/java/OperandStackTest;
            3       8     1     i   B
            6       5     2     j   I
           10       1     3     k   I
}
SourceFile: &quot;OperandStackTest.java&quot;</code></pre><p>常量池：</p>
<pre><code>Constant pool:
   #1 = Methodref          #3.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #20            // com/sicmatr1x/java/</code></pre><p>如果操作指令有用到常量池里的常量会出现<code>#2</code>这样的表示调用的是哪个常量</p>
<pre><code>    Code:
      stack=1, locals=1, args_size=1</code></pre><p>这里的<code>stack=1</code>表示操作数栈为1，<code>locals=4</code>表示本地变量表长度为4</p>
<p>本地变量表：</p>
<pre><code>      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lcom/sicmatr1x/java/OperandStackTest;
            3       8     1     i   B
            6       5     2     j   I
           10       1     3     k   I</code></pre><p>这里的start和length指的是该变量的生命周期对应操作指令的地址。这里因为没有double, long所以都是每个变量占用一个slot。byte, short, char, boolean都以int型来保存</p>
<p>分析操作指令：</p>
<pre><code>0: bipush        15
2: istore_1
3: bipush        8
5: istore_2
6: iload_1
7: iload_2
8: iadd
9: istore_3
10: return</code></pre><p>手动执行指令，因为局部变量表所需的容量大小是在编译期确定下来的，所以这里没值的用[]来占位，且省略局部变量表第0号元素<code>this</code>：</p>
<ul>
<li><code>0: bipush        15</code><ul>
<li>PC寄存器: 0</li>
<li>局部变量表: <ol>
<li>[]</li>
<li>[]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[15] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
<li><code>2: istore_1</code>: i指int类型，store存放到局部变量表，_1索引位1的位置<ul>
<li>PC寄存器: 2</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
<li><code>3: bipush        8</code><ul>
<li>PC寄存器: 3</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[8] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
<li><code>5: istore_2</code><ul>
<li>PC寄存器: 2</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[8]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
<li><code>6: iload_1</code>: 从局部比那里表中取索引位1的数据到操作数栈<ul>
<li>PC寄存器: 6</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[8]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[15] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
<li><code>7: iload_2</code>: 从局部比那里表中取索引位2的数据到操作数栈<ul>
<li>PC寄存器: 7</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[8]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[8] &lt;-栈顶</li>
<li>[15]</li>
</ul>
</li>
</ul>
</li>
<li><code>8: iadd</code>: 操作数栈出栈并做加法运算<ul>
<li>PC寄存器: 8</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[8]</li>
<li>[]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[23] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
<li><code>9: istore_3</code><ul>
<li>PC寄存器: 9</li>
<li>局部变量表: <ol>
<li>[15]</li>
<li>[8]</li>
<li>[23]</li>
</ol>
</li>
<li>操作数栈 : <ul>
<li>[]</li>
<li>[] &lt;-栈顶</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p>
<p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p>
<p>i++和++i的区别</p>
<h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>栈顶缓存技术：Top Of Stack Cashing</p>
<p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<blockquote>
<p>寄存器：指令更少，执行速度快</p>
</blockquote>
<h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h3><img src="image-20200706100311886.png">

<blockquote>
<p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p>
</blockquote>
<p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p>
<p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<img src="image-20200706101251847.png">

<blockquote>
<p>为什么需要运行时常量池？</p>
<p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
</blockquote>
<h3 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<p>早期绑定：</p>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<p>晚期绑定：</p>
<p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<h4 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h4><ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
<blockquote>
<p>子类对象的多态的使用前提</p>
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</blockquote>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<p>普通调用指令：</p>
<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<p>动态调用指令：</p>
<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p>
<h4 id="invokednamic指令"><a href="#invokednamic指令" class="headerlink" title="invokednamic指令"></a>invokednamic指令</h4><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<blockquote>
<p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p>
<p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p>
</blockquote>
<h4 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h4><p>注意：在调用对象方法前会将这个对象的引用压入操作数栈顶，因为后面需要需到其实际类型</p>
<p>Java 语言中方法重写的本质：</p>
<ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li>
</ul>
<p>IllegalAccessError介绍：<br>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变</p>
<h4 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h4><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>虚方法表是什么时候被创建的呢？</p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<h1 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h1><h1 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h1><h1 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Ethereum"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/25/Ethereum/"
    >Ethereum</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/25/Ethereum/" class="article-date">
  <time datetime="2020-07-25T02:28:01.000Z" itemprop="datePublished">2020-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ETH/" rel="tag">ETH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91/" rel="tag">踩坑</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java-NIO"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/25/Java-NIO/"
    >Java NIO</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/25/Java-NIO/" class="article-date">
  <time datetime="2020-07-25T02:25:07.000Z" itemprop="datePublished">2020-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Java NIO(New IO或Non Bloking IO)是从Java1.4版本开始引入的一个新的IO API，NIO支持面向缓冲区的、基于通道的IO操作，读写文件更加高效。</p>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>IO<ul>
<li>面向流(Stream Oriented)：相当于水管，一个steam一个方向出水的水管</li>
<li>阻塞IO(Blocking IO)</li>
<li>无选择器</li>
</ul>
</li>
<li>NIO<ul>
<li>面向缓冲区(Buffer Oriented)：相当于铁路，一条铁路上面有一个缓冲区可以装数据然后双向运输</li>
<li>非阻塞IO(Non Blocking IO)</li>
<li>选择器(Selectors)</li>
</ul>
</li>
</ul>
<p>NIO系统的核心：通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。</p>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><ol>
<li>缓冲区(Buffer):在NIO中复制数据的春秋，缓冲区就是数组。<ul>
<li>根据数据类型的不同可以分配对应的缓冲区，boolean类型除外</li>
</ul>
</li>
</ol>
<ol start="2">
<li>缓冲区存取数据的两个核心方法：</li>
</ol>
<ul>
<li>put()</li>
<li>get()</li>
</ul>
<ol start="3">
<li>缓冲区四个核心属性<ol>
<li>int capacity(容量): 表示缓冲区中最大存储数据的容量。一旦声明不能改变。</li>
<li>limit: 界限，表示缓冲区中可以操作数据的大小，即limit后的数据不能进行读写</li>
<li>position: 位置，表示缓冲区中正在操作数据的位置，且需满足(position &lt;= limit &lt;= capacity)</li>
<li>mark: 标记，标记当前position的位置，可以通过<code>reset()</code>恢复到mark的位置</li>
</ol>
</li>
</ol>
<p>这几个属性位于<code>java.nio.Buffer</code>类里</p>
<pre><code class="java">public abstract class Buffer {

    /**
     * The characteristics of Spliterators that traverse and split elements
     * maintained in Buffers.
     */
    static final int SPLITERATOR_CHARACTERISTICS =
        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;

    // Invariants: mark &lt;= position &lt;= limit &lt;= capacity
    private int mark = -1;
    private int position = 0;
    private int limit;
    private int capacity;</code></pre>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><pre><code class="java">    public void test1() {
        String str = &quot;abcde&quot;;
        // 分配一个指定大小的缓冲区
        ByteBuffer buf = ByteBuffer.allocate(1024);
        System.out.println(buf.position()); // 0
        System.out.println(buf.limit()); // 1024
        System.out.println(buf.capacity()); // 1024
        // 写数据
        buf.put(str.getBytes());
        System.out.println(buf.position()); // 5
        System.out.println(buf.limit()); // 1024
        System.out.println(buf.capacity()); // 1024
        // 切换读取数据模式
        buf.flip();
        System.out.println(buf.position()); // 0
        System.out.println(buf.limit()); // 5
        System.out.println(buf.capacity()); // 1024
        // 读数据
        byte[] dst = new byte[buf.limit()];
        buf.get(dst);
        System.out.println(new String(dst, 0, dst.length)); // abcd
        System.out.println(buf.position()); // 5
        System.out.println(buf.limit()); // 5
        System.out.println(buf.capacity()); // 1024
        // rewind() 可重复读数据
        buf.rewind();
        System.out.println(buf.position()); // 0
        System.out.println(buf.limit()); // 5
        System.out.println(buf.capacity()); // 1024
        // clear() 清空缓冲区，但是数据依然存在且处于被遗忘状态
        buf.clear();
        System.out.println(buf.position()); // 0
        System.out.println(buf.limit()); // 1024
        System.out.println(buf.capacity()); // 1024
    }</code></pre>
<pre><code class="java">    public void test2() {
        String str = &quot;abcde&quot;;
        ByteBuffer buf = ByteBuffer.allocate(1024);
        buf.put(str.getBytes());
        buf.flip();
        byte[] dst = new byte[buf.limit()];
        buf.get(dst, 0, 2);
        System.out.println(new String(dst, 0, 2));
        System.out.println(buf.position()); // 2
        buf.mark();
        buf.get(dst, 2, 2);
        System.out.println(new String(dst, 0, 2));
        System.out.println(buf.position()); // 4
        buf.reset();
        System.out.println(buf.position()); // 2
    }</code></pre>
<ol start="4">
<li>直接缓冲区与非直接缓冲区</li>
</ol>
<ul>
<li>非直接缓冲区：通过<code>allocate()</code>方法分配的缓冲区，缓冲区建立在JVM的内存中</li>
<li>直接缓冲区：通过<code>allocateDirect()</code>方法分配的直接缓冲区或者使用FileChannel的map()方法返回MappedByteBuffer对象，将缓冲区建立在物理内存中。可以提高效率</li>
</ul>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><p>用于源节点和目标节点间的连接，在NIO中复制缓冲区中数据的传输。Channel本身不存储数据，需要配合缓冲区使用。</p>
<h4 id="通道主要实现类"><a href="#通道主要实现类" class="headerlink" title="通道主要实现类"></a>通道主要实现类</h4><ul>
<li>java.nio.channels.CHannel<ul>
<li>FileChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
<li>DatagramChannel</li>
</ul>
</li>
</ul>
<h4 id="获取通道的几种方式"><a href="#获取通道的几种方式" class="headerlink" title="获取通道的几种方式"></a>获取通道的几种方式</h4><ol>
<li>Java针对支持通道的类提供了<code>getChannel()</code>方法用于获取对应的通道<ul>
<li>本地IO<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>RandomAccessFile</li>
</ul>
</li>
<li>网络IO<ul>
<li>Socket</li>
<li>ServerSocket</li>
<li>DatagramSocket</li>
</ul>
</li>
</ul>
</li>
<li>JDK1.7提供的NIO.2针对各个通道提供了静态方法<code>open()</code></li>
<li>JDK1.7中的NIO.2的Files工具类的<code>newByteChannel()</code>方法</li>
</ol>
<h4 id="通道使用案例"><a href="#通道使用案例" class="headerlink" title="通道使用案例"></a>通道使用案例</h4><pre><code class="java">    /**
     * 直接缓冲区：利用通道实现本地文件复制(内存映射文件)
     */
    @Test
    public void test2() throws IOException {
        FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.png&quot;), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get(&quot;3.png&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);
        // 内存映射文件
        MappedByteBuffer inMappedBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
        MappedByteBuffer outMappedBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());
        // 直接对缓冲区进行数据的读写操作
        byte[] dst = new byte[inMappedBuffer.limit()];
        inMappedBuffer.get(dst);
        outMappedBuffer.put(dst);

        inChannel.close();
        outChannel.close();
    }

    @Test
    public void test3() throws IOException {
        FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.png&quot;), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get(&quot;3.png&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);

        inChannel.transferTo(0, inChannel.size(), outChannel);

        inChannel.close();
        outChannel.close();
    }
</code></pre>
<h4 id="分散-Scatter-于聚集-Gather"><a href="#分散-Scatter-于聚集-Gather" class="headerlink" title="分散(Scatter)于聚集(Gather)"></a>分散(Scatter)于聚集(Gather)</h4><ul>
<li>分散读取(Scattering Reads): 将通道中的数据分散到多个缓冲区中</li>
<li>聚集写入(Gathering Writes): 将多个缓冲区中的数据聚集到通道中</li>
</ul>
<pre><code class="java">    public void test4() throws IOException {
        RandomAccessFile raf1 = new RandomAccessFile(&quot;1.txt&quot;, &quot;r&quot;);
        // 获取通道
        FileChannel fileChannel1 = raf1.getChannel();
        // 分配多个缓冲区
        ByteBuffer buf1 = ByteBuffer.allocate(100);
        ByteBuffer buf2 = ByteBuffer.allocate(1024);
        // 分散读取
        ByteBuffer[] bufs = {buf1, buf2};
        fileChannel1.read(bufs);

        for (ByteBuffer byteBuffer : bufs) {
            byteBuffer.flip();
        }
        System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));

        // 聚集写入
        RandomAccessFile raf2 = new RandomAccessFile(&quot;2.txt&quot;, &quot;rw&quot;);
        FileChannel fileChannel2 = raf2.getChannel();
        fileChannel2.write(bufs);

        fileChannel1.close();
        fileChannel2.close();
    }</code></pre>
<h4 id="字符集-Charset"><a href="#字符集-Charset" class="headerlink" title="字符集(Charset)"></a>字符集(Charset)</h4><pre><code class="java">    public void test6() throws CharacterCodingException {
        Charset cs1 = Charset.forName(&quot;GBK&quot;);
        // 获取编码器与解码器
        CharsetEncoder ce = cs1.newEncoder();
        CharsetDecoder cd = cs1.newDecoder();

        CharBuffer buffer = CharBuffer.allocate(1024);
        buffer.put(&quot;获取编码器与&quot;);
        buffer.flip();

        // 编码
        ByteBuffer bBuf = ce.encode(buffer);

        for (int i = 0; i &lt; 12; i++) {
            System.out.println(bBuf.get());
        }

        // 解码
        bBuf.flip();
        CharBuffer cBuf = cd.decode(bBuf);
        System.out.println(cBuf.toString());
    }</code></pre>
<h3 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h3><p>使用NIO完成网络通信需要：</p>
<ol>
<li>通道(Channel): 负责连接<ul>
<li>java.nio.channels.Channel接口<ul>
<li>SelectableChannel<ul>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
<li>DatagramChannel</li>
<li>Pipe.SinkChannel</li>
<li>Pipe.SourceChannel</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区(Buffer): 负责数据的存取</li>
<li>选择器(Selector): 是SelectableChannel的多路复用器。用于监控SelectableChannel的IO状况</li>
</ol>
<h3 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h3><h4 id="使用ServerSocketChannel"><a href="#使用ServerSocketChannel" class="headerlink" title="使用ServerSocketChannel"></a>使用ServerSocketChannel</h4><pre><code class="java">package com.sicmatr1x.nio;

import org.junit.Test;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.time.LocalDateTime;
import java.util.Iterator;
import java.util.Scanner;

public class TestNonBlockingNIO {
    @Test
    public void client() throws IOException {
        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));
        // 切换成非阻塞模式
        sChannel.configureBlocking(false);
        // 分配缓冲区
        ByteBuffer buf = ByteBuffer.allocate(1024);
        // 发送数据
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str = scanner.next();
            buf.put((LocalDateTime.now().toString() + &quot;:&quot; + str).getBytes());
            buf.flip();
            sChannel.write(buf);
            buf.clear();
        }

        sChannel.close();
    }

    @Test
    public void server() throws IOException {
        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        // 切换成非阻塞模式
        ssChannel.configureBlocking(false);
        // 绑定连接
        ssChannel.bind(new InetSocketAddress(9898));
        // 获取选择器
        Selector selector = Selector.open();
        // 将通道注册到选择器，并且指定监听事件
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);
        // 轮询式的获取选择器上已经准备就绪的事件
        while (selector.select() &gt; 0) {
            // 获取当前选择器中所有注册的且已就绪的选择键
            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
            // 迭代
            while(iterator.hasNext()) {
                // 获取准备就绪的事件
                SelectionKey key = iterator.next();
                // 判断是什么事件就绪
                if (key.isAcceptable()) { // 若为接收就绪
                    SocketChannel sChannel = ssChannel.accept();
                    sChannel.configureBlocking(false);
                    sChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {
                    // 获取当前选择器上读就绪的通道
                    SocketChannel sChannel = (SocketChannel)key.channel();

                    ByteBuffer buffer = ByteBuffer.allocate(1024);

                    int len = 0;
                    while((len = sChannel.read(buffer)) &gt; 0) {
                        buffer.flip();
                        System.out.println(new String(buffer.array(), 0, len));
                        buffer.clear();
                    }
                }
                // 取消选择键
                iterator.remove();
            }
        }
    }
}
</code></pre>
<h4 id="使用DatagramChannel"><a href="#使用DatagramChannel" class="headerlink" title="使用DatagramChannel"></a>使用DatagramChannel</h4><pre><code class="java">package com.sicmatr1x.nio;

import org.junit.Test;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Date;
import java.util.Iterator;
import java.util.Scanner;

public class TestNonBlockingNIO2 {
    @Test
    public void send() throws IOException {
        DatagramChannel dc = DatagramChannel.open();

        dc.configureBlocking(false);

        ByteBuffer buffer = ByteBuffer.allocate(1024);

        Scanner scan = new Scanner(System.in);

        while(scan.hasNext()) {
            String str = scan.next();
            buffer.put((new Date().toString() + &quot;:&quot; + str).getBytes());
            dc.send(buffer, new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));
            buffer.clear();
        }
        dc.close();
    }

    @Test
    public void receive() throws IOException {
        DatagramChannel dc = DatagramChannel.open();

        dc.configureBlocking(false);

        dc.bind(new InetSocketAddress(9898));

        Selector selector = Selector.open();

        dc.register(selector, SelectionKey.OP_READ);

        while(selector.select() &gt; 0) {
            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
            while(it.hasNext()) {
                SelectionKey key = it.next();
                if(key.isReadable()) {
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    dc.receive(buffer);
                    buffer.flip();
                    System.out.println(new String(buffer.array(), 0, buffer.limit()));
                }
            }
            it.remove();
        }
    }
}
</code></pre>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><pre><code class="java">package com.sicmatr1x.nio;

import org.junit.Test;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Pipe;

public class TestPip {
    @Test
    public void test1() throws IOException {
        // 获取管道
        Pipe pipe = Pipe.open();
        // 将缓冲区中的数据写入管道
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        Pipe.SinkChannel sinkChannel = pipe.sink();
        buffer.put(&quot;通过管道发送数据&quot;.getBytes());
        buffer.flip();
        sinkChannel.write(buffer);

        // 读取数据
        ByteBuffer buffer1 = ByteBuffer.allocate(1024);
        Pipe.SourceChannel sourceChannel = pipe.source();
        int len = sourceChannel.read(buffer1);
        System.out.println(new String(buffer1.array(), 0, len));

        sourceChannel.close();
        sinkChannel.close();
    }
}
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91/" rel="tag">踩坑</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-SpringCloud-Alibaba"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/13/SpringCloud-Alibaba/"
    >SpringCloud Alibaba</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/13/SpringCloud-Alibaba/" class="article-date">
  <time datetime="2020-07-13T09:37:39.000Z" itemprop="datePublished">2020-07-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
</blockquote>
<blockquote>
<p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p>
</blockquote>
<p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">GitHub: alibaba/spring-cloud-alibaba 官方中文文档</a></p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul>
<li>服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li>服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li>消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li>分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li>
<li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li>阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>
<li>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li>
<li>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>
<li>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li>Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li>
<li>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>
<li>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ul>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<h3 id="Nacos-配置中心"><a href="#Nacos-配置中心" class="headerlink" title="Nacos 配置中心"></a>Nacos 配置中心</h3><h4 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h4><ul>
<li>命名空间：用于进行配置隔离，不同命名空间下可以存着相同的Group或Data ID的配置。默认为public(保留空间)</li>
</ul>
<p>命名空间可以用于做环境隔离，注意：需要在bootstrap.properties里配置需要使用哪个命名空间下的配置</p>
<pre><code class="properties">spring.cloud.nacos.config.namespace=72d7c7bf-e241-49be-b0bf-73faace102b9</code></pre>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>也可以用于对每一个微服务之间互相隔离，每一个微服务创建一个命名空间，只加载自己命名空间下配置</p>
<ul>
<li>配置集：所有的配置的集合</li>
<li>配置集ID(Data ID)：类似于配置文件名</li>
<li>配置分组：在一个命名空间下相同的配置集ID可以在不同的分组里面创建多个，可用于批量切换配置即切换一下分组就完成了每个微服务的配置文件切换，默认所有的配置集都属于DEFAULT_GROUP</li>
</ul>
<p>项目中的使用：每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod</p>
<h4 id="同时加载多个配置集"><a href="#同时加载多个配置集" class="headerlink" title="同时加载多个配置集"></a>同时加载多个配置集</h4><ol>
<li>微服务任何配置信息，任何配置文件都可以放在配置中心中</li>
<li>只需要在bootstrap.properties说明加载配置中心中哪些配置文件即可</li>
<li>@Value，@ConfigurationProperties<ul>
<li>以前SpringBoot任何方法从配置文件中获取值，都能使用。</li>
<li>配置中心有的优先使用配置中心中的，</li>
</ul>
</li>
</ol>
<h3 id="SpringCloud-Gateway"><a href="#SpringCloud-Gateway" class="headerlink" title="SpringCloud Gateway"></a>SpringCloud Gateway</h3><ol>
<li>开启服务注册发现 (配置nacos的注册中心地址)</li>
<li>编写网关配置文件</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91/" rel="tag">踩坑</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-虚拟机相关"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/"
    >虚拟机相关</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-07-08T07:50:27.000Z" itemprop="datePublished">2020-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="使用Vagrant快速创建虚拟机"><a href="#使用Vagrant快速创建虚拟机" class="headerlink" title="使用Vagrant快速创建虚拟机"></a>使用Vagrant快速创建虚拟机</h2><ul>
<li><a href="https://www.vagrantup.com/" target="_blank" rel="noopener">官网</a></li>
</ul>
<pre><code class="cmd">vagrant init centos/7</code></pre>
<pre><code class="cmd">vagrant up
vagrant up --provider=vmware_desktop</code></pre>
<p>若提示找不到provider则需要安装对应的utility：</p>
<p>列如：这里的provider是VMware，<a href="https://www.vagrantup.com/docs/providers/vmware/installation" target="_blank" rel="noopener">参考步骤</a>:</p>
<ol>
<li>安装<a href="https://releases.hashicorp.com/vagrant-vmware-utility/1.0.9/vagrant-vmware-utility_1.0.9_x86_64.msi" target="_blank" rel="noopener">Download Vagrant VMWare Utility</a></li>
<li>运行<code>vagrant plugin install vagrant-vmware-desktop</code>或<code>vagrant plugin install vagrant-vmware-workstation</code></li>
</ol>
<p>如果还是搞不好的话就还是用Vagrant默认支持的VirtualBox吧<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">Download</a></p>
<p>如果出现如下下载慢的情况的话可以使用链接手动下载然后导入：</p>
<pre><code>Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
==&gt; default: Box &#39;centos/7&#39; could not be found. Attempting to find and install...
    default: Box Provider: virtualbox
    default: Box Version: &gt;= 0
==&gt; default: Loading metadata for box &#39;centos/7&#39;
    default: URL: https://vagrantcloud.com/centos/7
==&gt; default: Adding box &#39;centos/7&#39; (v2004.01) for provider: virtualbox
    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/2004.01/providers/virtualbox.box
Download redirected to host: cloud.centos.org
Progress: 0% (Rate: 0/s, Estimated time remaining: 94:22:44)</code></pre><p>先查看本地安装的box：</p>
<pre><code>vagrant box list</code></pre><p>再将得到的box文件手动添加进去：</p>
<pre><code>vagrant box add --name centos/7 D:\VirtualMachine_centerOS7\virtualbox.box</code></pre><p>添加完之后再run一下命令<code>vagrant up</code>：</p>
<p>当虚拟机安装完成之后会自动启动，启动完成会出现以下提示：</p>
<pre><code>==&gt; default: Importing base box &#39;centos/7&#39;...
==&gt; default: Matching MAC address for NAT networking...
==&gt; default: Setting the name of the VM: VirtualMachine_centerOS7_default_1594193913731_41252
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&gt; default: Forwarding ports...
    default: 22 (guest) =&gt; 2222 (host) (adapter 1)
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
    default:
    default: Vagrant insecure key detected. Vagrant will automatically replace
    default: this with a newly generated keypair for better security.
    default:
    default: Inserting generated public key within guest...
    default: Removing insecure key from the guest if it&#39;s present...
    default: Key inserted! Disconnecting and reconnecting using new SSH key...
==&gt; default: Machine booted and ready!
==&gt; default: Checking for guest additions in VM...
    default: No guest additions were detected on the base box for this VM! Guest
    default: additions are required for forwarded ports, shared folders, host only
    default: networking, and more. If SSH fails on this machine, please install
    default: the guest additions and repackage the box to continue.
    default:
    default: This is not an error message; everything may continue to work properly,
    default: in which case you may ignore this message.
==&gt; default: Rsyncing folder: /cygdrive/d/VirtualMachine_centerOS7/ =&gt; /vagrant</code></pre><p>使用ssh连接虚拟机：</p>
<pre><code>vagrant ssh</code></pre><p>查看当前用户：<code>whoami</code></p>
<p>退出ssh连接：<code>exit;</code></p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>可以直接在VirtualBox设置-&gt;网络-&gt;连接方式：网络地址转换(NAT)-&gt;端口转发 里面设置</p>
<p>也可通过修改<code>Vagrantfile</code>配置文件来改</p>
<h3 id="通过修改Vagrantfile配置文件来配置虚拟机IP"><a href="#通过修改Vagrantfile配置文件来配置虚拟机IP" class="headerlink" title="通过修改Vagrantfile配置文件来配置虚拟机IP"></a>通过修改<code>Vagrantfile</code>配置文件来配置虚拟机IP</h3><pre><code>ipconfig

以太网适配器 VirtualBox Host-Only Network #2:

   连接特定的 DNS 后缀 . . . . . . . :
   本地链接 IPv6 地址. . . . . . . . : fe80::8c1a:1f35:e70:a9%25
   IPv4 地址 . . . . . . . . . . . . : 192.168.33.1
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . :</code></pre><pre><code>config.vm.network &quot;private_network&quot;, ip:&quot;192.168.33.10&quot;
vagrant reload
vagrant ssh
ip addr

3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 100
0
    link/ether 08:00:27:f2:b4:fb brd ff:ff:ff:ff:ff:ff
    inet 192.168.33.10/24 brd 192.168.33.255 scope global noprefixroute eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fef2:b4fb/64 scope link
       valid_lft forever preferred_lft forever</code></pre><p>可以看到IP地址已经是192.168.33.10了</p>
<p>ping 192.168.33.10<br>ping 192.168.2.148</p>
<p>测试一下都可以ping通即可</p>
<h2 id="配置Docker"><a href="#配置Docker" class="headerlink" title="配置Docker"></a>配置Docker</h2><h3 id="安装docker-engine"><a href="#安装docker-engine" class="headerlink" title="安装docker engine"></a>安装docker engine</h3><p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">Install Docker Engine on CentOS</a></p>
<p>按照官方文档配即可，不再赘述</p>
<h3 id="设置Docker开机自启动"><a href="#设置Docker开机自启动" class="headerlink" title="设置Docker开机自启动"></a>设置Docker开机自启动</h3><pre><code class="shell">[vagrant@localhost ~]$ sudo systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</code></pre>
<h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p>登录阿里云，然后访问<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">容器镜像服务-&gt;镜像中心-&gt;镜像加速器</a></p>
<p>eg: <a href="https://sb0h74rp.mirror.aliyuncs.com" target="_blank" rel="noopener">https://sb0h74rp.mirror.aliyuncs.com</a></p>
<pre><code>sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
{
  &quot;registry-mirrors&quot;: [&quot;https://sb0h74rp.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker</code></pre><h3 id="Dock安装镜像-mysql"><a href="#Dock安装镜像-mysql" class="headerlink" title="Dock安装镜像(mysql)"></a>Dock安装镜像(mysql)</h3><pre><code>sudo docker pull mysql:5.7

sudo docker run -p 3306:3306 --name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/var/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7

sudo docker ps</code></pre><p>-p表示端口映射</p>
<p>-v挂载docker容器内部目录到外部目录</p>
<p>-d表示后台运行</p>
<p>进入mysql容器内部</p>
<pre><code>sudo docker exec -it mysql /bin/bash</code></pre><p>配置一下utf8 encoding</p>
<pre><code>vi /mydata/mysql/conf/my.cnf

[client]
default-character-set=utf8

[mysql]
default-character-set=utf8

[mysqld]
init_connect=&#39;SET collation_connection = utf8_unicode_ci&#39;
init_connect=&#39;SET NAMES utf8&#39;
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve</code></pre><h3 id="Dock安装镜像-redis"><a href="#Dock安装镜像-redis" class="headerlink" title="Dock安装镜像(redis)"></a>Dock安装镜像(redis)</h3><pre><code>docker pull redis

mkdir -p /mydata/redis/conf
touch /mydata/redis/conf/redis.conf

docker run -p 6379:6379 --name redis \
-v /mydata/redis/data:/data \
-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf

docker start c24743e3c322
docker rm -f c24743e3c322</code></pre><p>-d后面的是启动额外命令，表示以该配置文件启动</p>
<h4 id="快速调用redis-cli工具来运行redis命令"><a href="#快速调用redis-cli工具来运行redis命令" class="headerlink" title="快速调用redis cli工具来运行redis命令"></a>快速调用redis cli工具来运行redis命令</h4><pre><code>docker exec -it redis redis-cli
127.0.0.1:6379&gt; set a b
OK
127.0.0.1:6379&gt; get a
&quot;b&quot;</code></pre><h3 id="docker开机自动启动容器"><a href="#docker开机自动启动容器" class="headerlink" title="docker开机自动启动容器"></a>docker开机自动启动容器</h3><pre><code>sudo docker update redis --restart=always
sudo docker update mysql --restart=always</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-我是如何使用frp内网穿透来访问局域网web服务的"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/08/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%B1%80%E5%9F%9F%E7%BD%91web%E6%9C%8D%E5%8A%A1%E7%9A%84/"
    >我是如何使用frp内网穿透来访问局域网web服务的</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/08/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%B1%80%E5%9F%9F%E7%BD%91web%E6%9C%8D%E5%8A%A1%E7%9A%84/" class="article-date">
  <time datetime="2020-06-08T02:52:03.000Z" itemprop="datePublished">2020-06-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>想从公网访问家里PC上的web服务，但是运营商又不给公网IP？VPS服务器+frp+web服务器</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>局域网有一台MAC已经配置了静态IP和DMZ</p>
<p>IP: 192.168.2.104</p>
<p>已经启动了一台web服务器，这里使用的是Spring Boot，端口为8090</p>
<p>提供一个测试用的接口：<code>http://localhost:8090/notebook/version</code></p>
<h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.</p>
</blockquote>
<p>Frp是go写的免费开源的内网穿透软件，可以在windows/linux/mac下运行，:Github链接。其支持 TCP、UDP、HTTP、HTTPS等协议的网络连接，尝试性地支持了点对点穿透。部署时，需要在本地（内网服务器）和公网服务器同时部署，内网是frp客户端、公网是frp服务端，客户端之间通过ssh连接。当用户访问公网frp服务器时，服务器通过ssh连接到内网服务器上的端口，将本地客户端上对应端口的内容转发给用户，即反向代理。</p>
<h3 id="开始配置前注意"><a href="#开始配置前注意" class="headerlink" title="开始配置前注意"></a>开始配置前注意</h3><p>frp需要启动服务端与客户端，服务端运行在你位于公网的VPS上，客户端运行在你家的局域网下</p>
<ul>
<li>服务端对应的配置文件为: <code>frps.ini</code></li>
<li>客户端对应的配置文件为: <code>frpc.ini</code></li>
</ul>
<h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>查看系统信息</p>
<pre><code># uname -a
Linux VM_0_3_centos 3.10.0-1062.9.1.el7.x86_64 #1 SMP Fri Dec 6 15:49:49 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>下载frp对应的包</p>
<pre><code># wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz
2020-06-08 09:47:05 (3.53 MB/s) - ‘frp_0.33.0_linux_amd64.tar.gz’ saved [9028588/9028588]</code></pre><p>解压缩</p>
<pre><code>sudo tar -xzvf frp_0.33.0_linux_amd64.tar.gz
cd frp_0.33.0_linux_amd64</code></pre><p>修改配置文件<code>frps.ini</code></p>
<pre><code># cat frps.ini
[common]
bind_port = 7000

# sudo vim frps.ini
[common]
bind_port = 7000
token = password
vhost_http_port = 8090</code></pre><p>启动服务端</p>
<pre><code># ./frps -c ./frps.ini
2020/06/08 10:16:18 [I] [service.go:178] frps tcp listen on 0.0.0.0:7000
2020/06/08 10:16:18 [I] [service.go:220] http service listen on 0.0.0.0:8090
2020/06/08 10:16:18 [I] [root.go:209] start frps success</code></pre><p>启动frp服务器并后台运行,启动完成后可通过lsof -i :7000查看端口占用情况</p>
<pre><code>nohup ./frps -c ./frps.ini &amp;</code></pre><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>查看系统信息</p>
<pre><code># uname -a
Darwin sicmatr1xMacBook-Pro.local 19.4.0 Darwin Kernel Version 19.4.0: Wed Mar  4 22:28:40 PST 2020; root:xnu-6153.101.6~15/RELEASE_X86_64 x86_64</code></pre><p>下载frp对应的包: <a href="https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_darwin_amd64.tar.gz" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_darwin_amd64.tar.gz</a></p>
<p>解压缩并修改配置文件<code>frpc.ini</code></p>
<pre><code>[common]
server_addr = 45.**.**.**9
server_port = 7000
token = password

[web]
#配置类型为tcp协议
type = http
#内网需要监听的端口,即本地运行的服务所使用的端口
local_port = 8090
#公网服务器的IP或者已解析的域名
custom_domains=45.**.**.**9</code></pre><p>启动客户端</p>
<pre><code>cd /Users/sicmatr1x/Develop/frp_0.33.0_darwin_amd64
./frpc -c ./frpc.ini</code></pre><p>连接成功的话服务端会提示</p>
<pre><code>2020/06/08 10:16:20 [I] [service.go:432] [97bed4f24fba649a] client login info: ip [119.**.**.**:26698] version [0.33.0] hostname [] os [darwin] arch [amd64]</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/frp/" rel="tag">frp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" rel="tag">内网穿透</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91/" rel="tag">踩坑</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Daily-Knowledge-Point"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/20/Daily-Knowledge-Point/"
    >Daily Knowledge Point</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/05/20/Daily-Knowledge-Point/" class="article-date">
  <time datetime="2020-05-20T00:45:37.000Z" itemprop="datePublished">2020-05-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="2020-05-19"><a href="#2020-05-19" class="headerlink" title="2020-05-19"></a>2020-05-19</h3><h4 id="Q-SpringBoot-无法自动织入-mongoTemplate-对象"><a href="#Q-SpringBoot-无法自动织入-mongoTemplate-对象" class="headerlink" title="Q: SpringBoot 无法自动织入 mongoTemplate 对象"></a>Q: SpringBoot 无法自动织入 <code>mongoTemplate</code> 对象</h4><p>A: 原因为引入的MongoDB版本问题。</p>
<p>尝试以下两种写法均会出现此问题，固排除写法的原因</p>
<pre><code class="java">@Repository
public class ArticleDaoImpl implements ArticleDao {

    @Autowired
    private MongoTemplate mongoTemplate;

    @Override
    public void saveArticle(Article article)  {
        mongoTemplate.save(article);
    }
}</code></pre>
<pre><code class="java">@Component
public class ArticleDaoImpl implements ArticleDao {

    @Resource
    private MongoTemplate mongoTemplate;

    @Override
    public void saveArticle(Article article)  {
        mongoTemplate.save(article);
    }
}</code></pre>
<p>从GitHub上找同类型demo项目<a href="https://github.com/souyunku/SpringBootExamples" target="_blank" rel="noopener">souyunku/SpringBootExamples</a>，使用其springboot版本和MongoDB版本成功排除此问题</p>
<p>原pom.xml文件：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.sicmatr1x&lt;/groupId&gt;
    &lt;artifactId&gt;NoteBookServer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;NoteBookServer&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
            &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
            &lt;version&gt;1.11.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;4.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
            &lt;version&gt;1.9.13&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>修改后pom.xml文件：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.sicmatr1x&lt;/groupId&gt;
    &lt;artifactId&gt;NoteBookServer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;NoteBookServer&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;

        &lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
            &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
            &lt;version&gt;1.11.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;4.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
            &lt;version&gt;1.9.13&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="2020-05-23"><a href="#2020-05-23" class="headerlink" title="2020-05-23"></a>2020-05-23</h3><h4 id="Q-Cannot-resolve-symbol-‘BASE64Encoder’"><a href="#Q-Cannot-resolve-symbol-‘BASE64Encoder’" class="headerlink" title="Q: Cannot resolve symbol ‘BASE64Encoder’"></a>Q: Cannot resolve symbol ‘BASE64Encoder’</h4><pre><code class="java">import sun.misc.BASE64Encoder;
//...

            // 对字节数组Base64编码
            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(dataByte);
//...</code></pre>
<pre><code>Error:(74, 13) java: 找不到符号
  符号:   类 BASE64Encoder
  位置: 类 com.sicmatr1x.spider.translator.Img2Base64Translator</code></pre><p>A: sun.misc.BASE64Encoder 不建议使用java.sun自带包中的内容</p>
<p>在项目中，设计到64位编码的。有时开发会用到JDK中自带的BASE64工具。但sun公司是建议不这样做的。尤其是更新了JDK版本，项目甚至还存在保存的信息。<br>可引用 import org.apache.commons.codec.binary.Base64;进行替换</p>
<pre><code class="java">import org.apache.commons.codec.binary.Base64;
//...
            // 对字节数组Base64编码
            Base64 encoder = new Base64();
            return encoder.encodeToString(dataByte);
//...</code></pre>
<h4 id="Q-SpringBoot抛出WARNING-An-illegal-reflective-access-operation-has-occurred"><a href="#Q-SpringBoot抛出WARNING-An-illegal-reflective-access-operation-has-occurred" class="headerlink" title="Q: SpringBoot抛出WARNING: An illegal reflective access operation has occurred"></a>Q: SpringBoot抛出<code>WARNING: An illegal reflective access operation has occurred</code></h4><pre><code>WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils$1 (file:/C:/Users/Sicmatr1x/.m2/repository/org/springframework/spring-core/4.3.14.RELEASE/spring-core-4.3.14.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)
WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release</code></pre><p>A: 该警告是因为jdk版本太高（我用的是10.0，据说9.0的也会这样），具体的原理还没有研究</p>
<p>解决方案是把项目jdk降低到1.8及以下，建议1.8</p>
<h3 id="2020-05-25"><a href="#2020-05-25" class="headerlink" title="2020-05-25"></a>2020-05-25</h3><h4 id="Q-SpringBoot抛出Overriding-bean-definition-for-bean-39-person-39-with-a-different-definition"><a href="#Q-SpringBoot抛出Overriding-bean-definition-for-bean-39-person-39-with-a-different-definition" class="headerlink" title="Q: SpringBoot抛出Overriding bean definition for bean &#39;person&#39; with a different definition"></a>Q: SpringBoot抛出<code>Overriding bean definition for bean &#39;person&#39; with a different definition</code></h4><pre><code>May 25, 2020 5:20:16 PM org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition
INFO: Overriding bean definition for bean &#39;person&#39; with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/sicmatr1x/config/MainConfig2.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in com.sicmatr1x.config.MainConfig]</code></pre><p>意思是有一个叫<code>person</code>的bean被重复注入到IOT容器了</p>
<p>A: 导致的原因是：</p>
<p>启动的时候用的是<code>MainConfig.class</code>这个配置类</p>
<pre><code class="java">AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig.class);</code></pre>
<p>我在该类中注册了<code>person</code>，然后启用了包扫描</p>
<pre><code class="java">@Configuration
@ComponentScan(value = &quot;com.sicmatr1x&quot;, excludeFilters = {
        @Filter(type = FilterType.CUSTOM, classes = {MyTypeFilter.class})
})
public class MainConfig {
    @Bean(&quot;person&quot;)
    public Person person(){
        return new Person(&quot;Abby&quot;, 20);
    }
}</code></pre>
<p>然后扫描到了另外一个配置类，我在另外的这个配置类里面又注册了<code>person</code></p>
<pre><code class="java">package com.sicmatr1x.config;


import com.sicmatr1x.bean.Person;
import org.springframework.context.annotation.*;

@Configuration
public class MainConfig2 {
//    @Scope(&quot;prototype&quot;)
    @Lazy
    @Bean(&quot;person&quot;)
    public Person person(){
        return new Person(&quot;Bob&quot;, 30);
    }
}</code></pre>
<h3 id="2020-05-26"><a href="#2020-05-26" class="headerlink" title="2020-05-26"></a>2020-05-26</h3><h4 id="Q-Override-is-not-allowed-when-implementing-interface-method"><a href="#Q-Override-is-not-allowed-when-implementing-interface-method" class="headerlink" title="Q: @Override is not allowed when implementing interface method"></a>Q: <code>@Override is not allowed when implementing interface method</code></h4><img src="./Override is not allowed when implementing interface method IntelliJ IDEA.png">

<p>A:</p>
<p>@Override从jdk1.5开始出现的，是用来标注方法重写的。通常方法重写发生在继承父类，重写父类方法，或者实现接口，实现接口方法。@Override能够保证你正确重写方法，当你重写方法出错时，比如方法名误写，或者漏掉参数，编译器会提示编译错误。<br>  出现以上问题，则跟编译器版本问题有关。编译器1.5只支持@Override注释重写父类方法，不支持实现接口方法。而我的IDE默认使用jdk1.5的编译器。我这个用的是jdk1.7的，我们将language level设置高于jdk1.5版本即可</p>
<p>File —&gt; Project Structure —&gt; [ 项目名称 ] —&gt; Language level 修改成 7 - Diamonds,ARM,multi-catch etc.</p>
<p>或者直接根据idea的提升修改配置即可</p>
<h3 id="2020-05-27"><a href="#2020-05-27" class="headerlink" title="2020-05-27"></a>2020-05-27</h3><h4 id="Q-git修改已经提交的用户名"><a href="#Q-git修改已经提交的用户名" class="headerlink" title="Q: git修改已经提交的用户名"></a>Q: git修改已经提交的用户名</h4><p>A: 如果是已经push到remote仓库的则不能做到完全消除提交记录，只能追加修改提交用户名的commit，之前有几个commit需要修改的就追加几个。<br>如果只是本地commit可以undo commit再重新commit</p>
<ol>
<li>（n）代表提交次数<code>git rebase -i HEAD~n</code></li>
<li>然后按<code>i</code>编辑，把<code>pick</code> 改成 <code>edit</code>，按’Esc’退出编辑，按<code>:wq</code>保存退出</li>
<li><code>git commit --amend --author=&quot;作者 &lt;邮箱@xxxx.com&gt;&quot; --no-edit</code></li>
<li><code>git rebase --continue</code></li>
<li><code>git push --force</code></li>
</ol>
<p>这种情况只能预防，建议在配置了全局用户名的情况下再为每个project单独配置用户名</p>
<p>git全局配置路径：</p>
<ul>
<li>Windows: <code>C:\Users\GUOJO\.gitconfig</code></li>
<li>Mac: ``</li>
</ul>
<p>git项目配置路径：<code>.git\config</code></p>
<p>配置格式如下：</p>
<pre><code>[user]
    name = Sicmatr1x
    email = sicmatr1x@outlook.com</code></pre><p>有一种方法可以强制重写错误的commit，使用过滤器(git filter-branch)</p>
<p>警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作</p>
<pre><code class="bash">git filter-branch -f --commit-filter &#39;
        if [ &quot;$GIT_COMMITTER_NAME&quot; = &quot;Sic&quot; ];
        then
                GIT_COMMITTER_NAME=&quot;Joe Guo&quot;;
                GIT_AUTHOR_NAME=&quot;$GIT_COMMITTER_NAME&quot;;
                git commit-tree &quot;$@&quot;;
        else
                git commit-tree &quot;$@&quot;;
        fi&#39; HEAD</code></pre>
<p>修改完之后还需要force push</p>
<pre><code class="bash">git push --force --tags origin &#39;refs/heads/*&#39;</code></pre>
<p>参考：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000008828569" target="_blank" rel="noopener">Git 修改 commit 的作者信息</a></li>
<li><a href="https://help.github.com/en/github/using-git/changing-author-info" target="_blank" rel="noopener">Changing author info</a></li>
<li><a href="https://segmentfault.com/q/1010000022758855" target="_blank" rel="noopener">git如何修改已经提交的用户名?</a></li>
</ul>
<h4 id="IDEA查找接口实现类"><a href="#IDEA查找接口实现类" class="headerlink" title="IDEA查找接口实现类"></a>IDEA查找接口实现类</h4><p>双击选中接口名 + ctrl + alt + B</p>
<h3 id="2020-05-29"><a href="#2020-05-29" class="headerlink" title="2020-05-29"></a>2020-05-29</h3><h4 id="Oracle什么时候需要Commit"><a href="#Oracle什么时候需要Commit" class="headerlink" title="Oracle什么时候需要Commit"></a>Oracle什么时候需要Commit</h4><p>SQL语言分为五大类：</p>
<ol>
<li>DDL(数据定义语言) - Create、Alter、Drop 这些语句自动提交，无需用Commit提交。</li>
<li>DQL（数据查询语言）- Select查询语句不存在提交问题。</li>
<li>DML(数据操纵语言) - Insert、Update、Delete 这些语句需要Commit才能提交。</li>
<li>DTL(事务控制语言) - Commit、Rollback 事务提交与回滚语句。</li>
<li>DCL(数据控制语言) - Grant、Revoke 授予权限与回收权限语句。</li>
</ol>
<p>执行完DML语句，若没有commit再执行DDL语句，也会自动commit未被commit的数据。</p>
<p>DDL语句在执行前后会自动执行commit，所以你不能使用rollback去回滚它。但是在该语句执行过程中，如果由于某种原因而失败，系统会自动将其回滚，这就是语句级回滚的意思，它属于oracle的隐式回滚，我们不能进行控制。教材上说的DDL语句不能进行回滚，只是不能输入ROLLBACK去回滚DDL语句的结果而已。</p>
<h3 id="2020-06-02"><a href="#2020-06-02" class="headerlink" title="2020-06-02"></a>2020-06-02</h3><h4 id="Q-Springboot读取配置文件并初始化到bean失败，无法识别-person-nickname-作为运行时环境"><a href="#Q-Springboot读取配置文件并初始化到bean失败，无法识别-person-nickname-作为运行时环境" class="headerlink" title="Q: Springboot读取配置文件并初始化到bean失败，无法识别${person.nickname}作为运行时环境"></a>Q: Springboot读取配置文件并初始化到bean失败，无法识别<code>${person.nickname}</code>作为运行时环境</h4><pre><code class="java">    @Value(&quot;${person.nickname}&quot;)
    private String nickname;</code></pre>
<p>A: 查了一下发现是@PropertySource注解配错位置了，本来应该配在Configuration类上的结果配到bean上面去了</p>
<pre><code class="java">@PropertySource(value = {&quot;classpath:/person.properties&quot;}, encoding = &quot;UTF-8&quot;)
@Configuration
public class MainConfigOfPropertyValues {
    @Bean
    public Person person(){
        return new Person();
    }
}</code></pre>
<h3 id="2020-06-03"><a href="#2020-06-03" class="headerlink" title="2020-06-03"></a>2020-06-03</h3><h4 id="Q-如何在git上删除误提交的大文件"><a href="#Q-如何在git上删除误提交的大文件" class="headerlink" title="Q: 如何在git上删除误提交的大文件"></a>Q: 如何在git上删除误提交的大文件</h4><p>A: </p>
<p>首先使用下面查询git中前5名最大的文件:</p>
<pre><code>git verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -g | tail -5</code></pre><p>记下上面的文件id使用下面命令查看对应文件的路径</p>
<pre><code>git rev-list --objects --all | grep ed9253b5bbaaa6b0eb04db1dd9840121657b68f3</code></pre><p>从当前激活的分支最近30次提交中删除指定文件</p>
<pre><code>git filter-branch --force --prune-empty  --tree-filter &#39;git rm -f --cached --ignore-unmatch 文件路径&#39; HEAD~30..HEAD</code></pre><p>如果出现不能创建新的备份的话，就加上强制覆盖覆盖参数 –force</p>
<p>如果操作完成后没出现没有改变的情况,如下</p>
<p>WARNING: Ref ‘refs/heads/master’ is unchanged</p>
<p>可以尝试把上面命令中的–tree-filter换成 –index-filter再次运行命令</p>
<p>操作完成后,查看日志就会发现已经没有提交这个文件的日志记录啦,但是还有一个问题 .git 这个文件夹还是原来的大小，想减小它的大小就要对这个仓库进行分析重新打包,也就是清理垃圾</p>
<pre><code>git rm -rf --ignore-unmatch .git/refs/original/
git reflog expire --expire=now --all
git fsck --full --unreachable
git repack -A -d
git gc --aggressive --prune=now</code></pre><p>最后强制推送到远端</p>
<pre><code>git push origin master --force</code></pre><p>参考: </p>
<ul>
<li><a href="https://www.zhaokeli.com/article/8332.html" target="_blank" rel="noopener">git filter-branch 命令修改删除提示记录,删除误提交的大文件.减小.git的大小</a></li>
</ul>
<h3 id="2020-06-17"><a href="#2020-06-17" class="headerlink" title="2020-06-17"></a>2020-06-17</h3><h4 id="Q-Postman访问自签名证书服务器"><a href="#Q-Postman访问自签名证书服务器" class="headerlink" title="Q: Postman访问自签名证书服务器"></a>Q: Postman访问自签名证书服务器</h4><p>访问不可信任的证书签发机构签发的证书的服务器时，Chrome浏览器会提示：您与网站之间建立的连接不安全</p>
<p>你可以在高级选项里面选择继续访问该网站</p>
<p>但是使用Postman call就会提示：Error: Protocol “https:” not supported. Expected “http:”</p>
<p>A: Postman Settings -&gt; REQUEST -&gt; SSL certificate verification 关闭该选项</p>
<h3 id="2020-06-26"><a href="#2020-06-26" class="headerlink" title="2020-06-26"></a>2020-06-26</h3><h4 id="Q-org-bson-BsonSerializationException-Document-size-of-44088405-is-larger-than-maximum-of-16777216"><a href="#Q-org-bson-BsonSerializationException-Document-size-of-44088405-is-larger-than-maximum-of-16777216" class="headerlink" title="Q: org.bson.BsonSerializationException: Document size of 44088405 is larger than maximum of 16777216."></a>Q: org.bson.BsonSerializationException: Document size of 44088405 is larger than maximum of 16777216.</h4><p>mongodb中的大小限制, 即单个文档大小不能超过16M. 基于性能的考虑，这个限制无法取消。</p>
<p><a href="https://stackoverflow.com/questions/4667597/understanding-mongodb-bson-document-size-limit" target="_blank" rel="noopener">Understanding MongoDB BSON Document size limit</a></p>
<h3 id="2020-07-10"><a href="#2020-07-10" class="headerlink" title="2020-07-10"></a>2020-07-10</h3><h4 id="Q-npm-install-时-node-sass安装出现问题"><a href="#Q-npm-install-时-node-sass安装出现问题" class="headerlink" title="Q: npm install 时 node-sass安装出现问题"></a>Q: npm install 时 node-sass安装出现问题</h4><pre><code>“D:\Repositories\bilibili\renren-fast-vue\node_modules\node-sass\build\binding.sln”(默认目标) (1) -&gt;
“D:\Repositories\bilibili\renren-fast-vue\node_modules\node-sass\build\binding.vcxproj.metaproj”(默认目标) (2) -&gt;
“D:\Repositories\bilibili\renren-fast-vue\node_modules\node-sass\build\binding.vcxproj”(默认目标) (4) -&gt;
(ClCompile 目标) -&gt; 
  d:\repositories\bilibili\renren-fast-vue\node_modules\node-sass\src\create_string.cpp(17): error C2664: “v8::String::Utf8Value::Utf8Value(const v8::String::Utf8Value &amp;)”: 无法将参数 1 从“v8::Local&lt;v8::Value&gt;”转换为“const v8::Strin
g::Utf8Value 
&amp;” [D:\Repositories\bilibili\renren-fast-vue\node_modules\node-sass\build\binding.vcxproj]
gyp ERR! cwd D:\Repositories\bilibili\renren-fast-vue\node_modules\node-sass
gyp ERR! node -v v12.15.0
gyp ERR! node-gyp -v v3.8.0
gyp ERR! not ok</code></pre><p>A: 老版本的SASS调用到的<code>v8::String::Utf8Value string(value);</code>函数在node12版本的V8引擎里面出现了修改</p>
<p>解决方案：</p>
<ol>
<li>降级node版本</li>
<li>或者升级SASS版本</li>
</ol>
<ul>
<li><a href="https://github.com/sass/node-sass/issues/2632" target="_blank" rel="noopener">support for node.js 12.x #2632</a></li>
</ul>
<h3 id="2020-07-13"><a href="#2020-07-13" class="headerlink" title="2020-07-13"></a>2020-07-13</h3><h4 id="maven-install-source-1-5-中不支持-diamond-运算符"><a href="#maven-install-source-1-5-中不支持-diamond-运算符" class="headerlink" title="maven install -source 1.5 中不支持 diamond 运算符"></a>maven install -source 1.5 中不支持 diamond 运算符</h4><p>A: idea File-&gt;Project Struct-&gt;Modules-&gt;Sources-&gt;Language level这里改成&gt;=8的级别，如果多次反复maven install之后这个选项还是会弹回6及以下的级别的话就直接pom文件里面强制设置成package时为1.8的</p>
<pre><code class="xml">    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;</code></pre>
<h4 id="Error-8-14-java-程序包lombok不存在"><a href="#Error-8-14-java-程序包lombok不存在" class="headerlink" title="Error:(8,14) java: 程序包lombok不存在"></a>Error:(8,14) java: 程序包lombok不存在</h4><p>背景：common的module里面导入了lombok包，然后product的module里依赖了common的module，根据maven的依赖传递性，product应该引入了lombok包这个依赖</p>
<p>common module的pom.xml</p>
<pre><code class="xml">        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;</code></pre>
<p>product module的pom.xml</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.sicmatr1x.gulimall&lt;/groupId&gt;
            &lt;artifactId&gt;gulimall-common&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
<p>A: 在涉及到maven的依赖传递性时，若存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这需要看间接依赖的jar包引入时的依赖范围——只有依赖范围为compile时可以访问(若不写scope则默认值为compile)</p>
<p>所以这里修改pom.xml文件删去<code>&lt;scope&gt;provided&lt;/scope&gt;</code>或者改为<code>&lt;scope&gt;compile&lt;/scope&gt;</code>即可</p>
<pre><code class="xml">        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
<p>操作完之后记得重新对common module做maven install，重新生成jar文件</p>
<h4 id="Caused-by-java-lang-RuntimeException-Driver-com-mysql-jdbc-Driver-claims-to-not-accept-jdbcUrl-jdbc-mysql-192-168-33-10-3306-gulimall-pms"><a href="#Caused-by-java-lang-RuntimeException-Driver-com-mysql-jdbc-Driver-claims-to-not-accept-jdbcUrl-jdbc-mysql-192-168-33-10-3306-gulimall-pms" class="headerlink" title="Caused by: java.lang.RuntimeException: Driver com.mysql.jdbc.Driver claims to not accept jdbcUrl, jdbc:mysql://192.168.33.10:3306/gulimall_pms"></a>Caused by: java.lang.RuntimeException: Driver com.mysql.jdbc.Driver claims to not accept jdbcUrl, jdbc:mysql://192.168.33.10:3306/gulimall_pms</h4><p>A:  JDBC驱动程序的5.2版本与UTC时区配合使用，必须在连接字符串中明确指定serverTimezone。</p>
<pre><code class="yml">spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.33.10:3306/gulimall_pms
    driver-class-name: com.mysql.jdbc.Driver</code></pre>
<p>改成</p>
<pre><code class="yml">spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.33.10:3306/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.jdbc.Driver</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java复习笔记：注解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/13/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%B3%A8%E8%A7%A3/"
    >Java复习笔记：注解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/05/13/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2020-05-13T06:49:28.000Z" itemprop="datePublished">2020-05-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Java-内置注解"><a href="#Java-内置注解" class="headerlink" title="Java 内置注解"></a>Java 内置注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a><code>@Override</code></h3><p>定义在：<code>java.lang.Override</code> 中</p>
<p>只能用于修辞方法，表示一个方法声明打算重写超类中的另一个方法。</p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a><code>@Deprecated</code></h3><p>定义在：<code>java.lang.Deprecated</code> 中</p>
<p>可以用于修辞方法、属性、类，表示不推荐程序员使用的元素，通常意味着它存在危险或有更好的选择</p>
<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a><code>@SuppressWarnings</code></h3><p>定义在：<code>java.lang.SuppressWarnings</code> 中</p>
<p>用于抑制编译时的警告信息</p>
<ul>
<li><code>@SuppressWarnings(&quot;all&quot;)</code>: 抑制所有类型的警告</li>
<li><code>@SuppressWarnings(value={&quot;unchecked&quot;, &quot;rawtypes&quot;})</code>: 抑制所多种类型的警告</li>
<li><code>@SuppressWarnings(&quot;unchecked&quot;)</code>: 抑制unchecked类型的警告</li>
</ul>
<p>参数：</p>
<ul>
<li><code>all</code>: to suppress all warnings</li>
<li><code>boxing</code> : to suppress warnings relative to boxing/unboxing operations</li>
<li><code>cast</code>: to suppress warnings relative to cast operations</li>
<li><code>dep-ann</code>: to suppress warnings relative to deprecated annotation</li>
<li><code>deprecation</code>: to suppress warnings relative to deprecation</li>
<li><code>fallthrough</code>:  to suppress warnings relative to missing breaks in switch statements</li>
<li><code>finally</code> : to suppress warnings relative to finally block that don’t return</li>
<li><code>hiding</code>: to suppress warnings relative to locals that hide variable</li>
<li><code>incomplete-switch</code>:  to suppress warnings relative to missing entries in a switch statement (enum case)</li>
<li><code>nls</code>:  to suppress warnings relative to non-nls string literals</li>
<li><code>null</code>: to suppress warnings relative to null analysis</li>
<li><code>rawtypes</code>: to suppress warnings relative to un-specific types when using generics on class params</li>
<li><code>restriction</code>: to suppress warnings relative to usage of discouraged or forbidden references</li>
<li><code>serial</code>: to suppress warnings relative to missing serialVersionUID field for a serializable class</li>
<li><code>static-access</code>: o suppress warnings relative to incorrect static access</li>
<li><code>synthetic-access</code> :  to suppress warnings relative to unoptimized access from inner classes</li>
<li><code>unchecked</code>:  to suppress warnings relative to unchecked operations</li>
<li><code>unqualified-field-access</code>: to suppress warnings relative to field access unqualified</li>
<li><code>unused</code>: to suppress warnings relative to unused code</li>
</ul>
<h2 id="元注解-meta-annotation"><a href="#元注解-meta-annotation" class="headerlink" title="元注解(meta-annotation)"></a>元注解(meta-annotation)</h2><p>用于注解其它注解的注解</p>
<h3 id="1-Target"><a href="#1-Target" class="headerlink" title="1. @Target"></a>1. <code>@Target</code></h3><p>用于描述注解的使用范围</p>
<p>example:</p>
<pre><code class="java">@Target(value = ElementType.TYPE)</code></pre>
<p>可用<code>{}</code>来给value传入数组</p>
<pre><code class="java">@Target(value = {ElementType.TYPE, ElementType.METHOD})</code></pre>
<p>value参数值为枚举类型，定义如下：</p>
<pre><code class="java">public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Formal parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE,

    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}</code></pre>
<h3 id="2-Retention"><a href="#2-Retention" class="headerlink" title="2. @Retention"></a>2. <code>@Retention</code></h3><p>表示需要什么级别保存该注解信息，用于描述注解的生命周期</p>
<p>取值：<code>SOURCE</code> &lt; <code>CLASS</code> &lt; <code>RUNTIME</code></p>
<ul>
<li><code>SOURCE</code>: 保留到源码</li>
<li><code>CLASS</code>: 保留到字节码</li>
<li><code>RUNTIME</code>: 保留到虚拟机</li>
</ul>
<pre><code class="java">public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}</code></pre>
<h3 id="3-Document"><a href="#3-Document" class="headerlink" title="3. @Document"></a>3. <code>@Document</code></h3><p>表示该注解将被包含在javadoc中</p>
<h3 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4. @Inherited"></a>4. <code>@Inherited</code></h3><p>表示子类可以继承父类中的该注解</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射(Reflection)"></a>反射(Reflection)</h2><p>反射(Reflection)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类型的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Spring注解驱动开发"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/12/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"
    >Spring注解驱动开发</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/05/12/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" class="article-date">
  <time datetime="2020-05-12T08:02:27.000Z" itemprop="datePublished">2020-05-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="Configuration-amp-Bean-给容器中注册组件"><a href="#Configuration-amp-Bean-给容器中注册组件" class="headerlink" title="@Configuration &amp; @Bean 给容器中注册组件"></a><code>@Configuration</code> &amp; <code>@Bean</code> 给容器中注册组件</h4><p>配置类相当于以前的配置文件<code>beans.xml</code></p>
<p>配置类：</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;
import org.springframework.stereotype.Controller;

@Configuration // 告诉Spring这是一个配置类
@ComponentScan(value = &quot;com.sicmatr1x&quot;, excludeFilters = {
        @Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
}) // 手动配置包扫描，扫描com.sicmatr1x包下的内容，exclude可以排除不想注入的类，这里按照注解排除了使用到Controller注解的类
// @ComponentScan value:指定要扫描的包
// excludeFilters = Filter[] 指定扫描的时候按照什么规则排除哪些组件
// includeFilters = Filter[] 指定扫描的时候按照什么规则包含哪些组件
// useDefaultFilters = false 可以关闭默认的filter
public class MainConfig {
    @Bean(&quot;person&quot;) // 给容器中注册一个bean，类型为返回值的类型，id默认为方法名，也可自定义
    public Person person(){
        return new Person(&quot;Abby&quot;, 20);
    }
}
</code></pre>
<p>测试配置类：</p>
<pre><code class="java">package com.sicmatr1x.test;

import com.sicmatr1x.bean.Person;
import com.sicmatr1x.config.MainConfig;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MainTest {
    public static void main(String[] args) {
        // 传统xml方式
//        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
//        Person bean = (Person) applicationContext.getBean(&quot;person&quot;);
//        System.out.println(bean);

        // 以前传配置文件，现在传配置类
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        Person bean = applicationContext.getBean(Person.class);
        System.out.println(bean);
    }
}
</code></pre>
<h4 id="ComponentScan-自动扫描组件-amp-指定扫描规则"><a href="#ComponentScan-自动扫描组件-amp-指定扫描规则" class="headerlink" title="@ComponentScan 自动扫描组件&amp;指定扫描规则"></a><code>@ComponentScan</code> 自动扫描组件&amp;指定扫描规则</h4><p>查看IOT容器里面有哪些对象：</p>
<pre><code class="java">import com.sicmatr1x.config.MainConfig;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class IOCTest {

    @SuppressWarnings(&quot;resource&quot;)
    @Test
    public void test01(){
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        String[] beanNames = annotationConfigApplicationContext.getBeanDefinitionNames();
        for (String beanName : beanNames) {
            System.out.println(beanName);
        }
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
mainConfig
bookDao
bookService
person</code></pre><p>因为上面使用了<code>excludeFilters = {@Filter(type = FilterType.ANNOTATION, classes = {Controller.class}</code>所以IOT容器中注入了除了<code>BookController</code>以外的其它位于包<code>com.sicmatr1x</code>下的类的对象</p>
<p>我们再看下其它的Filter，进入到<code>FilterType.class</code>里面</p>
<p>FilterType.java:</p>
<pre><code class="java">/*
 * Copyright 2002-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.context.annotation;

/**
 * Enumeration of the type filters that may be used in conjunction with
 * {@link ComponentScan @ComponentScan}.
 *
 * @author Mark Fisher
 * @author Juergen Hoeller
 * @author Chris Beams
 * @since 2.5
 * @see ComponentScan
 * @see ComponentScan#includeFilters()
 * @see ComponentScan#excludeFilters()
 * @see org.springframework.core.type.filter.TypeFilter
 */
public enum FilterType {

    /**
     * Filter candidates marked with a given annotation.
     * @see org.springframework.core.type.filter.AnnotationTypeFilter
     */
    ANNOTATION,

    /**
     * Filter candidates assignable to a given type.
     * @see org.springframework.core.type.filter.AssignableTypeFilter
     */
    ASSIGNABLE_TYPE,

    /**
     * Filter candidates matching a given AspectJ type pattern expression.
     * @see org.springframework.core.type.filter.AspectJTypeFilter
     */
    ASPECTJ,

    /**
     * Filter candidates matching a given regex pattern.
     * @see org.springframework.core.type.filter.RegexPatternTypeFilter
     */
    REGEX,

    /** Filter candidates using a given custom
     * {@link org.springframework.core.type.filter.TypeFilter} implementation.
     */
    CUSTOM

}
</code></pre>
<ul>
<li><code>ANNOTATION</code>: 按照注解来进行过滤<ul>
<li>eg: <code>@Filter(type = FilterType.ANNOTATION, classes = {Controller.class}</code></li>
</ul>
</li>
<li><code>ASSIGNABLE_TYPE</code>: 按照给定的类型来进行过滤<ul>
<li>eg: <code>@Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {BookController.class}</code></li>
</ul>
</li>
<li><code>ASPECTJ</code>: 按照AspectJ表达式来进行过滤</li>
<li><code>REGEX</code>: 按照正则表达式来进行过滤</li>
<li><code>CUSTOM</code>: 按照自定义规则来进行过滤，需要自定义一个<code>org.springframework.core.type.filter.TypeFilter</code>的实现类</li>
</ul>
<h4 id="自定义TypeFilter指定过滤规则"><a href="#自定义TypeFilter指定过滤规则" class="headerlink" title="自定义TypeFilter指定过滤规则"></a>自定义TypeFilter指定过滤规则</h4><p>实现<code>org.springframework.core.type.filter.TypeFilter</code>类：</p>
<pre><code class="java">package com.sicmatr1x.config;

import org.springframework.core.io.Resource;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.core.type.ClassMetadata;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.TypeFilter;

import java.io.IOException;

public class MyTypeFilter implements TypeFilter {
    /**
     *
     * @param metadataReader the metadata reader for the target class 读取到当前正在扫描的类的信息
     * @param metadataReaderFactory a factory for obtaining metadata readers 可以获取到其它任何类信息的
     * @return true: 匹配成功; false: 匹配失败
     * @throws IOException
     */
    @Override
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
        // 获取当前类注解的信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
        // 获取当前正在扫描的类的类信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        // 获取当前类资源(类路径等)信息
        Resource resource = metadataReader.getResource();

        String className = classMetadata.getClassName();
        System.out.println(&quot;className:&quot; + className);
        return false;
    }
}
</code></pre>
<p>在Config类里面使用我们的Filter类：</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;

@Configuration
@ComponentScan(value = &quot;com.sicmatr1x&quot;, excludeFilters = {
        @Filter(type = FilterType.CUSTOM, classes = {MyTypeFilter.class})
})
public class MainConfig {
    @Bean(&quot;person&quot;)
    public Person person(){
        return new Person(&quot;Abby&quot;, 20);
    }
}
</code></pre>
<p>输出：</p>
<pre><code>className:com.sicmatr1x.bean.Person
className:com.sicmatr1x.config.MyTypeFilter
className:com.sicmatr1x.controller.BookController
className:com.sicmatr1x.dao.BookDao
className:com.sicmatr1x.service.BookService
className:com.sicmatr1x.test.MainTest
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
mainConfig
bookController
bookDao
bookService
person
</code></pre><p>这里没有类被排除是因为我们的自定义规则里面总是返回false，所以一个都没有被排除</p>
<p>修改一下代码：</p>
<pre><code class="java">package com.sicmatr1x.config;

import org.springframework.core.io.Resource;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.core.type.ClassMetadata;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.TypeFilter;

import java.io.IOException;

public class MyTypeFilter implements TypeFilter {
    /**
     *
     * @param metadataReader the metadata reader for the target class 读取到当前正在扫描的类的信息
     * @param metadataReaderFactory a factory for obtaining metadata readers 可以获取到其它任何类信息的
     * @return true: 匹配成功; false: 匹配失败
     * @throws IOException
     */
    @Override
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
        // 获取当前类注解的信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
        // 获取当前正在扫描的类的类信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        // 获取当前类资源(类路径等)信息
        Resource resource = metadataReader.getResource();

        String className = classMetadata.getClassName();
        System.out.println(&quot;className:&quot; + className);
        if(className.contains(&quot;er&quot;)) {
            return true;
        }
        return false;
    }
}
</code></pre>
<p>输出：</p>
<pre><code>className:com.sicmatr1x.bean.Person
className:com.sicmatr1x.config.MyTypeFilter
className:com.sicmatr1x.controller.BookController
className:com.sicmatr1x.dao.BookDao
className:com.sicmatr1x.service.BookService
className:com.sicmatr1x.test.MainTest
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
mainConfig
bookDao
person</code></pre><p>与之前相比少了bookController, bookService，其实这里还排除了MyTypeFilter，不过这个类本来就用<code>annotationConfigApplicationContext.getBeanDefinitionNames()</code>获取不出来所以看不出效果</p>
<h4 id="Scope-设置组件作用域"><a href="#Scope-设置组件作用域" class="headerlink" title="@Scope 设置组件作用域"></a><code>@Scope</code> 设置组件作用域</h4><p>众所周知，在spring里面注册一个bean并托管到IOT容器中之后该bean是单实例的，无论你get几次都是获得的同一个对象</p>
<p>可以使用<code>@Scope</code>注解来限定对象范围</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

@Configuration
public class MainConfig2 {
    @Scope
    @Bean(&quot;person&quot;)
    public Person person(){
        return new Person(&quot;Bob&quot;, 30);
    }
}
</code></pre>
<p>点进<code>@Scope</code>注解里面看一下：</p>
<pre><code class="java">/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.core.annotation.AliasFor;

/**
 * When used as a type-level annotation in conjunction with
 * {@link org.springframework.stereotype.Component @Component},
 * {@code @Scope} indicates the name of a scope to use for instances of
 * the annotated type.
 *
 * &lt;p&gt;When used as a method-level annotation in conjunction with
 * {@link Bean @Bean}, {@code @Scope} indicates the name of a scope to use
 * for the instance returned from the method.
 *
 * &lt;p&gt;In this context, &lt;em&gt;scope&lt;/em&gt; means the lifecycle of an instance,
 * such as {@code singleton}, {@code prototype}, and so forth. Scopes
 * provided out of the box in Spring may be referred to using the
 * {@code SCOPE_*} constants available in the {@link ConfigurableBeanFactory}
 * and {@code WebApplicationContext} interfaces.
 *
 * &lt;p&gt;To register additional custom scopes, see
 * {@link org.springframework.beans.factory.config.CustomScopeConfigurer
 * CustomScopeConfigurer}.
 *
 * @author Mark Fisher
 * @author Chris Beams
 * @author Sam Brannen
 * @since 2.5
 * @see org.springframework.stereotype.Component
 * @see org.springframework.context.annotation.Bean
 */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Scope {

    /**
     * Alias for {@link #scopeName}.
     * @see #scopeName
     */
    @AliasFor(&quot;scopeName&quot;)
    String value() default &quot;&quot;;

    /**
     * Specifies the name of the scope to use for the annotated component/bean.
     * &lt;p&gt;Defaults to an empty string ({@code &quot;&quot;}) which implies
     * {@link ConfigurableBeanFactory#SCOPE_SINGLETON SCOPE_SINGLETON}.
     * @since 4.2
     * @see ConfigurableBeanFactory#SCOPE_PROTOTYPE
     * @see ConfigurableBeanFactory#SCOPE_SINGLETON
     * @see org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST
     * @see org.springframework.web.context.WebApplicationContext#SCOPE_SESSION
     * @see #value
     */
    @AliasFor(&quot;value&quot;)
    String scopeName() default &quot;&quot;;

    /**
     * Specifies whether a component should be configured as a scoped proxy
     * and if so, whether the proxy should be interface-based or subclass-based.
     * &lt;p&gt;Defaults to {@link ScopedProxyMode#DEFAULT}, which typically indicates
     * that no scoped proxy should be created unless a different default
     * has been configured at the component-scan instruction level.
     * &lt;p&gt;Analogous to {@code &lt;aop:scoped-proxy/&gt;} support in Spring XML.
     * @see ScopedProxyMode
     */
    ScopedProxyMode proxyMode() default ScopedProxyMode.DEFAULT;

}
</code></pre>
<p>这里的<code>@AliasFor</code>注解是别名的意思，就是给其注解的字段一个别名，比如这里<code>value</code>就和<code>scopeName</code>等价了</p>
<p>我们看下<code>value</code>能取哪些值，注释中就说了可以取以下类中的以下的值</p>
<p>类名#值：</p>
<ul>
<li>ConfigurableBeanFactory#SCOPE_PROTOTYPE</li>
<li>ConfigurableBeanFactory#SCOPE_SINGLETON</li>
<li>org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</li>
<li>org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</li>
</ul>
<p>点进<code>ConfigurableBeanFactory</code>中：</p>
<pre><code class="java">public interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry {
    String SCOPE_SINGLETON = &quot;singleton&quot;;
    String SCOPE_PROTOTYPE = &quot;prototype&quot;;
    //...
}</code></pre>
<p>可知：<code>SCOPE_PROTOTYPE</code>的值为<code>prototype</code>，其它以此类推</p>
<p><code>value</code>能取：</p>
<ul>
<li><code>singleton</code>: 单实例（默认值），IOC容器启动时会调用方法创建对象并托管到IOC容器中，以后每次获取直接从容器中拿</li>
<li><code>prototype</code>: 多实例，IOC容器启动时并不会调用方法创建对象，而是每次获取的时候才会调用方法创建对象，每次获取都会调一遍方法</li>
<li><code>request</code>: 同一次请求创建一个实例</li>
<li><code>session</code>: 同一个session创建一个实例</li>
</ul>
<p>我们使用<code>prototype</code>试下：</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

@Configuration
public class MainConfig2 {
    @Scope(&quot;prototype&quot;)
    @Bean(&quot;person&quot;)
    public Person person(){
        return new Person(&quot;Bob&quot;, 30);
    }
}
</code></pre>
<p>测试方法：</p>
<pre><code class="java">    @SuppressWarnings(&quot;resource&quot;)
    @Test
    public void test02(){
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);
        String[] beanNames = annotationConfigApplicationContext.getBeanDefinitionNames();
        for (String beanName : beanNames) {
            System.out.println(beanName);
        }
        Object bean = annotationConfigApplicationContext.getBean(&quot;person&quot;);
        Object bean2 = annotationConfigApplicationContext.getBean(&quot;person&quot;);
        System.out.println(&quot;bean == bean2: &quot; + (bean == bean2));
    }</code></pre>
<p>输出：</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
mainConfig2
person
bean == bean2: false
</code></pre><p>可以看到已经不是单例了</p>
<h4 id="Lazy-bean-懒加载"><a href="#Lazy-bean-懒加载" class="headerlink" title="@Lazy-bean 懒加载"></a><code>@Lazy-bean</code> 懒加载</h4><p>懒加载主要针对单实例bean，单实例通常情况下IOC容器启动时会调用方法创建对象并托管到IOC容器中，以后每次获取直接从容器中拿。如果启用懒加载则会使得容器在启动时不创建对象，而是在第一次使用(获取)bean时创建对象</p>
<pre><code class="java">    @Lazy
    @Bean(&quot;person&quot;)
    public Person person(){
        return new Person(&quot;Bob&quot;, 30);
    }</code></pre>
<h4 id="Conditional-按照条件注册bean"><a href="#Conditional-按照条件注册bean" class="headerlink" title="@Conditional 按照条件注册bean"></a><code>@Conditional</code> 按照条件注册bean</h4><p>该注解在spring底层大量使用，主要作用是按照一定的条件进行判断满足条件给容器中注册bean</p>
<p>那么该如何使用<code>@Conditional</code>注解呢，我们点进去看到需要提供一个实现了<code>Condition</code>接口的类</p>
<pre><code class="java">package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {

    /**
     * All {@link Condition}s that must {@linkplain Condition#matches match}
     * in order for the component to be registered.
     */
    Class&lt;? extends Condition&gt;[] value();

}</code></pre>
<p><code>@Target({ElementType.TYPE, ElementType.METHOD})</code>, 显然<code>@Conditional</code>注解可以用于方法和类</p>
<p>点进去看下<code>Condition</code>接口：</p>
<pre><code class="java">public interface Condition {

    /**
     * Determine if the condition matches.
     * @param context the condition context
     * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class}
     * or {@link org.springframework.core.type.MethodMetadata method} being checked.
     * @return {@code true} if the condition matches and the component can be registered
     * or {@code false} to veto registration.
     */
    boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);

}</code></pre>
<p>显然需要实现<code>matches</code>方法，并且若返回为true则表示条件匹配成功</p>
<p>假设我们需要做一个根据操作系统来判断并注入对应的bean的功能</p>
<pre><code class="java">package com.sicmatr1x.condition;

import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class LinuxCondition implements Condition {
    /**
     * 判断是否为Linux系统
     * @param context 判断条件能使用的上下文环境
     * @param metadata 注解信息
     * @return
     */
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 能获取到IOC使用的beanFactory
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
        // 能获取到类加载器
        ClassLoader classLoader = context.getClassLoader();
        // 能获取到当前环境信息
        Environment environment = context.getEnvironment();
        // 能获取到bean定义的注册类(可用于查某个bean的定义或者注册bean)
        BeanDefinitionRegistry registry = context.getRegistry();
        String property = environment.getProperty(&quot;os.name&quot;);
        if(property.contains(&quot;Linux&quot;)) {
            return true;
        }
        return false;
    }
}
</code></pre>
<pre><code class="java">package com.sicmatr1x.condition;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class WindowsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 能获取到当前环境信息
        Environment environment = context.getEnvironment();
        String property = environment.getProperty(&quot;os.name&quot;);
        if(property.contains(&quot;Windows&quot;)) {
            return true;
        }
        return false;
    }
}
</code></pre>
<p>然后使用<code>@Conditional</code>注解</p>
<pre><code class="java">    @Conditional({WindowsCondition.class})
    @Bean(&quot;bill&quot;)
    public Person person01(){
        return new Person(&quot;Bill&quot;, 60);
    }

    @Conditional({LinuxCondition.class})
    @Bean(&quot;Linus&quot;)
    public Person person02(){
        return new Person(&quot;Linus&quot;, 50);
    }</code></pre>
<p>测试一下效果：</p>
<pre><code class="java">    @SuppressWarnings(&quot;resource&quot;)
    @Test
    public void test03(){
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig2.class);
        ConfigurableEnvironment environment = annotationConfigApplicationContext.getEnvironment();
        String property = environment.getProperty(&quot;os.name&quot;);
        System.out.println(property);
        String[] namesForType = annotationConfigApplicationContext.getBeanNamesForType(Person.class);
        for (String name : namesForType) {
            System.out.println(name);
        }
        Map&lt;String, Person&gt; persons = annotationConfigApplicationContext.getBeansOfType(Person.class);
    }</code></pre>
<p>输出：</p>
<pre><code>Windows 10
person
bill</code></pre><p>这里打印出了我们当前的操作系统为Windows 10，然后正确的注入了bill这个bean到IOT容器</p>
<p>测试Linux可以在VM arguments里面配置虚拟机参数：</p>
<pre><code>-Dos.name=Linux</code></pre><p>输出：</p>
<pre><code>Linux
person
Linus</code></pre><p><code>@Conditional</code>注解还可以放在类上，作用是满足当前条件后这个类中配置的所有bean才能生效</p>
<h4 id="容器中注册组件方法"><a href="#容器中注册组件方法" class="headerlink" title="容器中注册组件方法"></a>容器中注册组件方法</h4><ol>
<li>包扫描+组件标注注解(<code>@Controller</code>, <code>@Service</code>, <code>@Component</code>)<ul>
<li>缺点：只能作用在自己写的类上，即需要修改需要注册的类的代码，导入的第三方包不可以采用此种方法</li>
</ul>
</li>
<li><code>@Bean</code>注解，手动注册</li>
<li><code>@Import</code>注解，快速导入组件到容器，id默认是全类名</li>
</ol>
<h4 id="Import-给容器中快速导入一个组件"><a href="#Import-给容器中快速导入一个组件" class="headerlink" title="@Import 给容器中快速导入一个组件"></a><code>@Import</code> 给容器中快速导入一个组件</h4><pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Color;
import org.springframework.context.annotation.*;

@Configuration
@Import(Color.class)
public class MainConfig2 {

}</code></pre>
<p>批量导入：</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Color;
import com.sicmatr1x.bean.Red;
import org.springframework.context.annotation.*;

@Configuration
@Import({Color.class, Red.class})
public class MainConfig2 {

}</code></pre>
<h4 id="Import-使用ImportSelector"><a href="#Import-使用ImportSelector" class="headerlink" title="@Import 使用ImportSelector"></a><code>@Import</code> 使用ImportSelector</h4><p>这种方法在spring源码用用到的较多</p>
<p>查看<code>@Import</code>的源码发现除了通常的组件类(regular component classes)作为参数传入以外还可以传入<code>Configuration</code>, <code>ImportSelector</code>, <code>ImportBeanDefinitionRegistrar</code></p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {

    /**
     * {@link Configuration}, {@link ImportSelector}, {@link ImportBeanDefinitionRegistrar}
     * or regular component classes to import.
     */
    Class&lt;?&gt;[] value();

}</code></pre>
<p>查看<code>ImportSelector</code>源码: </p>
<pre><code class="java">public interface ImportSelector {

    /**
     * Select and return the names of which class(es) should be imported based on
     * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.
     */
    String[] selectImports(AnnotationMetadata importingClassMetadata);

}</code></pre>
<blockquote>
<p>Select and return the names of which class(es) should be imported</p>
</blockquote>
<p>显然<code>selectImports</code>方法会返回需要导入的类的全类名组成的数组</p>
<p>在本项目中只有<code>MainConfig2</code>类里面使用到了<code>@Import</code>注解</p>
<pre><code class="java">@Configuration
@Import({Color.class, MyImportSelector.class})
public class MainConfig2 {
    //...
}</code></pre>
<p>我们打个断点到<code>selectImports</code>方法上看看传入的参数：</p>
<img src="./2020-05-26 11_41_57-spring-annotation – MainConfig2.java IntelliJ IDEA Administrator.png">

<p>可以看到<code>importingClassMetadata</code>对象包含的：</p>
<ul>
<li><code>annotations</code>对象数组里面获取到了<code>MainConfig2</code>类上面的2个注解</li>
<li><code>introspectedClass</code>对象则获取到了<code>MainConfig2</code>类的类信息</li>
</ul>
<p>继续debug就可发现：若返回为null则会抛出空指针异常</p>
<pre><code class="java">    /**
     * Factory method to obtain {@link SourceClass}s from class names.
     */
    private Collection&lt;SourceClass&gt; asSourceClasses(String[] classNames) throws IOException {
        List&lt;SourceClass&gt; annotatedClasses = new ArrayList&lt;SourceClass&gt;(classNames.length); // 这里调到了classNames.length，若返回为空，显然null没有length属性
        for (String className : classNames) {
            annotatedClasses.add(asSourceClass(className));
        }
        return annotatedClasses;
    }</code></pre>
<p>推荐在没有class返回的情况下返回一个空数组</p>
<p>实践一下：</p>
<pre><code class="java">package com.sicmatr1x.condition;

import org.springframework.context.annotation.ImportSelector;
import org.springframework.core.type.AnnotationMetadata;

public class MyImportSelector implements ImportSelector {
    /**
     *
     * @param importingClassMetadata 当前标注@Import注解的类的所有的类的信息
     * @return 返回需要导入的类的全类名
     */
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {

        return new String[]{&quot;com.sicmatr1x.bean.Blue&quot;, &quot;com.sicmatr1x.bean.Yellow&quot;};
    }
}
</code></pre>
<p>运行unit test，可以看到已经注册进来了</p>
<pre><code>mainConfig2
com.sicmatr1x.bean.Color
com.sicmatr1x.bean.Blue
com.sicmatr1x.bean.Yellow
person
bill</code></pre><h4 id="Import-使用ImportBeanDefinitionRegistrar"><a href="#Import-使用ImportBeanDefinitionRegistrar" class="headerlink" title="@Import 使用ImportBeanDefinitionRegistrar"></a><code>@Import</code> 使用ImportBeanDefinitionRegistrar</h4><p>从<code>@Import</code>源码里面继续点进去看<code>ImportBeanDefinitionRegistrar</code>的源码：</p>
<pre><code class="java">public interface ImportBeanDefinitionRegistrar {

    /**
     * Register bean definitions as necessary based on the given annotation metadata of
     * the importing {@code @Configuration} class.
     * &lt;p&gt;Note that {@link BeanDefinitionRegistryPostProcessor} types may &lt;em&gt;not&lt;/em&gt; be
     * registered here, due to lifecycle constraints related to {@code @Configuration}
     * class processing.
     * @param importingClassMetadata annotation metadata of the importing class
     * @param registry current bean definition registry
     */
    public void registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);

}</code></pre>
<ul>
<li><code>importingClassMetadata</code>: 当前类的一些注解信息</li>
<li><code>registry</code>: bean定义的注册类，可用于给程序中注册bean</li>
</ul>
<p>现在实现一下这个接口：</p>
<pre><code class="java">package com.sicmatr1x.condition;

import com.sicmatr1x.bean.RainBow;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
import org.springframework.core.type.AnnotationMetadata;

public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    /**
     * 把所有需要添加到容器中的bean，可以通过BeanDefinition注册类的registerBeanDefinition方法注册进IOT容器
     * @param importingClassMetadata 当前类的注解信息
     * @param registry BeanDefinition注册类，可用于给程序中注册bean
     */
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 判断IOT容器中是否已经注册了red和blue
        boolean isRegisteredYellowClass = registry.containsBeanDefinition(&quot;com.sicmatr1x.bean.Yellow&quot;);
        boolean isRegisteredBlueClass = registry.containsBeanDefinition(&quot;com.sicmatr1x.bean.Blue&quot;);
        if(isRegisteredYellowClass &amp;&amp; isRegisteredBlueClass) {
            // 指定Bean定义信息(如Bean的类型、作用域等)
            RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class);
            // 注册bean，同时指定bean名
            registry.registerBeanDefinition(&quot;rainBow&quot;, beanDefinition);
        }
    }
}
</code></pre>
<p>使用方法同前面的<code>MyImportSelector</code>类：</p>
<pre><code class="java">@Configuration
@Import({Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class})
public class MainConfig2 {
    //...
}</code></pre>
<p>运行unit test：</p>
<pre><code>mainConfig2
com.sicmatr1x.bean.Color
com.sicmatr1x.bean.Blue
com.sicmatr1x.bean.Yellow
person
bill
rainBow</code></pre><h4 id="使用FactoryBean注册组件"><a href="#使用FactoryBean注册组件" class="headerlink" title="使用FactoryBean注册组件"></a>使用FactoryBean注册组件</h4><p>使用前先看<code>FactoryBean</code>源码：</p>
<pre><code class="java">public interface FactoryBean&lt;T&gt; {

    /**
     * Return an instance (possibly shared or independent) of the object
     * managed by this factory.
     * &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the
     * Singleton and Prototype design pattern.
     * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of
     * the call (for example because it is involved in a circular reference),
     * throw a corresponding {@link FactoryBeanNotInitializedException}.
     * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null}
     * objects. The factory will consider this as normal value to be used; it
     * will not throw a FactoryBeanNotInitializedException in this case anymore.
     * FactoryBean implementations are encouraged to throw
     * FactoryBeanNotInitializedException themselves now, as appropriate.
     * @return an instance of the bean (can be {@code null})
     * @throws Exception in case of creation errors
     * @see FactoryBeanNotInitializedException
     */
    T getObject() throws Exception;

    /**
     * Return the type of object that this FactoryBean creates,
     * or {@code null} if not known in advance.
     * &lt;p&gt;This allows one to check for specific types of beans without
     * instantiating objects, for example on autowiring.
     * &lt;p&gt;In the case of implementations that are creating a singleton object,
     * this method should try to avoid singleton creation as far as possible;
     * it should rather estimate the type in advance.
     * For prototypes, returning a meaningful type here is advisable too.
     * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has
     * been fully initialized. It must not rely on state created during
     * initialization; of course, it can still use such state if available.
     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return
     * {@code null} here. Therefore it is highly recommended to implement
     * this method properly, using the current state of the FactoryBean.
     * @return the type of object that this FactoryBean creates,
     * or {@code null} if not known at the time of the call
     * @see ListableBeanFactory#getBeansOfType
     */
    Class&lt;?&gt; getObjectType();

    /**
     * Is the object managed by this factory a singleton? That is,
     * will {@link #getObject()} always return the same object
     * (a reference that can be cached)?
     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,
     * the object returned from {@code getObject()} might get cached
     * by the owning BeanFactory. Hence, do not return {@code true}
     * unless the FactoryBean always exposes the same reference.
     * &lt;p&gt;The singleton status of the FactoryBean itself will generally
     * be provided by the owning BeanFactory; usually, it has to be
     * defined as singleton there.
     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning {@code false} does not
     * necessarily indicate that returned objects are independent instances.
     * An implementation of the extended {@link SmartFactoryBean} interface
     * may explicitly indicate independent instances through its
     * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
     * implementations which do not implement this extended interface are
     * simply assumed to always return independent instances if the
     * {@code isSingleton()} implementation returns {@code false}.
     * @return whether the exposed object is a singleton
     * @see #getObject()
     * @see SmartFactoryBean#isPrototype()
     */
    boolean isSingleton();

}</code></pre>
<p>可以看到有三个方法：</p>
<ol>
<li><code>T getObject() throws Exception</code>: 返回需要放到容器中的对象，这里是泛型也就是说工厂接口在实现时就已经确定了其只能返回某种类型的对象了</li>
<li><code>Class&lt;?&gt; getObjectType()</code>: 返回对象类型</li>
<li><code>boolean isSingleton();</code>: 是否为单例模式</li>
</ol>
<p>我们实现一下这个接口：</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.factory.FactoryBean;

/**
 * 实现一个spring定义的工厂Bean
 */
public class ColorFactoryBean implements FactoryBean&lt;Color&gt; {
    /**
     *
     * @return 返回Color对象，并添加到容器中
     * @throws Exception
     */
    @Override
    public Color getObject() throws Exception {
        System.out.println(&quot;ColorFactoryBean:getObject()&quot;);
        return new Color();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return Color.class;
    }

    /**
     * true表明为单例，容器中只保存一份
     * @return
     */
    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre>
<p>配置类里注册一下<code>ColorFactoryBean</code>工厂</p>
<pre><code class="java">@Configuration
public class MainConfig2 {
    //...
    @Bean
    public ColorFactoryBean colorFactoryBean(){
        return new ColorFactoryBean();
    }
}</code></pre>
<p>unit test里从IOT容器中获取并打印一下我们的工厂的类型：</p>
<pre><code class="java">        // 工厂Bean获取的是调用getObject创建的对象
        Object factoryBean = annotationConfigApplicationContext.getBean(&quot;colorFactoryBean&quot;);
        Object factoryBean2 = annotationConfigApplicationContext.getBean(&quot;colorFactoryBean&quot;);
        System.out.println(&quot;ColorFactoryBean class is &quot; + factoryBean.getClass());
        System.out.println(factoryBean == factoryBean2);</code></pre>
<p>输出：</p>
<pre><code>ColorFactoryBean:getObject()
ColorFactoryBean class is class com.sicmatr1x.bean.Color
true</code></pre><p>可以发现我们的工厂Bean的类型居然是<code>Color</code>，说明我们从IOT容器中getBean结果其实get到的是调用<code>ColorFactoryBean.getObject()</code>返回的对象，再用getBean获取一下发现两次获取到的对象是一样的，这表明我们重写<code>isSingleton()</code>方法的返回值被spring用于判断是否为单例模式了</p>
<p>如果想获取到<code>ColorFactoryBean</code>本身的话可以通过在bean的id前增加一个<code>&amp;</code>字符来实现：</p>
<pre><code class="java">Object factoryBean = annotationConfigApplicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);</code></pre>
<p>至于为什么是这个字符，可以去<code>BeanFactory</code>接口里面定义了<code>&amp;</code>字符</p>
<pre><code class="java">public interface BeanFactory {

    /**
     * Used to dereference a {@link FactoryBean} instance and distinguish it from
     * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named
     * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject}
     * will return the factory, not the instance returned by the factory.
     */
    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;
    //...
}</code></pre>
<hr>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="Bean指定初始化和销毁方法"><a href="#Bean指定初始化和销毁方法" class="headerlink" title="@Bean指定初始化和销毁方法"></a><code>@Bean</code>指定初始化和销毁方法</h4><p>Bean的生命周期：</p>
<ul>
<li>bean创建</li>
<li>初始化</li>
<li>销毁</li>
</ul>
<p>Bean的生命周期现在是由容器来管理的，我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候会调用我们自定义的初始化或销毁方法</p>
<p>以下会讲4种实现方式：</p>
<ol>
<li>指定初始化和销毁方法</li>
</ol>
<p>以前是在<code>beans.xml</code>文件中指定初始化和销毁方法<code>init-method=&quot;&quot; destroy-method=&quot;&quot;</code></p>
<pre><code class="java">package com.sicmatr1x.bean;

public class Car {
    public Car(){
        System.out.println(&quot;Car:constructor&quot;);
    }

    public void init() {
        System.out.println(&quot;Car:init()&quot;);
    }

    public void destroy() {
        System.out.println(&quot;Car:destroy()&quot;);
    }
}
</code></pre>
<p>现在可以通过<code>@Bean</code>注解配置对应的方法</p>
<ul>
<li>初始化：对象创建完成并赋值好，调用初始化方法</li>
<li>销毁：容器关闭的时候，进行销毁</li>
</ul>
<p>写一个配置类：</p>
<pre><code class="java">package com.sicmatr1x.condition;

import com.sicmatr1x.bean.Car;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MainConfigLifeCycle {

    @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
    public Car car() {
        return new Car();
    }
}

</code></pre>
<p>unit test：</p>
<pre><code class="java">    @Test
    public void test01(){
        // 创建IOC容器
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfigLifeCycle.class);
        System.out.println(&quot;容器创建完成&quot;);
        annotationConfigApplicationContext.close();
        System.out.println(&quot;容器销毁完成&quot;);
    }</code></pre>
<p>输出：</p>
<pre><code>Car:constructor
Car:init()
容器创建完成
Car:destroy()
容器销毁完成</code></pre><p>在单实例模式下对象的初始化在容器创建完之后进行，销毁在容器销毁前完成</p>
<p>在多实例模式下对象的初始化在你获取时进行，容器不会管理这个bean，容器不会调用其销毁方法</p>
<h4 id="InitializingBean-amp-DisposableBean"><a href="#InitializingBean-amp-DisposableBean" class="headerlink" title="InitializingBean &amp; DisposableBean"></a><code>InitializingBean</code> &amp; <code>DisposableBean</code></h4><ol start="2">
<li>实现<code>InitializingBean</code> &amp; <code>DisposableBean</code>接口</li>
</ol>
<p>用于在bean初始化时执行自定义初始化逻辑的接口</p>
<p>当<code>BeanFactory</code>创建好对象并且给bean里所有的属性设置完成后会调用<code>InitializingBean.afterPropertiesSet()</code></p>
<pre><code class="java">public interface InitializingBean {

    /**
     * Invoked by a BeanFactory after it has set all bean properties supplied
     * (and satisfied BeanFactoryAware and ApplicationContextAware).
     * &lt;p&gt;This method allows the bean instance to perform initialization only
     * possible when all bean properties have been set and to throw an
     * exception in the event of misconfiguration.
     * @throws Exception in the event of misconfiguration (such
     * as failure to set an essential property) or if initialization fails.
     */
    void afterPropertiesSet() throws Exception;

}</code></pre>
<p>与之相对的在bean销毁时也有对应的接口：</p>
<pre><code class="java">public interface DisposableBean {

    /**
     * Invoked by a BeanFactory on destruction of a singleton.
     * @throws Exception in case of shutdown errors.
     * Exceptions will get logged but not rethrown to allow
     * other beans to release their resources too.
     */
    void destroy() throws Exception;

}</code></pre>
<p>给bean实现一下对应接口：</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;

@Component
public class Cat implements InitializingBean, DisposableBean {
    public Cat() {
        System.out.println(&quot;Cat:constructor()&quot;);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;Cat:destroy()&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;Cat:afterPropertiesSet()&quot;);
    }
}
</code></pre>
<p>运行一下unit test：</p>
<pre><code>Cat:constructor()
Cat:afterPropertiesSet()
Car:constructor
Car:init()
容器创建完成
Car:destroy()
Cat:destroy()
容器销毁完成</code></pre><h4 id="PostConstruct-amp-PreDestroy"><a href="#PostConstruct-amp-PreDestroy" class="headerlink" title="@PostConstruct &amp; @PreDestroy"></a><code>@PostConstruct</code> &amp; <code>@PreDestroy</code></h4><ol start="3">
<li>实现<code>@PostConstruct</code> &amp; <code>@PreDestroy</code>注解</li>
</ol>
<p><code>@PostConstruct</code> &amp; <code>@PreDestroy</code>注解在JSR250规范中被定义</p>
<p>话不多说，先看源码：</p>
<pre><code class="java">package javax.annotation;

import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

/**
 * The PostConstruct annotation is used on a method that needs to be executed
 * after dependency injection is done to perform any initialization. This
 * method MUST be invoked before the class is put into service. This
 * annotation MUST be supported on all classes that support dependency
 * injection. The method annotated with PostConstruct MUST be invoked even
 * if the class does not request any resources to be injected. Only one
 * method can be annotated with this annotation. The method on which the
 * PostConstruct annotation is applied MUST fulfill all of the following
 * criteria:
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The method MUST NOT have any parameters except in the case of
 * interceptors in which case it takes an InvocationContext object as
 * defined by the Interceptors specification.&lt;/li&gt;
 * &lt;li&gt;The method defined on an interceptor class MUST HAVE one of the
 * following signatures:
 * &lt;p&gt;
 * void &amp;#060;METHOD&amp;#062;(InvocationContext)
 * &lt;p&gt;
 * Object &amp;#060;METHOD&amp;#062;(InvocationContext) throws Exception
 * &lt;p&gt;
 * &lt;i&gt;Note: A PostConstruct interceptor method must not throw application
 * exceptions, but it may be declared to throw checked exceptions including
 * the java.lang.Exception if the same interceptor method interposes on
 * business or timeout methods in addition to lifecycle events. If a
 * PostConstruct interceptor method returns a value, it is ignored by
 * the container.&lt;/i&gt;
 * &lt;/li&gt;
 * &lt;li&gt;The method defined on a non-interceptor class MUST HAVE the
 * following signature:
 * &lt;p&gt;
 * void &amp;#060;METHOD&amp;#062;()
 * &lt;/li&gt;
 * &lt;li&gt;The method on which PostConstruct is applied MAY be public, protected,
 * package private or private.&lt;/li&gt;
 * &lt;li&gt;The method MUST NOT be static except for the application client.&lt;/li&gt;
 * &lt;li&gt;The method MAY be final.&lt;/li&gt;
 * &lt;li&gt;If the method throws an unchecked exception the class MUST NOT be put into
 * service except in the case of EJBs where the EJB can handle exceptions and
 * even recover from them.&lt;/li&gt;&lt;/ul&gt;
 * @since Common Annotations 1.0
 * @see javax.annotation.PreDestroy
 * @see javax.annotation.Resource
 */
@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PostConstruct {
}
</code></pre>
<blockquote>
<p>The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization.</p>
</blockquote>
<p>显然这个注解的作用是用于在dependency injection(也就是bean创建完成且属性赋值完成)之后运行一个初始化方法</p>
<pre><code class="java">package javax.annotation;

import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

/**
 * The PreDestroy annotation is used on methods as a callback notification to
 * signal that the instance is in the process of being removed by the
 * container. The method annotated with PreDestroy is typically used to
 * release resources that it has been holding. This annotation MUST be
 * supported by all container managed objects that support PostConstruct
 * except the application client container in Java EE 5. The method on which
 * the PreDestroy annotation is applied MUST fulfill all of the following
 * criteria:
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The method MUST NOT have any parameters except in the case of
 * interceptors in which case it takes an InvocationContext object as
 * defined by the Interceptors specification.&lt;/li&gt;
 * &lt;li&gt;The method defined on an interceptor class MUST HAVE one of the
 * following signatures:
 * &lt;p&gt;
 * void &amp;#060;METHOD&amp;#062;(InvocationContext)
 * &lt;p&gt;
 * Object &amp;#060;METHOD&amp;#062;(InvocationContext) throws Exception
 * &lt;p&gt;
 * &lt;i&gt;Note: A PreDestroy interceptor method must not throw application
 * exceptions, but it may be declared to throw checked exceptions including
 * the java.lang.Exception if the same interceptor method interposes on
 * business or timeout methods in addition to lifecycle events. If a
 * PreDestroy interceptor method returns a value, it is ignored by
 * the container.&lt;/i&gt;
 * &lt;/li&gt;
 * &lt;li&gt;The method defined on a non-interceptor class MUST HAVE the
 * following signature:
 * &lt;p&gt;
 * void &amp;#060;METHOD&amp;#062;()
 * &lt;/li&gt;
 * &lt;li&gt;The method on which PreDestroy is applied MAY be public, protected,
 * package private or private.&lt;/li&gt;
 * &lt;li&gt;The method MUST NOT be static.&lt;/li&gt;
 * &lt;li&gt;The method MAY be final.&lt;/li&gt;
 * &lt;li&gt;If the method throws an unchecked exception it is ignored except in the
 * case of EJBs where the EJB can handle exceptions.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @see javax.annotation.PostConstruct
 * @see javax.annotation.Resource
 * @since Common Annotations 1.0
 */

@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PreDestroy {
}
</code></pre>
<blockquote>
<p>The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container.</p>
</blockquote>
<p>显然被注解方法会在 being removed by the container之前做为callback notification to signal被调用，即容器销毁bean之前调用该方法</p>
<p>创建一个bean来试验一下：</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class Dog {
    public Dog() {
        System.out.println(&quot;Dog:constructor()&quot;);
    }

    /**
     * 对象创建并赋值之后调用
     */
    @PostConstruct
    public void init() {
        System.out.println(&quot;Dog:init() by @PostConstruct&quot;);
    }

    /**
     * 容器移除对象之前调用
     */
    @PreDestroy
    public void destroy() {
        System.out.println(&quot;Dog:destroy() by @PreDestroy&quot;);
    }
}
</code></pre>
<p>run unit test看一下输出：</p>
<pre><code>Cat:constructor()
Cat:afterPropertiesSet()
Dog:constructor()
Dog:init() by @PostConstruct
Car:constructor
Car:init()
容器创建完成
Car:destroy()
Dog:destroy() by @PreDestroy
Cat:destroy()
容器销毁完成</code></pre><h4 id="BeanPostProcessor-bean的后置处理器"><a href="#BeanPostProcessor-bean的后置处理器" class="headerlink" title="BeanPostProcessor bean的后置处理器"></a><code>BeanPostProcessor</code> bean的后置处理器</h4><ol start="4">
<li><code>BeanPostProcessor</code> bean的后置处理器</li>
</ol>
<p>在bean初始化前后进行处理</p>
<p>按照惯例，看源码先：</p>
<pre><code class="java">public interface BeanPostProcessor {

    /**
     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean
     * initialization callbacks (like InitializingBean&#39;s {@code afterPropertiesSet}
     * or a custom init-method). The bean will already be populated with property values.
     * The returned bean instance may be a wrapper around the original.
     * @param bean the new bean instance
     * @param beanName the name of the bean
     * @return the bean instance to use, either the original or a wrapped one;
     * if {@code null}, no subsequent BeanPostProcessors will be invoked
     * @throws org.springframework.beans.BeansException in case of errors
     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
     */
    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;

    /**
     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean
     * initialization callbacks (like InitializingBean&#39;s {@code afterPropertiesSet}
     * or a custom init-method). The bean will already be populated with property values.
     * The returned bean instance may be a wrapper around the original.
     * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean
     * instance and the objects created by the FactoryBean (as of Spring 2.0). The
     * post-processor can decide whether to apply to either the FactoryBean or created
     * objects or both through corresponding {@code bean instanceof FactoryBean} checks.
     * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a
     * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,
     * in contrast to all other BeanPostProcessor callbacks.
     * @param bean the new bean instance
     * @param beanName the name of the bean
     * @return the bean instance to use, either the original or a wrapped one;
     * if {@code null}, no subsequent BeanPostProcessors will be invoked
     * @throws org.springframework.beans.BeansException in case of errors
     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
     * @see org.springframework.beans.factory.FactoryBean
     */
    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;

}</code></pre>
<blockquote>
<p>Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks.</p>
</blockquote>
<p>运行这个BeanPostProcessor在一个新的bean的实例调用任何initialization callbacks之前，也就是说会在一个bean的实例初始化时的所有的初始化调用方法之前调用该方法，相当于最早调用的bean的实例的初始化方法</p>
<ul>
<li><code>postProcessBeforeInitialization</code>: 在任何初始化方法之前进行处理工作</li>
<li><code>postProcessAfterInitialization</code>: 在任何初始化方法之后进行处理工作</li>
</ul>
<blockquote>
<p>@return the bean instance to use, either the original or a wrapped one;</p>
</blockquote>
<p>你可以返回一个原本的bean(通过参数传进来的)，也可以包装一下再返回</p>
<p>我们实现一下这个接口来做一个自己的BeanPostProcessor：</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;

/**
 * 后置处理器，初始化前后进行处理
 * 讲后置处理器假如到容器
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;MyBeanPostProcessor:postProcessBeforeInitialization():bean=&quot; + bean + &quot;, beanName=&quot; + beanName);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;MyBeanPostProcessor:postProcessAfterInitialization():bean=&quot; + bean + &quot;, beanName=&quot; + beanName);
        return bean;
    }
}
</code></pre>
<p>运行一下unit test：</p>
<pre><code>MyBeanPostProcessor:postProcessBeforeInitialization():bean=org.springframework.context.event.EventListenerMethodProcessor@c8e4bb0, beanName=org.springframework.context.event.internalEventListenerProcessor
MyBeanPostProcessor:postProcessAfterInitialization():bean=org.springframework.context.event.EventListenerMethodProcessor@c8e4bb0, beanName=org.springframework.context.event.internalEventListenerProcessor
MyBeanPostProcessor:postProcessBeforeInitialization():bean=org.springframework.context.event.DefaultEventListenerFactory@4206a205, beanName=org.springframework.context.event.internalEventListenerFactory
MyBeanPostProcessor:postProcessAfterInitialization():bean=org.springframework.context.event.DefaultEventListenerFactory@4206a205, beanName=org.springframework.context.event.internalEventListenerFactory
MyBeanPostProcessor:postProcessBeforeInitialization():bean=com.sicmatr1x.condition.MainConfigLifeCycle$$EnhancerBySpringCGLIB$$883e25cf@57175e74, beanName=mainConfigLifeCycle
MyBeanPostProcessor:postProcessAfterInitialization():bean=com.sicmatr1x.condition.MainConfigLifeCycle$$EnhancerBySpringCGLIB$$883e25cf@57175e74, beanName=mainConfigLifeCycle
Cat:constructor()
MyBeanPostProcessor:postProcessBeforeInitialization():bean=com.sicmatr1x.bean.Cat@770c2e6b, beanName=cat
Cat:afterPropertiesSet()
MyBeanPostProcessor:postProcessAfterInitialization():bean=com.sicmatr1x.bean.Cat@770c2e6b, beanName=cat
Dog:constructor()
MyBeanPostProcessor:postProcessBeforeInitialization():bean=com.sicmatr1x.bean.Dog@1a38c59b, beanName=dog
Dog:init() by @PostConstruct
MyBeanPostProcessor:postProcessAfterInitialization():bean=com.sicmatr1x.bean.Dog@1a38c59b, beanName=dog
Car:constructor
MyBeanPostProcessor:postProcessBeforeInitialization():bean=com.sicmatr1x.bean.Car@105fece7, beanName=car
Car:init()
MyBeanPostProcessor:postProcessAfterInitialization():bean=com.sicmatr1x.bean.Car@105fece7, beanName=car
容器创建完成
Car:destroy()
Dog:destroy() by @PreDestroy
Cat:destroy()
容器销毁完成
</code></pre><p>可以看到我们之前的<code>Cat</code>, <code>Dog</code>类的init方法被夹在<code>MyBeanPostProcessor</code>的两个方法之间运行了</p>
<pre><code>MyBeanPostProcessor:postProcessBeforeInitialization():bean=com.sicmatr1x.bean.Cat@770c2e6b, beanName=cat
Cat:afterPropertiesSet()
MyBeanPostProcessor:postProcessAfterInitialization():bean=com.sicmatr1x.bean.Cat@770c2e6b, beanName=cat</code></pre><pre><code>MyBeanPostProcessor:postProcessBeforeInitialization():bean=com.sicmatr1x.bean.Dog@1a38c59b, beanName=dog
Dog:init() by @PostConstruct
MyBeanPostProcessor:postProcessAfterInitialization():bean=com.sicmatr1x.bean.Dog@1a38c59b, beanName=dog</code></pre><p>再看<code>BeanPostProcessor</code>的注释，里面举例子提到了<code>afterPropertiesSet</code>和<code>custom init-method</code>就正好对应我们的<code>Cat.afterPropertiesSet()</code>和<code>Car.init()</code></p>
<blockquote>
<p>Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks (like InitializingBean’s {@code afterPropertiesSet} or a custom init-method)</p>
</blockquote>
<h4 id="BeanPostProcessor-原理"><a href="#BeanPostProcessor-原理" class="headerlink" title="BeanPostProcessor 原理"></a><code>BeanPostProcessor</code> 原理</h4><p>我们还是用上个例子来看，在<code>MyBeanPostProcessor.postProcessBeforeInitialization</code>方法里面打个断点</p>
<img src="./idea-debug-MyBeanPostProcessor.postProcessBeforeInitialization.png">

<p>看一下上图的方法调用栈，我们从创建IOC容器开始按照上面那个调用栈一个一个往上看：</p>
<p>用<code>// &lt;=========</code>来表明断点的位置</p>
<pre><code class="java">public class IOCTest_LifeCycle {

    @Test
    public void test01(){
        // 创建IOC容器
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfigLifeCycle.class);// &lt;=========
        System.out.println(&quot;容器创建完成&quot;);
        annotationConfigApplicationContext.close();
        System.out.println(&quot;容器销毁完成&quot;);
    }

}</code></pre>
<p>使用<code>AnnotationConfigApplicationContext</code>构造方法创建IOC容器</p>
<pre><code class="java">    public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {
        this();
        register(annotatedClasses);
        refresh();// &lt;=========
    }</code></pre>
<p><code>AnnotationConfigApplicationContext</code>构造方法调用了<code>refresh()</code>方法来刷新容器</p>
<pre><code class="java">                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);// &lt;=========</code></pre>
<p>显然从注释可以看出<code>refresh()</code>方法里面调用了<code>finishBeanFactoryInitialization</code>来初始化所有的单例对象</p>
<pre><code class="java">        // Instantiate all remaining (non-lazy-init) singletons.
        beanFactory.preInstantiateSingletons();// &lt;=========</code></pre>
<pre><code class="java">        // Trigger initialization of all non-lazy singleton beans...
        for (String beanName : beanNames) { // 这个beanNames数组里面装的就是我们之前所有的bean id，比如car, cat, dog
            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
                if (isFactoryBean(beanName)) {
                    final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);
                    boolean isEagerInit;
                    if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                        isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {
                            @Override
                            public Boolean run() {
                                return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();
                            }
                        }, getAccessControlContext());
                    }
                    else {
                        isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                    }
                    if (isEagerInit) {
                        getBean(beanName);
                    }
                }
                else {
                    getBean(beanName);// &lt;=========
                }
            }
        }</code></pre>
<p>初始化所有的非懒加载的单例bean</p>
<pre><code class="java">    @Override
    public Object getBean(String name) throws BeansException {
        return doGetBean(name, null, null, false);// &lt;=========
    }</code></pre>
<pre><code class="java">                // Create bean instance.
                if (mbd.isSingleton()) {
                    sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {// &lt;=========
                        @Override
                        public Object getObject() throws BeansException {
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            catch (BeansException ex) {
                                // Explicitly remove instance from singleton cache: It might have been put there
                                // eagerly by the creation process, to allow for circular reference resolution.
                                // Also remove any beans that received a temporary reference to the bean.
                                destroySingleton(beanName);
                                throw ex;
                            }
                        }
                    });
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }</code></pre>
<p>调用<code>getSingleton</code>获取单实例，若获取不到则会调用<code>createBean</code>创建对象</p>
<pre><code class="java">                try {
                    singletonObject = singletonFactory.getObject();// &lt;=========
                    newSingleton = true;
                }</code></pre>
<pre><code class="java">                // Create bean instance.
                if (mbd.isSingleton()) {
                    sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {
                        @Override
                        public Object getObject() throws BeansException {
                            try {
                                return createBean(beanName, mbd, args);// &lt;=========
                            }
                            catch (BeansException ex) {
                                // Explicitly remove instance from singleton cache: It might have been put there
                                // eagerly by the creation process, to allow for circular reference resolution.
                                // Also remove any beans that received a temporary reference to the bean.
                                destroySingleton(beanName);
                                throw ex;
                            }
                        }
                    });</code></pre>
<p>调用<code>createBean</code>创建对象</p>
<pre><code class="java">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);// &lt;=========
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);
        }</code></pre>
<p><code>createBean</code>方法调完就会创建出来实例，<code>beanInstance</code>就是创建出来的实例，进去看下怎么创建的</p>
<pre><code class="java">        try {
            populateBean(beanName, mbd, instanceWrapper); // 为bean的属性赋值
            if (exposedObject != null) {
                exposedObject = initializeBean(beanName, exposedObject, mbd);// &lt;=========
            }
        }</code></pre>
<p>这里调了一个叫<code>initializeBean</code>的方法</p>
<pre><code class="java">    /**
     * Initialize the given bean instance, applying factory callbacks
     * as well as init methods and bean post processors.
     * &lt;p&gt;Called from {@link #createBean} for traditionally defined beans,
     * and from {@link #initializeBean} for existing bean instances.
     * @param beanName the bean name in the factory (for debugging purposes)
     * @param bean the new bean instance we may need to initialize
     * @param mbd the bean definition that the bean was created with
     * (can also be {@code null}, if given an existing bean instance)
     * @return the initialized bean instance (potentially wrapped)
     * @see BeanNameAware
     * @see BeanClassLoaderAware
     * @see BeanFactoryAware
     * @see #applyBeanPostProcessorsBeforeInitialization
     * @see #invokeInitMethods
     * @see #applyBeanPostProcessorsAfterInitialization
     */
    protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
        if (System.getSecurityManager() != null) {
            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
                @Override
                public Object run() {
                    invokeAwareMethods(beanName, bean);
                    return null;
                }
            }, getAccessControlContext());
        }
        else {
            invokeAwareMethods(beanName, bean);
        }

        Object wrappedBean = bean;
        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);// &lt;=========
        }

        try {
            invokeInitMethods(beanName, wrappedBean, mbd); // 执行初始化方法
        }
        catch (Throwable ex) {
            throw new BeanCreationException(
                    (mbd != null ? mbd.getResourceDescription() : null),
                    beanName, &quot;Invocation of init method failed&quot;, ex);
        }

        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        }
        return wrappedBean;
    }</code></pre>
<p>看到这里的<code>applyBeanPostProcessorsBeforeInitialization</code>熟悉不，长的像啥，就是在<code>initializeBean</code>的方法里面调到了我们定义的处理器<code>MyBeanPostProcessor</code>，<br>可知是先为bean的属性赋值之后再调的处理器</p>
<p>看到了没有，断点在<code>invokeInitMethods(beanName, wrappedBean, mbd);</code>这句话上面，表明先执行我们之前实现的<code>postProcessBeforeInitialization</code>方法里面的内容再来运行之前提到的那些初始化bean的方法</p>
<p>再往下看，<code>applyBeanPostProcessorsAfterInitialization</code>眼熟不，长的像啥，表明先执行之前提到的那些初始化bean的方法之后再来运行我们之前实现的<code>postProcessAfterInitialization</code>方法里面的内容</p>
<pre><code class="java">    @Override
    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result = existingBean;
        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
            result = beanProcessor.postProcessBeforeInitialization(result, beanName);// &lt;=========
            if (result == null) {
                return result;
            }
        }
        return result;
    }</code></pre>
<p>这里逐个遍历了<code>BeanPostProcessor</code>，当前断点里面的这个<code>beanProcessor</code>变量里面的值就是我们之前定义的<code>MyBeanPostProcessor</code>类的对象。这里调用到了<code>postProcessBeforeInitialization</code>方法就是我们实现的那个。</p>
<p>我们还知道了一旦我们实现的<code>postProcessBeforeInitialization</code>方法返回null之后，整个BeanPostProcessor就不会执行后面的其它的beanProcessor了，跳出for循环，直接就返回了</p>
<pre><code class="java">@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;MyBeanPostProcessor:postProcessBeforeInitialization():bean=&quot; + bean + &quot;, beanName=&quot; + beanName);// &lt;=========
        return bean;
    }</code></pre>
<p>最后就进到我打断点的地方了</p>
<h4 id="BeanPostProcessor在Spring底层的使用"><a href="#BeanPostProcessor在Spring底层的使用" class="headerlink" title="BeanPostProcessor在Spring底层的使用"></a><code>BeanPostProcessor</code>在Spring底层的使用</h4><ul>
<li><code>ApplicationContextAwareProcessor</code>: 组件里面注入IOC容器</li>
</ul>
<p>实现一下这个接口：</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class Dog implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Dog() {
        System.out.println(&quot;Dog:constructor()&quot;);
    }

    /**
     * 对象创建并赋值之后调用
     */
    @PostConstruct
    public void init() {
        System.out.println(&quot;Dog:init() by @PostConstruct&quot;);
    }

    /**
     * 容器移除对象之前调用
     */
    @PreDestroy
    public void destroy() {
        System.out.println(&quot;Dog:destroy() by @PreDestroy&quot;);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<p>在Dog这个类里面，重写了<code>setApplicationContext</code>这个方法，我们可以在这个方法里面把获取到的IOC容器对象applicationContext赋值给我们的私有属性，然后就可以在其它需要用到的方法里面调到了</p>
<p>那么它是如何实现这个功能的呢？上源码：</p>
<pre><code class="java">package org.springframework.context.support;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.Aware;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.config.EmbeddedValueResolver;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.EmbeddedValueResolverAware;
import org.springframework.context.EnvironmentAware;
import org.springframework.context.MessageSourceAware;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.util.StringValueResolver;

/**
 * {@link org.springframework.beans.factory.config.BeanPostProcessor}
 * implementation that passes the ApplicationContext to beans that
 * implement the {@link EnvironmentAware}, {@link EmbeddedValueResolverAware},
 * {@link ResourceLoaderAware}, {@link ApplicationEventPublisherAware},
 * {@link MessageSourceAware} and/or {@link ApplicationContextAware} interfaces.
 *
 * &lt;p&gt;Implemented interfaces are satisfied in order of their mention above.
 *
 * &lt;p&gt;Application contexts will automatically register this with their
 * underlying bean factory. Applications do not use this directly.
 *
 * @author Juergen Hoeller
 * @author Costin Leau
 * @author Chris Beams
 * @since 10.10.2003
 * @see org.springframework.context.EnvironmentAware
 * @see org.springframework.context.EmbeddedValueResolverAware
 * @see org.springframework.context.ResourceLoaderAware
 * @see org.springframework.context.ApplicationEventPublisherAware
 * @see org.springframework.context.MessageSourceAware
 * @see org.springframework.context.ApplicationContextAware
 * @see org.springframework.context.support.AbstractApplicationContext#refresh()
 */
class ApplicationContextAwareProcessor implements BeanPostProcessor {

    private final ConfigurableApplicationContext applicationContext;

    private final StringValueResolver embeddedValueResolver;


    /**
     * Create a new ApplicationContextAwareProcessor for the given context.
     */
    public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
        this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
    }


    @Override
    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
        AccessControlContext acc = null;

        if (System.getSecurityManager() != null &amp;&amp;
                (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
                        bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
                        bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
            acc = this.applicationContext.getBeanFactory().getAccessControlContext();
        }

        if (acc != null) {
            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
                @Override
                public Object run() {
                    invokeAwareInterfaces(bean);
                    return null;
                }
            }, acc);
        }
        else {
            invokeAwareInterfaces(bean);
        }

        return bean;
    }

    private void invokeAwareInterfaces(Object bean) {
        if (bean instanceof Aware) {
            if (bean instanceof EnvironmentAware) {
                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
            }
            if (bean instanceof EmbeddedValueResolverAware) {
                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
            }
            if (bean instanceof ResourceLoaderAware) {
                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
            }
            if (bean instanceof ApplicationEventPublisherAware) {
                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
            }
            if (bean instanceof MessageSourceAware) {
                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
            }
            if (bean instanceof ApplicationContextAware) {
                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
            }
        }
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        return bean;
    }

}
</code></pre>
<p>显然它也是一个BeanPostProcessor，我们看<code>postProcessBeforeInitialization</code>方法里面，判断了当前的bean是否实现了该接口，如果实现了就把获取到的applicationContext对象传给bean重写的<code>setApplicationContext</code>方法</p>
<p>也可以debug验证一下，这里就不贴debug的过程了</p>
<ul>
<li><code>BeanValidationPostProcessor</code>: 做数据校验</li>
<li><code>InitDestroyAnnotationBeanPostProcessor</code>: 处理<code>PostConstruct</code>和<code>PreDestroy</code>注解</li>
</ul>
<p>还记得之前讲的使用<code>PostConstruct</code>和<code>PreDestroy</code>注解来使spring调我们自己的方法吗，那两个注解起作用的背后就是<code>InitDestroyAnnotationBeanPostProcessor</code>在操作</p>
<p>话不多说，来debug</p>
<p>下面是方法调用栈</p>
<img src="./idea-debug-MyBeanPostProcessor.postProcessBeforeInitialization-2.png">

<p>这次就不从头开始看了，直接从<code>InitDestroyAnnotationBeanPostProcessor</code>的方法栈开始看</p>
<pre><code class="java">    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass()); //找到dog bean的生命周期注解
        try {
            metadata.invokeInitMethods(bean, beanName);//&lt;=========
        }
        catch (InvocationTargetException ex) {
            throw new BeanCreationException(beanName, &quot;Invocation of init method failed&quot;, ex.getTargetException());
        }
        catch (Throwable ex) {
            throw new BeanCreationException(beanName, &quot;Failed to invoke init method&quot;, ex);
        }
        return bean;
    }</code></pre>
<p>然后用<code>invokeInitMethods</code>执行指定的生命周期的方法</p>
<pre><code class="java">        public void invokeInitMethods(Object target, String beanName) throws Throwable {
            Collection&lt;LifecycleElement&gt; initMethodsToIterate =
                    (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods);
            if (!initMethodsToIterate.isEmpty()) {
                boolean debug = logger.isDebugEnabled();
                for (LifecycleElement element : initMethodsToIterate) {
                    if (debug) {
                        logger.debug(&quot;Invoking init method on bean &#39;&quot; + beanName + &quot;&#39;: &quot; + element.getMethod());
                    }
                    element.invoke(target);//&lt;=========
                }
            }
        }</code></pre>
<p>进到这个invoke方法里面看：</p>
<pre><code class="java">        public void invoke(Object target) throws Throwable {
            ReflectionUtils.makeAccessible(this.method);
            this.method.invoke(target, (Object[]) null);//&lt;=========
        }</code></pre>
<p>可以看到这里调到了java反射里面的method的invoke方法来执行</p>
<ul>
<li><code>AutowiredAnnotationBeanPostProcessor</code>: 用于处理<code>@Autowired</code>注解</li>
</ul>
<h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><h4 id="Value赋值"><a href="#Value赋值" class="headerlink" title="@Value赋值"></a><code>@Value</code>赋值</h4><p>主要功能为用指定的属性来初始化bean的属性</p>
<p>使用方法：</p>
<ul>
<li>直接赋值基本数据类型</li>
<li>使用SpEL表达式<code>#{}</code></li>
<li>可以用<code>${}</code>取出配置文件中的值(环境变量中的值)</li>
</ul>
<pre><code class="java">package org.springframework.beans.factory.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation at the field or method/constructor parameter level
 * that indicates a default value expression for the affected argument.
 *
 * &lt;p&gt;Typically used for expression-driven dependency injection. Also supported
 * for dynamic resolution of handler method parameters, e.g. in Spring MVC.
 *
 * &lt;p&gt;A common use case is to assign default field values using
 * &quot;#{systemProperties.myProp}&quot; style expressions.
 *
 * &lt;p&gt;Note that actual processing of the {@code @Value} annotation is performed
 * by a {@link org.springframework.beans.factory.config.BeanPostProcessor
 * BeanPostProcessor} which in turn means that you &lt;em&gt;cannot&lt;/em&gt; use
 * {@code @Value} within
 * {@link org.springframework.beans.factory.config.BeanPostProcessor
 * BeanPostProcessor} or
 * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}
 * types. Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor}
 * class (which, by default, checks for the presence of this annotation).
 *
 * @author Juergen Hoeller
 * @since 3.0
 * @see AutowiredAnnotationBeanPostProcessor
 * @see Autowired
 * @see org.springframework.beans.factory.config.BeanExpressionResolver
 * @see org.springframework.beans.factory.support.AutowireCandidateResolver#getSuggestedValue
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Value {

    /**
     * The actual value expression: e.g. &quot;#{systemProperties.myProp}&quot;.
     */
    String value();

}
</code></pre>
<pre><code class="java">public class Person {
    /**
     * 直接赋值
     */
    @Value(&quot;张三&quot;)
    private String name;
    /**
     * SpEL表达式
     */
    @Value(&quot;#{20-2}&quot;)
    private Integer age;
    //...
}</code></pre>
<h4 id="PropertySource加载外部配置文件"><a href="#PropertySource加载外部配置文件" class="headerlink" title="@PropertySource加载外部配置文件"></a><code>@PropertySource</code>加载外部配置文件</h4><p>如何使用，先看源码里面的注释有没有说：</p>
<pre><code class="java">package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.core.io.support.PropertySourceFactory;

/**
 * Annotation providing a convenient and declarative mechanism for adding a
 * {@link org.springframework.core.env.PropertySource PropertySource} to Spring&#39;s
 * {@link org.springframework.core.env.Environment Environment}. To be used in
 * conjunction with @{@link Configuration} classes.
 *
 * &lt;h3&gt;Example usage&lt;/h3&gt;
 *
 * &lt;p&gt;Given a file {@code app.properties} containing the key/value pair
 * {@code testbean.name=myTestBean}, the following {@code @Configuration} class
 * uses {@code @PropertySource} to contribute {@code app.properties} to the
 * {@code Environment}&#39;s set of {@code PropertySources}.
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;PropertySource(&quot;classpath:/com/myco/app.properties&quot;)
 * public class AppConfig {
 *     &amp;#064;Autowired
 *     Environment env;
 *
 *     &amp;#064;Bean
 *     public TestBean testBean() {
 *         TestBean testBean = new TestBean();
 *         testBean.setName(env.getProperty(&quot;testbean.name&quot;));
 *         return testBean;
 *     }
 * }&lt;/pre&gt;
 *
 * Notice that the {@code Environment} object is @{@link
 * org.springframework.beans.factory.annotation.Autowired Autowired} into the
 * configuration class and then used when populating the {@code TestBean} object. Given
 * the configuration above, a call to {@code testBean.getName()} will return &quot;myTestBean&quot;.
 *
 * &lt;h3&gt;Resolving ${...} placeholders in {@code &lt;bean&gt;} and {@code @Value} annotations&lt;/h3&gt;
 *
 * In order to resolve ${...} placeholders in {@code &lt;bean&gt;} definitions or {@code @Value}
 * annotations using properties from a {@code PropertySource}, one must register
 * a {@code PropertySourcesPlaceholderConfigurer}. This happens automatically when using
 * {@code &lt;context:property-placeholder&gt;} in XML, but must be explicitly registered using
 * a {@code static} {@code @Bean} method when using {@code @Configuration} classes. See
 * the &quot;Working with externalized values&quot; section of @{@link Configuration}&#39;s javadoc and
 * &quot;a note on BeanFactoryPostProcessor-returning @Bean methods&quot; of @{@link Bean}&#39;s javadoc
 * for details and examples.
 *
 * &lt;h3&gt;Resolving ${...} placeholders within {@code @PropertySource} resource locations&lt;/h3&gt;
 *
 * Any ${...} placeholders present in a {@code @PropertySource} {@linkplain #value()
 * resource location} will be resolved against the set of property sources already
 * registered against the environment. For example:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;PropertySource(&quot;classpath:/com/${my.placeholder:default/path}/app.properties&quot;)
 * public class AppConfig {
 *     &amp;#064;Autowired
 *     Environment env;
 *
 *     &amp;#064;Bean
 *     public TestBean testBean() {
 *         TestBean testBean = new TestBean();
 *         testBean.setName(env.getProperty(&quot;testbean.name&quot;));
 *         return testBean;
 *     }
 * }&lt;/pre&gt;
 *
 * Assuming that &quot;my.placeholder&quot; is present in one of the property sources already
 * registered, e.g. system properties or environment variables, the placeholder will
 * be resolved to the corresponding value. If not, then &quot;default/path&quot; will be used as a
 * default. Expressing a default value (delimited by colon &quot;:&quot;) is optional.  If no
 * default is specified and a property cannot be resolved, an {@code
 * IllegalArgumentException} will be thrown.
 *
 * &lt;h3&gt;A note on property overriding with @PropertySource&lt;/h3&gt;
 *
 * In cases where a given property key exists in more than one {@code .properties}
 * file, the last {@code @PropertySource} annotation processed will &#39;win&#39; and override.
 *
 * For example, given two properties files {@code a.properties} and
 * {@code b.properties}, consider the following two configuration classes
 * that reference them with {@code @PropertySource} annotations:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;PropertySource(&quot;classpath:/com/myco/a.properties&quot;)
 * public class ConfigA { }
 *
 * &amp;#064;Configuration
 * &amp;#064;PropertySource(&quot;classpath:/com/myco/b.properties&quot;)
 * public class ConfigB { }
 * &lt;/pre&gt;
 *
 * The override ordering depends on the order in which these classes are registered
 * with the application context.
 * &lt;pre class=&quot;code&quot;&gt;
 * AnnotationConfigApplicationContext ctx =
 *     new AnnotationConfigApplicationContext();
 * ctx.register(ConfigA.class);
 * ctx.register(ConfigB.class);
 * ctx.refresh();
 * &lt;/pre&gt;
 *
 * In the scenario above, the properties in {@code b.properties} will override any
 * duplicates that exist in {@code a.properties}, because {@code ConfigB} was registered
 * last.
 *
 * &lt;p&gt;In certain situations, it may not be possible or practical to tightly control
 * property source ordering when using {@code @ProperySource} annotations. For example,
 * if the {@code @Configuration} classes above were registered via component-scanning,
 * the ordering is difficult to predict. In such cases - and if overriding is important -
 * it is recommended that the user fall back to using the programmatic PropertySource API.
 * See {@link org.springframework.core.env.ConfigurableEnvironment ConfigurableEnvironment}
 * and {@link org.springframework.core.env.MutablePropertySources MutablePropertySources}
 * javadocs for details.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @since 3.1
 * @see PropertySources
 * @see Configuration
 * @see org.springframework.core.env.PropertySource
 * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()
 * @see org.springframework.core.env.MutablePropertySources
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {

    /**
     * Indicate the name of this property source. If omitted, a name will
     * be generated based on the description of the underlying resource.
     * @see org.springframework.core.env.PropertySource#getName()
     * @see org.springframework.core.io.Resource#getDescription()
     */
    String name() default &quot;&quot;;

    /**
     * Indicate the resource location(s) of the properties file to be loaded.
     * For example, {@code &quot;classpath:/com/myco/app.properties&quot;} or
     * {@code &quot;file:/path/to/file&quot;}.
     * &lt;p&gt;Resource location wildcards (e.g. *&amp;#42;/*.properties) are not permitted;
     * each location must evaluate to exactly one {@code .properties} resource.
     * &lt;p&gt;${...} placeholders will be resolved against any/all property sources already
     * registered with the {@code Environment}. See {@linkplain PropertySource above}
     * for examples.
     * &lt;p&gt;Each location will be added to the enclosing {@code Environment} as its own
     * property source, and in the order declared.
     */
    String[] value();

    /**
     * Indicate if failure to find the a {@link #value() property resource} should be
     * ignored.
     * &lt;p&gt;{@code true} is appropriate if the properties file is completely optional.
     * Default is {@code false}.
     * @since 4.0
     */
    boolean ignoreResourceNotFound() default false;

    /**
     * A specific character encoding for the given resources, e.g. &quot;UTF-8&quot;.
     * @since 4.3
     */
    String encoding() default &quot;&quot;;

    /**
     * Specify a custom {@link PropertySourceFactory}, if any.
     * &lt;p&gt;By default, a default factory for standard resource files will be used.
     * @since 4.3
     * @see org.springframework.core.io.support.DefaultPropertySourceFactory
     * @see org.springframework.core.io.support.ResourcePropertySource
     */
    Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;

}
</code></pre>
<p>显然该注解作用的对象是类，保留到运行时</p>
<p>再看参数：</p>
<ul>
<li><code>String[] value()</code></li>
</ul>
<blockquote>
<p>Indicate the resource location(s) of the properties file to be loaded.</p>
</blockquote>
<p>这个参数用于指定配置文件的路径</p>
<p>实践一下：</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
// 使用@PropertySource读取额外外部配置文件中的k/v保存到运行环境的环境变量中；加载完外部的配置文件后使用${}取出配置文件中的值
@PropertySource(value = {&quot;classpath:/person.properties&quot;}, encoding = &quot;UTF-8&quot;)
@Configuration
public class MainConfigOfPropertyValues {
    @Bean
    public Person person(){
        return new Person();
    }
}
</code></pre>
<p>在Person类中加入一个字段用于赋值properties文件中配置的值：</p>
<pre><code class="java">    @Value(&quot;${person.nickname}&quot;)
    private String nickname;</code></pre>
<p>person.properties：</p>
<pre><code class=".properties">person.nickname=法外狂徒</code></pre>
<p>输出：</p>
<pre><code>mainConfigOfPropertyValues
person
Person{name=&#39;张三&#39;, age=18, nickname=&#39;法外狂徒&#39;}</code></pre><p>值得注意的是这里使用<code>@Value(&quot;${person.nickname}&quot;)</code>获取到的是运行时环境变量中的值，也就是说还可以直接读取运行时环境变量来获取该值</p>
<pre><code class="java">        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        String property = environment.getProperty(&quot;person.nickname&quot;);
        System.out.println(property);</code></pre>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>自动装配：Spring利用依赖注入(DI)来完成对IOC容器中各个组件的依赖关系的赋值</p>
<h4 id="Autowired-amp-Qualifier-amp-Primary"><a href="#Autowired-amp-Qualifier-amp-Primary" class="headerlink" title="@Autowired &amp; @Qualifier &amp; @Primary"></a><code>@Autowired</code> &amp; <code>@Qualifier</code> &amp; <code>@Primary</code></h4><ul>
<li><code>@Autowired</code>: 自动注入<ol>
<li>优先按照容器类型去容器中找对应的组件：等价于<code>applicationContext.getBean(BookService.class)</code>，找到就赋值</li>
<li>如果找到多个相同类型的组件，则将属性名作为组件的id去容器中查找，等价于<code>applicationContext.getBean(&quot;bookDao&quot;)</code></li>
<li>这里若不想将属性名作为组件的id去容器中查找的话可以使用<code>@Qualifier(&quot;bookDao&quot;)</code>注解在属性上来手动指定组件的id</li>
<li>自动装配默认一定要将属性赋值好，没有就报错，除非设置为非必须<code>@Autowired(required = false)</code></li>
<li><code>@Primary</code>让Spring进行自动装配的时候默认使用首选的bean，注：该优先级低于@Qualifier明确指定的优先级</li>
</ol>
</li>
</ul>
<p><code>@Autowired</code>注解大家都用的比较多这里就不贴代码了，简单的测试一下将bookDao注入bookService里，然后从IOT容器中取出bookDao和bookService，通过比较发现bookService里的bookDao对象和IOT容器中的bookDao对象是同一个</p>
<pre><code>BookService{bookDao=com.sicmatr1x.dao.BookDao@25b485ba}
com.sicmatr1x.dao.BookDao@25b485ba</code></pre><h4 id="Resource-amp-Inject"><a href="#Resource-amp-Inject" class="headerlink" title="@Resource &amp; @Inject"></a><code>@Resource</code> &amp; <code>@Inject</code></h4><p>Spring还支持<code>@Resource</code>(定义在JSR250) 和 <code>@Inject</code>(定义在JSR330)，注意这两个注解是java规范里面的注解</p>
<ul>
<li><code>@Resource</code>注解与<code>@Autowired</code>注解类似，可以用于实现自动装配的功能，默认按照组件名称装配</li>
<li><code>@Inject</code>使用此注解需要导入依赖，不支持修改为require=false也不支持@Primary</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/javax.inject/javax.inject --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>使用<code>@Inject</code>注解可能会在日志中输出下面这句话，这句话表面<code>@Inject</code>也支持许多自动装配的特性</p>
<pre><code>INFO: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring</code></pre><h4 id="方法、构造器位置的自动装配"><a href="#方法、构造器位置的自动装配" class="headerlink" title="方法、构造器位置的自动装配"></a>方法、构造器位置的自动装配</h4><p><code>@Autowired</code>可以用在构造器、参数、方法、属性上面，并且注入的bean均是从IOT容器中获取已经托管的bean，以下将会试验并证明这一点</p>
<ol>
<li>将<code>@Autowired</code>标注在set方法上</li>
</ol>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Boss {

    private Car car;

    public Car getCar() {
        return car;
    }

    /**
     * 标注在方法上时，spring容器创建当前对象会调用该方法完成赋值
     * 方法使用的参数，自定义类型的值从IOC容器中获取
     * @param car
     */
    @Autowired
    public void setCar(Car car) {
        this.car = car;
    }

    @Override
    public String toString() {
        return &quot;Boss{&quot; +
                &quot;car=&quot; + car +
                &#39;}&#39;;
    }
}</code></pre>
<p>从IOC容器中get出来看一下是否boss对象里面set进去的car对象就是从IOT容器中获取的那个car对象</p>
<pre><code class="java">        Boss boss = applicationContext.getBean(Boss.class);
        Car car = applicationContext.getBean(Car.class);
        System.out.println(boss);
        System.out.println(car);</code></pre>
<p>输出：</p>
<pre><code>Boss{car=com.sicmatr1x.bean.Car@5b0abc94}
com.sicmatr1x.bean.Car@5b0abc94</code></pre><p>可以看到是同一个car对象</p>
<ol start="2">
<li>将<code>@Autowired</code>标注在构造器上</li>
</ol>
<p>默认加入到IOC容器中的组件，容器在启动时会调用其无参构造器创建对象，再进行初始化赋值等操作</p>
<p>如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Boss {
    private Car car;

    @Autowired
    public Boss(Car car) {
        this.car = car;
        System.out.println(&quot;Boss:constructor()&quot;);
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    @Override
    public String toString() {
        return &quot;Boss{&quot; +
                &quot;car=&quot; + car +
                &#39;}&#39;;
    }
}
</code></pre>
<p>输出：</p>
<pre><code>Car:constructor
Boss:constructor()
Boss{car=com.sicmatr1x.bean.Car@214b199c}
com.sicmatr1x.bean.Car@214b199c</code></pre><p>说明构造器用到的组件也都是从容器中获取</p>
<p>下面这种用法也定价于上面的用法：</p>
<pre><code class="java">    public Boss(@Autowired Car car) {
        this.car = car;
        System.out.println(&quot;Boss:constructor()&quot;);
    }</code></pre>
<p>也可以在构造器上面使用<code>@Bean</code>注解，效果是一样的</p>
<p>如果你的自定义组件想要使用Spring容器底层的一些组件，例如：ApplicationContext, BeanFactory…可以通过自定义组件实现xxxAware的方法</p>
<p>比如之前讲过的Dog类通过实现<code>ApplicationContextAware</code>接口来获取到ApplicationContext对象</p>
<p>这里再看一下<code>ApplicationContextAware</code>接口</p>
<pre><code class="java">public interface ApplicationContextAware extends Aware {
    //...
}</code></pre>
<p>可以看到该类实现了<code>Aware</code>接口，点进去看一下Aware：</p>
<pre><code class="java">package org.springframework.beans.factory;

/**
 * Marker superinterface indicating that a bean is eligible to be
 * notified by the Spring container of a particular framework object
 * through a callback-style method. Actual method signature is
 * determined by individual subinterfaces, but should typically
 * consist of just one void-returning method that accepts a single
 * argument.
 *
 * &lt;p&gt;Note that merely implementing {@link Aware} provides no default
 * functionality. Rather, processing must be done explicitly, for example
 * in a {@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor}.
 * Refer to {@link org.springframework.context.support.ApplicationContextAwareProcessor}
 * and {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory}
 * for examples of processing {@code *Aware} interface callbacks.
 *
 * @author Chris Beams
 * @since 3.1
 */
public interface Aware {

}</code></pre>
<blockquote>
<p>Marker superinterface indicating that a bean is eligible to be notified by the Spring container of a particular framework object through a callback-style method.</p>
</blockquote>
<p>显然这个接口是一个标记接口，其提供了一个回调风格的方法来让你获取到一个特定的 framework object</p>
<p>这里演示几个常用的Aware接口的实现接口：</p>
<pre><code class="java">package com.sicmatr1x.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.EmbeddedValueResolverAware;
import org.springframework.stereotype.Component;
import org.springframework.util.StringValueResolver;

@Component
public class Red implements ApplicationContextAware, BeanNameAware, EmbeddedValueResolverAware {

    private ApplicationContext applicationContext;

    /**
     * BeanNameAware
     * @param name 获取IOC容器创建该对象时给这个对象生成的id
     */
    @Override
    public void setBeanName(String name) {
        System.out.println(&quot;Red:setBeanName():Current bean name=&quot; + name);
    }

    /**
     * ApplicationContextAware
     * @param applicationContext 获取IOC容器对象
     * @throws BeansException
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        System.out.println(&quot;Red:setApplicationContext():applicationContext=&quot; + applicationContext);
        this.applicationContext = applicationContext;
    }

    /**
     * EmbeddedValueResolverAware
     * Set the StringValueResolver to use for resolving embedded definition values.
     * 获取字符串解析器
     * @param resolver
     */
    @Override
    public void setEmbeddedValueResolver(StringValueResolver resolver) {
        String result = resolver.resolveStringValue(&quot;Hello, ${os.name}. #{15*10}&quot;);
        System.out.println(&quot;Red:setEmbeddedValueResolver():result=&quot; + result);
    }
}
</code></pre>
<p>输出：</p>
<pre><code>Red:setBeanName():Current bean name=red
Red:setEmbeddedValueResolver():result=Hello, Windows 10. 150
Red:setApplicationContext():applicationContext=org.springframework.context.annotation.</code></pre><h4 id="Profile环境搭建"><a href="#Profile环境搭建" class="headerlink" title="@Profile环境搭建"></a><code>@Profile</code>环境搭建</h4><p>Spring提供的可以根据当前环境动态激活一系列组件的功能</p>
<p>这里我们拟真一下有3个场的mysql数据源管理：</p>
<p>先在pom.xml中引入数据源包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.mchange&lt;/groupId&gt;
    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
    &lt;version&gt;0.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>创建数据源配置文件dbconfig.properties：</p>
<pre><code class="properties">db.user=root
db.password=123456
db.driverClass=com.mysql.jdbc.Driver</code></pre>
<p>创建数据源配置类：</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.EmbeddedValueResolverAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.util.StringValueResolver;

import javax.sql.DataSource;
import java.beans.PropertyVetoException;

@PropertySource(&quot;classpath:/dbconfig.properties&quot;)
@Configuration
public class MainConfigOfProfile implements EmbeddedValueResolverAware {

    @Value(&quot;${db.user}&quot;)
    private String user;

    private StringValueResolver valueResolver;

    @Bean(&quot;devDataSource&quot;)
    public DataSource dataSourceDev(@Value(&quot;${db.password}&quot;) String pwd) throws PropertyVetoException {
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setUser(user);
        dataSource.setPassword(pwd);
        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/&quot;);
        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);
        return dataSource;
    }

    @Bean(&quot;testDataSource&quot;)
    public DataSource dataSourceTest(@Value(&quot;${db.password}&quot;) String pwd) throws PropertyVetoException {
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setUser(user);
        dataSource.setPassword(pwd);
        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);
        return dataSource;
    }

    @Bean(&quot;prodDataSource&quot;)
    public DataSource dataSourceProd(@Value(&quot;${db.password}&quot;) String pwd) throws PropertyVetoException {
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setUser(user);
        dataSource.setPassword(pwd);
        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/&quot;);
        String driverName = this.valueResolver.resolveStringValue(&quot;${db.driverClass}&quot;);
        dataSource.setDriverClass(driverName);
        return dataSource;
    }

    @Override
    public void setEmbeddedValueResolver(StringValueResolver resolver) {
        this.valueResolver = resolver;
    }
}
</code></pre>
<p>这里用到了<code>@PropertySource</code>读取配置文件，以及el表达式从配置文件里读取配置项</p>
<p>还用到了EmbeddedValueResolverAware来获取<code>StringValueResolver</code></p>
<p>写测试类run一下：</p>
<pre><code class="java">import com.sicmatr1x.bean.Boss;
import com.sicmatr1x.bean.Car;
import com.sicmatr1x.config.MainConfigOfAutowired;
import com.sicmatr1x.config.MainConfigOfProfile;
import com.sicmatr1x.dao.BookDao;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;

public class IOCTest_Profile {

    @Primary
    @Bean
    public BookDao bookDao() {
        return new BookDao();
    }

    @Test
    public void test01(){
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfProfile.class);
        String[] beanNames = applicationContext.getBeanDefinitionNames();
        for (String beanName : beanNames) {
            System.out.println(beanName);
        }
        applicationContext.close();
    }

}
</code></pre>
<p>输出：</p>
<pre><code>mainConfigOfProfile
devDataSource
testDataSource
prodDataSource</code></pre><p>可以看到几个数据源已经正确的添加进来了</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>指在程序运行期间将某段代码切入到指定方法指定位置的进行运行的编程方式。其底层实现是动态代理</p>
<h4 id="AOP功能测试"><a href="#AOP功能测试" class="headerlink" title="AOP功能测试"></a>AOP功能测试</h4><ol>
<li>导入AOP模块</li>
</ol>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<ol start="2">
<li>创建业务逻辑类(MathCalculator)</li>
</ol>
<pre><code class="java">package com.sicmatr1x.aop;

public class MathCalculator {
    public int div(int i, int j) {
        return i/j;
    }
}
</code></pre>
<p>我们希望在业务逻辑运行的时候将日志进行打印</p>
<p>若我们直接在<code>div(int i, int j)</code>方法里面添加打印语句则是一个高耦合的做法</p>
<ol start="3">
<li>定义一个日志切面类(LogAspects), 切面类里面的方法需要可以动态感知<code>div(int i, int j)</code>方法运行状态</li>
</ol>
<p>相当于通知方法：</p>
<ul>
<li>前置通知(@Before)：在目标方法运行之前运行</li>
<li>后置通知(@After)：在目标方法运行之后运行</li>
<li>返回通知(@AfterReturning)：在目标方法正常返回之后运行</li>
<li>异常通知(@AfterThrowing)：在目标方法运行出现异常后运行</li>
<li>环绕通知(@Around)：动态代理，手动推进目标方法运行(<code>joinPoint.procced()</code>)</li>
</ul>
<ol start="4">
<li>给切面类(LogAspects)的目标方法标注何时运行</li>
</ol>
<ul>
<li>@Before(“com.sicmatr1x.aop.MathCalculator.div(int, int)”)：指定具体的需要切入的方法</li>
<li>@Before(“com.sicmatr1x.aop.MathCalculator.*(int, int)”)：切入MathCalculator的所有形参表的方法</li>
<li>@Before(“com.sicmatr1x.aop.MathCalculator.*(..)”)：切入MathCalculator类的所有方法</li>
</ul>
<pre><code class="java">    @Before(&quot;com.sicmatr1x.aop.MathCalculator.*(..)&quot;)
//    @Before(&quot;com.sicmatr1x.aop.MathCalculator.div(int, int)&quot;)
    public void logStart() {
        System.out.println(&quot;div is starting, args:&quot;);
    }</code></pre>
<p>如果多个切入点表达式一样的话可以抽取出来：</p>
<pre><code class="java">package com.sicmatr1x.aop;

import org.aspectj.lang.annotation.*;

/**
 * 切面类
 */
@Aspect
public class LogAspects {

    /**
     * 抽取公共的切入点表达式
     * 1. 本类引用 @Before(&quot;pointCut()&quot;)
     * 2. 其它类引用 @Before(&quot;com.sicmatr1x.aop.LogAspects.pointCut()&quot;)
     */
    @Pointcut(&quot;execution(public int com.sicmatr1x.aop.MathCalculator.*(..))&quot;)
    private void pointCut(){}

    @Before(&quot;pointCut()&quot;)
    public void logStart() {
        System.out.println(&quot;div is starting, args:&quot;);
    }

    @After(&quot;pointCut()&quot;)
    public void logEnd() {
        System.out.println(&quot;div is ending&quot;);
    }

    @AfterReturning(&quot;pointCut()&quot;)
    public void logReturn() {
        System.out.println(&quot;div is return, value:&quot;);
    }

    @AfterThrowing(&quot;pointCut()&quot;)
    public void logException() {
        System.out.println(&quot;div throws exception, error message:&quot;);
    }
}
</code></pre>
<ol start="5">
<li>将切面类LogAspects和业务逻辑类MathCalculator都加入到容器中</li>
</ol>
<p>并使用@EnableAspectJAutoProxy注解开启Spring 基于注解的AOP功能</p>
<pre><code class="java">package com.sicmatr1x.config;

import com.sicmatr1x.aop.LogAspects;
import com.sicmatr1x.aop.MathCalculator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@EnableAspectJAutoProxy
@Configuration
public class MainConfigOfAOP {
    @Bean
    public MathCalculator mathCalculator(){
        return new MathCalculator();
    }

    @Bean
    public LogAspects logAspects(){
        return new LogAspects();
    }
}
</code></pre>
<ol start="6">
<li>告诉Spring哪个类是切面类</li>
</ol>
<p>给切面类加上@Aspect注解即可</p>
<pre><code class="java">@Aspect
public class LogAspects {
    //...
}</code></pre>
<p>编写测试类进行测试：</p>
<pre><code class="java">import com.sicmatr1x.aop.MathCalculator;
import com.sicmatr1x.config.MainConfigOfAOP;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class IOCTest_AOP {
    @Test
    public void test01(){
        // 创建IOC容器
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);

        MathCalculator mathCalculator = new MathCalculator();
        mathCalculator.div(1,1);

        applicationContext.close();
    }
}
</code></pre>
<p>输出结果中并没有输出任何东西，为什么呢，如果你是这样写测试类的话是不会有效果的，因为你使用的是自己new出来的一个MathCalculator对象而不是用脱光到IOT容器中的那个对象</p>
<pre><code class="java">import com.sicmatr1x.aop.MathCalculator;
import com.sicmatr1x.config.MainConfigOfAOP;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class IOCTest_AOP {
    @Test
    public void test01(){
        // 创建IOC容器
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);
        // 自己new的对象没有AOP功能
//        MathCalculator mathCalculator = new MathCalculator();
//        mathCalculator.div(1,1);

        // 从Spring容器中的对象才有AOP功能
        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);
        mathCalculator.div(1,1);

        applicationContext.close();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>div is starting, args:
div is ending
div is return, value:</code></pre><p>可以看到切面执行顺序是@Before, @After, @AfterReturning</p>
<p>刚刚忘记写输出args:的代码了，我们再来升级一下切面类</p>
<pre><code class="java">package com.sicmatr1x.aop;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;

/**
 * 切面类
 */
@Aspect
public class LogAspects {

    /**
     * 抽取公共的切入点表达式
     * 1. 本类引用 @Before(&quot;pointCut()&quot;)
     * 2. 其它类引用 @Before(&quot;com.sicmatr1x.aop.LogAspects.pointCut()&quot;)
     */
    @Pointcut(&quot;execution(public int com.sicmatr1x.aop.MathCalculator.*(..))&quot;)
    private void pointCut(){}

    @Before(&quot;pointCut()&quot;)
    public void logStart(JoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        System.out.print(joinPoint.getSignature().getName() + &quot; div is starting, args:&quot;);
        for(Object arg: args) {
            System.out.print(arg + &quot;,&quot;);
        }
        System.out.println();
    }

    @After(&quot;pointCut()&quot;)
    public void logEnd(JoinPoint joinPoint) {
        System.out.println(joinPoint.getSignature().getName() + &quot; div is ending&quot;);
    }

    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)
    public void logReturn(Object result) {
        System.out.println(&quot;div is return, value:&quot; + result);
    }

    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;exception&quot;)
    public void logException(Exception exception) {
        System.out.println(&quot;div throws exception, error message:&quot;);
    }
}
</code></pre>
<p>输出：</p>
<pre><code>div div is starting, args:1,1,
div div is ending
div is return, value:1</code></pre><h4 id="AOP原理解析-EnableAspectJAutoProxyCreator"><a href="#AOP原理解析-EnableAspectJAutoProxyCreator" class="headerlink" title="AOP原理解析 @EnableAspectJAutoProxyCreator"></a>AOP原理解析 <code>@EnableAspectJAutoProxyCreator</code></h4><p>从上述AOP demo可以看出关键的一步是给spring开启AOP功能，所以我们先从这里开始看</p>
<p>点进@EnableAspectJAutoProxy注解看源码：</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {

    /**
     * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
     * to standard Java interface-based proxies. The default is {@code false}.
     */
    boolean proxyTargetClass() default false;

    /**
     * Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal}
     * for retrieval via the {@link org.springframework.aop.framework.AopContext} class.
     * Off by default, i.e. no guarantees that {@code AopContext} access will work.
     * @since 4.3.1
     */
    boolean exposeProxy() default false;

}</code></pre>
<p>可以看到这里用到了一个叫AspectJAutoProxyRegistrar的类：</p>
<pre><code class="java">/**
 * Registers an {@link org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator
 * AnnotationAwareAspectJAutoProxyCreator} against the current {@link BeanDefinitionRegistry}
 * as appropriate based on a given @{@link EnableAspectJAutoProxy} annotation.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.1
 * @see EnableAspectJAutoProxy
 */
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

    /**
     * Register, escalate, and configure the AspectJ auto proxy creator based on the value
     * of the @{@link EnableAspectJAutoProxy#proxyTargetClass()} attribute on the importing
     * {@code @Configuration} class.
     */
    @Override
    public void registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

        AnnotationAttributes enableAspectJAutoProxy =
                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
        if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
        }
        if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
        }
    }

}</code></pre>
<p>可以看到AspectJAutoProxyRegistrar这个类是一个ImportBeanDefinitionRegistrar接口的实现</p>
<p>我们之前也实现过这个接口，实现类<code>MyImportBeanDefinitionRegistrar</code>，我们当时使用的功能是判断容器中有没有指定的bean，若有则再注册一个给定的bean到容器中</p>
<p>打个断点从<code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</code>这里进入，看下注册了啥</p>
<pre><code class="java">    private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) {
        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
        if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
            BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
            if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
                int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
                int requiredPriority = findPriorityForClass(cls);
                if (currentPriority &lt; requiredPriority) {
                    apcDefinition.setBeanClassName(cls.getName());
                }
            }
            return null;
        }
        RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
        beanDefinition.setSource(source);
        beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);
        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
        return beanDefinition;
    }</code></pre>
<p>显然这里向容器中注册了一个ID为<code>AUTO_PROXY_CREATOR_BEAN_NAME=org.springframework.aop.config.internalAutoProxyCreator</code>的bean</p>
<pre><code class="java">        AnnotationAttributes enableAspectJAutoProxy =
                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
        if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
        }
        if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
        }</code></pre>
<p>然后它拿了@EnableAspectJAutoProxy注解的信息并判断其属性proxyTargetClass, exposeProxy的值，并做相应的操作</p>
<p>总结：在使用了@EnableAspectJAutoProxy注解之后发生了以下的事情</p>
<ol>
<li><code>@Import(AspectJAutoProxyRegistrar.class)</code>给容器中导入了AspectJAutoProxyRegistrar</li>
<li>利用AspectJAutoProxyRegistrar类自定义给容器中注册bean</li>
<li>internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator</li>
<li>给容器中注册一个AnnotationAwareAspectJAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator：<ul>
<li>AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator<ul>
<li>AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator<ul>
<li>AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator<ul>
<li>AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator<ul>
<li>AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</li>
<li>关注后置处理器(在bean初始化完成前后做的事情)；自动装配BeanFactoryAware</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>还是从测试类开始走断点：</p>
<pre><code class="java">import com.sicmatr1x.aop.MathCalculator;
import com.sicmatr1x.config.MainConfigOfAOP;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class IOCTest_AOP {
    @Test
    public void test01(){
        // 创建IOC容器
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class); // &lt;========= 传入配置类，创建IOC容器
        // 从Spring容器中的对象才有AOP功能
        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);
        mathCalculator.div(1,1);

        applicationContext.close();
    }
}</code></pre>
<pre><code class="java">    public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {
        this();
        register(annotatedClasses);
        refresh(); // &lt;========= 调用refresh()刷新容器
    }</code></pre>
<pre><code class="java">                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory); // &lt;========= 注册bean的后置处理器来方便拦截bean的创建</code></pre>
<ol>
<li>传入配置类，创建IOC容器</li>
<li>调用<code>refresh()</code>刷新容器</li>
<li><code>registerBeanPostProcessors(beanFactory)</code>注册bean的后置处理器来方便拦截bean的创建<ol>
<li>先获取IOC容器已经定义了的需要创建对象的所有的BeanPostProcessor</li>
<li>给容器中加别的BeanPostProcessor</li>
<li>优先注册实现了PriorityOrdered接口的BeanPostProcessor</li>
<li>再给容器中注册实现了Ordered接口的BeanPostProcessor</li>
<li>注册没实现优先级接口的BeanPostProcessor</li>
<li>注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，并保存到容器中：创建internalAutoProxyCreator的BeanPostProcessor<ol>
<li>创建Bean的实例</li>
<li>populateBean：给bean的各种属性赋值</li>
<li>initializeBean：初始化bean：</li>
<li>invokeAwareMethods()：处理各种Aware接口的方法回调</li>
<li>applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessorsBeforeInitialization()方法</li>
<li>invokeInitMethods()：执行自定义的初始化方法</li>
<li>applyBeanPostProcessorsAfterInitialization()：执行后置处理器的postProcessorsAfterInitialization()方法</li>
<li>BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="扩展原理"><a href="#扩展原理" class="headerlink" title="扩展原理"></a>扩展原理</h2><!-- TODO: -->

<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><!-- TODO: -->
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Nginx"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/10/Nginx/"
    >Nginx</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/04/10/Nginx/" class="article-date">
  <time datetime="2020-04-10T01:43:00.000Z" itemprop="datePublished">2020-04-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>在客户端(浏览器)中配置代理服务器，通过代理服务器进行互联网访问。</p>
<h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><h4 id="pcre"><a href="#pcre" class="headerlink" title="pcre"></a>pcre</h4><p>解压pcre压缩包，进入目录执行</p>
<pre><code>./configure

make &amp;&amp; make install</code></pre><p>查看版本号</p>
<pre><code>pcre-config --version</code></pre><h4 id="zlib与openssl"><a href="#zlib与openssl" class="headerlink" title="zlib与openssl"></a>zlib与openssl</h4><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code></pre><h4 id="或者使用yum一键安装上述3个依赖"><a href="#或者使用yum一键安装上述3个依赖" class="headerlink" title="或者使用yum一键安装上述3个依赖"></a>或者使用<code>yum</code>一键安装上述3个依赖</h4><pre><code>yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</code></pre><h4 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h4><p>解压nginx压缩包，进入目录执行</p>
<pre><code>./configure

make &amp;&amp; make install</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>cd /usr/local/nginx</code></pre><p>nginx的启动脚本在<code>nginx/sbin</code>文件夹下面</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>cd /usr/local/nginx/sbin
./nginx

ps -ef | grep nginx</code></pre><h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>查看防火墙规则：</p>
<pre><code>firewall-cmd --list-all</code></pre><p>添加规则：</p>
<pre><code>firewall-cmd --add-service=http =permanent
sudo firewall-cmd --add-port=80/tcp --permanent</code></pre><p>重启防火墙：</p>
<pre><code>firewall-cmd -reload</code></pre><h2 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h2><p>进入nginx根目录或者将其添加到<code>PATH</code></p>
<pre><code>cd /usr/local/nginx/sbin</code></pre><h4 id="查看nginx版本号"><a href="#查看nginx版本号" class="headerlink" title="查看nginx版本号"></a>查看nginx版本号</h4><pre><code>./nginx -v</code></pre><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><pre><code>./nginx</code></pre><h4 id="关闭nginx"><a href="#关闭nginx" class="headerlink" title="关闭nginx"></a>关闭nginx</h4><pre><code>./nginx -s stop</code></pre><h4 id="重新加载nginx"><a href="#重新加载nginx" class="headerlink" title="重新加载nginx"></a>重新加载nginx</h4><p><code>nginx.conf</code>文件内容修改后需要重新加载才能生效，此命令可以使得在不重启nginx情况下应用修改</p>
<pre><code>./nginx -s reload</code></pre><h2 id="配置文件nginx-conf"><a href="#配置文件nginx-conf" class="headerlink" title="配置文件nginx.conf"></a>配置文件<code>nginx.conf</code></h2><pre><code>cd /usr/local/nginx/conf</code></pre><p>配置文件由3部分组成：</p>
<ol>
<li>全局块：从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令</li>
<li>events块：主要影响nginx服务器与用户的网络连接，常用的设置包括是否开启对多worker processes下的网络连接进行序列化，是否允许同时接受多个网络连接，选取暗中事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等</li>
<li>http块：包含http全局块和server块，代理、缓存和日志等绝大多数功能和第三方模块的配置都在这里<ul>
<li>http全局块：包括文件引入、MIME-TYPE协议、日志自定义、连接超时时间、单链接请求数上限等</li>
<li>server块：包含全局server块和location块，和虚拟主机有密切关系，虚拟主机从用户角度看和一台独立的硬件主机完全一样，该技术主要用于节省互联网服务器硬件成本<ul>
<li>全局server块：最常见的配置是虚拟主机的监听配置和本虚拟主机的名称或IP配置</li>
<li>location块：一个server块可以配置多个location块，这个块的主要作用是基于nginx服务器收到的请求字符串(例如：server_name/uri-string)，对虚拟主机名称(或IP别名)之外的字符串(例如：/uri-string)进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><pre><code class="conf">#user  nobody;
worker_processes  1; #nginx服务器并发处理关键配置，worker_processes值越大，可以支持的并发处理量越多，但是受硬件、软件等设备制约

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;</code></pre>
<h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><pre><code class="conf">events {
    worker_connections  1024; #表示每个worker processes支持的最大连接数为1024
}</code></pre>
<h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><pre><code class="conf">http {
    # http全局块
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server { # server块
        listen       80; # 目前监听端口号
        server_name  localhost; # 主机名称

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache&#39;s document root
        # concurs with nginx&#39;s one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}</code></pre>
<h4 id="location指令说明"><a href="#location指令说明" class="headerlink" title="location指令说明"></a>location指令说明</h4><p>该指令用于匹配URL</p>
<p>语法如下：</p>
<ol>
<li><code>=</code>: 用于不含正则表达式的URI前，要求请求字符串与URI严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求</li>
<li><code>~</code>: 用于表示URI包含正则表达式，并且区分大小写</li>
<li><code>~*</code>: 用于表示URI包含正则表达式，并且不区分大小写</li>
<li><code>^~</code>: 用于不含正则表达式的URI前，要求Nginx服务器找到标识URI和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则URI和请求字符串做匹配</li>
</ol>
<h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><h3 id="反向代理实例"><a href="#反向代理实例" class="headerlink" title="反向代理实例"></a>反向代理实例</h3><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><p>实现效果：浏览器输入网址<a href="http://www.123.com跳转到本地Tomcat页面" target="_blank" rel="noopener">www.123.com跳转到本地Tomcat页面</a></p>
<p>下载并解压Tomcat，进入bin目录启动Tomcat</p>
<pre><code>./startup.sh</code></pre><p>开放端口</p>
<pre><code>sudo firewall-cmd --add-port=8080/tcp --permanent
firewall-cmd -reload
firewall-cmd --list-all</code></pre><p>修改配置文件</p>
<pre><code class="conf">server {
    listen 80;
    server_name www.123.com;

    location / {
        proxy_pass http://www.123.com:8080;
        index index.html index.htm index.jsp;
    }
}</code></pre>
<h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><p>实现效果：根据访问的路径跳转到不同端口的服务中</p>
<ul>
<li>访问<a href="http://127.0.0.1:9001/edu" target="_blank" rel="noopener">http://127.0.0.1:9001/edu</a> 直接跳转到127.0.0.1:8080</li>
<li>访问<a href="http://127.0.0.1:9001/vod" target="_blank" rel="noopener">http://127.0.0.1:9001/vod</a> 直接跳转到127.0.0.1:8081</li>
</ul>
<pre><code class="conf">server {
    listen 9001;
    server_name localhost;

    location ~ /edu/ { # ~符号表示后接正则表达式，表示访问的路径中包含edu字符串就跳转到8080
        proxy_pass http://localhost:8080;
    }
    location ~ /vod/ {
        proxy_pass http://localhost:8081;
    }
}</code></pre>
<h3 id="负载均衡实例"><a href="#负载均衡实例" class="headerlink" title="负载均衡实例"></a>负载均衡实例</h3><p>实现效果：通过浏览器的地址栏输入地址(<a href="http://localhost/edu/a.html)，使得请求平均分配到8080与8081端口中" target="_blank" rel="noopener">http://localhost/edu/a.html)，使得请求平均分配到8080与8081端口中</a></p>
<p>关键配置：</p>
<pre><code class="conf">http {
    #.....
    upstream myserver {
        ip_hash;
        server 192.168.17.129:8080 weight=1;
        server 192.168.17.129:8081 weight=1;
    }
    #.....
    server {
        location / {
            #.....
            proxy_pass http://myserver;
            proxy_connect_timeout 10;
        }
    }
}</code></pre>
<p>配置案例：</p>
<pre><code class="conf">
worker_processes  1;


events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    upstream myserver {
        ip_hash;
        server 192.168.17.129:8080 weight=1;
        server 192.168.17.129:8081 weight=1;
    }

    server {
        listen       80;
        server_name  192.168.17.129;

        location / {
            proxy_pass http://myserver;
            proxy_connect_timeout 10;
            root   html
            index index.html index.htm
        }
    }
}
</code></pre>
<h3 id="负载均衡的分配方式"><a href="#负载均衡的分配方式" class="headerlink" title="负载均衡的分配方式"></a>负载均衡的分配方式</h3><ol>
<li>轮询(默认)：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</li>
<li>weight：权重，weight和访问比率成正比，用于后端服务器性能不均的情况，例如：<ul>
<li>A服务器<code>weight=5</code>，B服务器<code>weight=10</code>，则B会收到的流量为A的一倍，即A会收到全部流量的1/3，B为2/3</li>
</ul>
</li>
<li>ip_hash：每个请求按IP的hash结果分配，每个访客固定访问一个后端服务器，可以解决session的问题</li>
<li>fair: 按照后端服务器的访问时间来分配，时间短的优先分配</li>
</ol>
<pre><code class="conf">upstream myserver {
    server 192.168.17.129:8080;
    server 192.168.17.129:8081;
}</code></pre>
<pre><code class="conf">upstream myserver {
    server 192.168.17.129:8080 weight=5;
    server 192.168.17.129:8081 weight=10;
}</code></pre>
<pre><code class="conf">upstream myserver {
    ip_hash;
    server 192.168.17.129:8080;
    server 192.168.17.129:8081;
}</code></pre>
<pre><code class="conf">upstream myserver {
    server 192.168.17.129:8080;
    server 192.168.17.129:8081;
    fair;
}</code></pre>
<h3 id="动静分离实例"><a href="#动静分离实例" class="headerlink" title="动静分离实例"></a>动静分离实例</h3><p>通过<code>location</code>指定不同的后缀名实现不同的请求转发。通过<code>expires</code>参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p>
<p><code>Expores</code>：给一个资源设定一个过期时间，无需服务器端验证，而是由浏览器去确认该资源是否过期，不会产生额外的流量。适用于不经常变动的资源。比如设置为<code>3d</code>表示3天之内访问这个URL，浏览器会发送一个请求来对比服务器该文件最后更新时间有无变化，若无则不会从服务器抓取，返回状态码<code>304</code>，如果有修改则直接从服务器下载，返回状态码<code>200</code></p>
<p>实现效果：</p>
<ol>
<li>浏览器中输入地址<a href="http://192.168.17.129/image/01.jpg" target="_blank" rel="noopener">http://192.168.17.129/image/01.jpg</a></li>
<li>浏览器中输入地址<a href="http://192.168.17.129/www/a.html" target="_blank" rel="noopener">http://192.168.17.129/www/a.html</a></li>
</ol>
<p>文件结构：</p>
<ul>
<li>data<ul>
<li>image<ul>
<li>01.jpg</li>
</ul>
</li>
<li>www<ul>
<li>a.html</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="conf">worker_processes  1;


events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    server {
        listen       80;
        server_name  192.168.17.129;

        location /www/ {
            root /data/;
            index index.html index.htm
        }

        location /image/ {
            root /data/;
            autoindex on; # 在浏览器中列出当前文件夹中的内容
        }
    }
}</code></pre>
<h2 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h2><p>多台Nginx同时工作，若其中一台宕机服务不会中断。</p>
<p>需要：</p>
<ol>
<li>2台服务器192.168.17.129, 192.168.17.131</li>
<li>两台服务器安装Nginx</li>
<li>两台服务器安装keepalived</li>
</ol>
<pre><code>yum install keepalived -y</code></pre><p>配置文件<code>/etc/keepalive.conf</code>：</p>
<pre><code class="conf">#全局配置
global_defs { 
    notification_email {
        acassen@firewall.loc
        failover@firewall.loc
        sysadmin@firewall.loc
    }
    notification_email from Alexandre.Cassen@firewall.loc
    smtp_server 192.168.17.129
    smtp_connect timeout 30
    router_id LVS_DEVEL # 唯一取值，可写服务器名字(配置在hosts里的domian)也可写IP
}

# 脚本配置
vrrp_script chk_http_port {
    script &quot;/usr/local/src/nginx_check.sh&quot; # 检测脚本路径
    interval 2 # 检测脚本执行间隔
    weight 2 # 权重参数
}

vrrp_instance VI_1 {
    state BACKUP # 备份服务器上将MASTER改为BACKUP
    interface ens33 # 网卡
    virtual_router_id 51 # 主、备机的virtual_router_id 必须相同
    priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小
    advert_int 1 # 时间间隔，每隔多久发送一个心跳，单位秒
    authentication { # 权限校验方式
        auth_type PASS # 类型：密码
        auth_pass 1111 # 密码值
    }
    virtual_ipaddress {
        192.168.17.50 # VRRP H虚拟地址
    }
}</code></pre>
<p>检测脚本<code>/usr/local/src/nginx_check.sh</code>：</p>
<pre><code class="sh">#!/bin/bash
A=`ps -C nginx -no-header |wc -l`
if [ $A -eq 0 ]; then
    /usr/local/nginx/sbin/nginx
    sleep 2
    if [ `ps -C nginx -no-header |wc -l` -eq 0 ]; then
        killall keepalived
    fi
fi</code></pre>
<p>查看网卡名：</p>
<pre><code>ifconfig</code></pre><h2 id="Nginx原理分析"><a href="#Nginx原理分析" class="headerlink" title="Nginx原理分析"></a>Nginx原理分析</h2><h3 id="master-和-worker"><a href="#master-和-worker" class="headerlink" title="master 和 worker"></a>master 和 worker</h3><p>Nginx启动之后在Linux系统中其实有两个进程，分别叫<code>nginx: master</code>, <code>nginx: worker</code></p>
<p>当客户端发送一条请求给master之后，然后由worker来争抢该条请求，当worker抢到之后变进行请求转发或反向代理给Tomcat来响应请求</p>
<p>一个master和多个worker的好处：</p>
<ol>
<li>可以使用<code>nginx -s reload</code>热部署。在进行热部署时，已经在执行任务的worker继续执行，没有任务的worker重新加载，有任务的worker任务执行完毕后再加载新配置文件。</li>
<li>对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销。</li>
<li>独立的进程互相之间不会相互影响，一个进程退出后，其它的进程还在工作，服务不会中断。若单个worker进程遇到异常退出了，会导致当前worker上的所有请求失败，不会影响到其它worker在处理的请求。</li>
</ol>
<h4 id="需要设置多少个worker"><a href="#需要设置多少个worker" class="headerlink" title="需要设置多少个worker"></a>需要设置多少个worker</h4><p>Nginx和redis类似都采用了io多路复用机制，每个worker都是一个独立的进程，但每个进程只有一个主线程，通过异步非阻塞的方式来处理请求。每个worker的线程可以把一个cpu的性能发挥到极致。所以worker数和服务器的cpu核数相等是最为适宜的。设少了浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。</p>
<h2 id="反向代理配置文件案例"><a href="#反向代理配置文件案例" class="headerlink" title="反向代理配置文件案例"></a>反向代理配置文件案例</h2><pre><code class="conf">
#user  nobody;
worker_processes  1; # nginx服务器并发处理关键配置，worker_processes值越大，可以支持的并发处理量越多，但是受硬件、软件等设备制约

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024; # 表示每个worker processes支持的最大连接数为1024
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    server_names_hash_max_size 512;
    server_names_hash_bucket_size 1024;

    #gzip  on;

    # upstream 负载均衡关键配置
    # The ngx_http_upstream_module module is used to define groups of servers that can be referenced by the proxy_pass, fastcgi_pass, uwsgi_pass, scgi_pass, memcached_pass, and grpc_pass directives.
    # 定义server用于给后面的proxy_pass使用
    # 参考：https://blog.csdn.net/caijunsen/article/details/83002219
    upstream www-pixiv-net { 
        # 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除
        server 210.140.131.223:443;
        server 210.140.131.225:443;
        server 210.140.131.220:443;
    }

    upstream sketch-pixiv-net { 
        server 210.140.174.37:443;
        server 210.140.170.179:443;
        server 210.140.175.130:443;
    }

    upstream sketch-hls-server {
        server 210.140.214.211:443;
        server 210.140.214.212:443;
        server 210.140.214.213:443;
    }

    upstream imgaz-pixiv-net { 
        server 210.140.131.145:443;
        server 210.140.131.144:443;
        server 210.140.131.147:443;
        server 210.140.131.153:443;
    }

    upstream i-pximg-net { 
        server 210.140.92.140:443;
        server 210.140.92.137:443;
        server 210.140.92.139:443;
        server 210.140.92.142:443;
        server 210.140.92.134:443;
        server 210.140.92.141:443;
        server 210.140.92.143:443;
        server 210.140.92.136:443; 
        server 210.140.92.138:443;
        server 210.140.92.144:443;
        server 210.140.92.145:443;
    }

    server {
        listen 80 default_server; # default_server 指令可以定义默认的 server 去处理一些没有匹配到 server_name 的请求，如果没有显式定义，则会选取第一个定义的 server 作为 default_server
        rewrite ^(.*) https://$host$1 permanent; # 网站添加了https证书后，当http方式访问网站时就会报404错误，所以需要做http到https的强制跳转设置
        # rewrite语法：
        # rewrite    &lt;regex&gt;    &lt;replacement&gt;    [flag];
        # 关键字      正则        替代内容          flag标记
        # 关键字：其中关键字error_log不能改变
        # 正则：perl兼容正则表达式语句进行规则匹配
        # 替代内容：将正则匹配的内容替换成replacement
        # flag标记：rewrite支持的flag标记
        # flag标记说明：
        # last: 本条规则匹配完成后，继续向下匹配新的location URI规则
        # break: 本条规则匹配完成即终止，不再匹配后面的任何规则
        # redirect: 返回302临时重定向，浏览器地址会显示跳转后的URL地址
        # permanent: 返回301永久重定向，浏览器地址栏会显示跳转后的URL地址

        # rewrite的组要功能是实现URL地址的重定向。Nginx的rewrite功能需要PCRE软件的支持，即通过perl兼容正则表达式语句进行规则匹配的。默认参数编译nginx就会支持rewrite的模块，但是也必须要PCRE的支持
    }

    server {
        listen 443 ssl; # 443是https的默认端口
        server_name pixiv.net; # server name 为虚拟服务器的识别路径。因此不同的域名会通过请求头中的HOST字段，匹配到特定的server块，转发到对应的应用服务器中去
        server_name www.pixiv.net;
        server_name ssl.pixiv.net;
        server_name accounts.pixiv.net;
        server_name touch.pixiv.net;
        server_name oauth.secure.pixiv.net;

        ssl on; # 使用HTTPS，需要安装OpenSSL
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key; # HTTPS私钥

        client_max_body_size 50M; # 用nginx作代理服务器，上传大文件的大小有限制(限制请求体的大小，若超过所设定的大小，返回413错误)

        location / {
            proxy_pass https://www-pixiv-net;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off; # 主要是实现被代理服务器的数据和客户端的请求异步
            # A为客户端，B为代理服务器，C为被代理服务器。
            # 当proxy_buffering开启，A发起请求到B，B再到C，C反馈的数据先到B的buffer上，
            # 然后B会根据proxy_busy_buffer_size来决定什么时候开始把数据传输给A。
            # 在此过程中，如果所有的buffer被写满，数据将会写入到temp_file中。
            # 相反，如果proxy_buffering关闭，C反馈的数据实时地通过B传输给A。
        }
    }

    server {
        listen 443 ssl;
        server_name i.pximg.net;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://i-pximg-net;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    server {
        listen 443 ssl;
        server_name sketch.pixiv.net;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://sketch-pixiv-net;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }

        # Proxying WebSockets
        location /ws/ {
            proxy_pass https://sketch-pixiv-net;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
            proxy_set_header Host $host;
        }
    }

    server {
        listen 443 ssl;
        server_name *.pixivsketch.net;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://sketch-hls-server;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    server {
        listen 443 ssl;
        server_name factory.pixiv.net;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://210.140.131.180/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    server {
        listen 443 ssl;
        server_name dic.pixiv.net;
        server_name en-dic.pixiv.net;
        server_name sensei.pixiv.net;
        server_name fanbox.pixiv.net;
        server_name payment.pixiv.net.pixiv.net;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://210.140.131.222/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    server {
        listen 443 ssl;
        server_name imgaz.pixiv.net;
        server_name comic.pixiv.net;
        server_name novel.pixiv.net;
        server_name source.pixiv.net;
        server_name i1.pixiv.net;
        server_name i2.pixiv.net;
        server_name i3.pixiv.net;
        server_name i4.pixiv.net;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://imgaz-pixiv-net;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    upstream wikipedia-server { 
        server 198.35.26.96:443;
        server 103.102.166.224:443;
    }

    server {
        listen 443 ssl;
        server_name *.wikipedia.org;
        server_name *.m.wikipedia.org;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://wikipedia-server/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    server {
        listen 443 ssl;
        server_name *.steamcommunity.com;
        server_name steamcommunity.com;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://23.61.176.149/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

    server {
        listen 443 ssl;
        server_name *.steampowered.com;
        server_name steampowered.com;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://104.112.84.145/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }
        server {
        listen 443 ssl;
        server_name *.archiveofourown.org;
        server_name archiveofourown.org;

        ssl on;
        ssl_certificate ca/pixiv.net.crt;
        ssl_certificate_key ca/pixiv.net.key;

        location / {
            proxy_pass https://104.153.64.122/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Real_IP $remote_addr;
            proxy_set_header User-Agent $http_user_agent;
            proxy_set_header Accept-Encoding &#39;&#39;; 
            proxy_buffering off;
        }
    }

}
</code></pre>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://www.digitalocean.com/community/tools/nginx" target="_blank" rel="noopener">The easiest way to configure a performant, secure, and stable NGINX server.</a></li>
<li><a href="https://2heng.xin/2017/09/19/pixiv/" target="_blank" rel="noopener">PIXIV网页版及客户端访问恢复指南</a></li>
<li><a href="http://idayer.com/nginx-reverse-proxy-for-pixiv/" target="_blank" rel="noopener">MAC本地nginx反向代理访问Pixiv指北</a></li>
<li><a href="https://moe.best/technology/pixiv-proxy.html" target="_blank" rel="noopener">Nginx 真·反代P站 恢复直接访问</a></li>
<li><a href="https://www.digitalocean.com/community/tools/nginx" target="_blank" rel="noopener">NGINX Config The easiest way to configure a performant, secure, and stable NGINX server.</a></li>
<li></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Sicmatr1x
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Sicmatr1x"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>