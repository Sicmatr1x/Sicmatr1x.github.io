<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sicmatr1x</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-03-05T10:42:20.703Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sicmatr1x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java后端速查表</title>
    <link href="http://yoursite.com/2023/01/20/Java%E5%90%8E%E7%AB%AF%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://yoursite.com/2023/01/20/Java%E5%90%8E%E7%AB%AF%E9%80%9F%E6%9F%A5%E8%A1%A8/</id>
    <published>2023-01-20T02:04:40.000Z</published>
    <updated>2023-03-05T10:42:20.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java后端"><a href="#Java后端" class="headerlink" title="Java后端"></a>Java后端</h1><h3 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h3><ul><li>JDK(Java Development Kit)</li><li>JRE(Java Runtime Environment)</li></ul><p>面向对象三大特征:</p><ol><li>封装: 封装是指把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li><li>继承: 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。提高代码的重用，程序的可维护性</li><li>多态: 表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</li></ol><p>Java 和 C++的区别</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li></ul><p>为什么说 Java 语言编译与解释并存？</p><ul><li>编译型语言: 是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码</li><li>解释型语言: 是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</li><li>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。</li></ul><p>为什么重写<code>equals()</code>时必须重写<code>hashCode()</code>方法？</p><ul><li>两个对象调用 equals 方法返回 true, 那么调用 hashCode 返回的值也必须一样</li><li>反之 hashCode 返回值一样 equals 可以返回 false，这种情况为哈希碰撞</li></ul><p>重载(Overload)和重写(<code>@Override</code>)的</p><ul><li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</li><li>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</li></ul><p>深拷贝 vs 浅拷贝</p><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ul><h3 id="Java基本类"><a href="#Java基本类" class="headerlink" title="Java基本类"></a>Java基本类</h3><p>异常(Throwable)： </p><ul><li>Exception（异常）：是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。<ul><li>RuntimeException<ul><li>例如：ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）</li></ul></li></ul></li><li>Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。表示代码运行时 JVM（Java 虚拟机）出现的问题。<ul><li>例如：当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li></ul><p><code>java.util.HashMap</code></p><ul><li>JDK1.7: 数组+单链表 链地址法</li><li>JDK1.8: 数组+单链表+红黑树(当链表的深度达到8的时候，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O(n)变成O(logN)提高了效率)</li><li>put操作的流程：<ol><li><code>key.hashcode()</code>，时间复杂度O(1)</li><li>找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)</li><li>如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(n)</li><li>如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(logn)</li></ol></li></ul><p><code>java.util.concurrent.ConcurrentHashMap</code></p><ul><li>采用了分段锁技术</li><li>JDK7采用Segment分段锁(默认16个Segment)</li><li>JDK8改成了CAS+synchronized(这里只加锁在hashmap中的一个元素上面)</li><li>理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment</li><li>put():</li></ul><ol><li>通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put</li><li>尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁</li><li>重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取</li><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry</li><li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li><li>释放当前 Segment 的锁</li></ol><ul><li>get():</li></ul><ol><li>Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值</li></ol><h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>传统拷贝流程(下载文件为例):</p><ul><li>磁盘 -&gt; 内核缓冲区 -&gt; 用户缓冲区 -&gt; 网络堆栈相关的内核缓冲区 -&gt; 网卡</li><li>DMA从磁盘读取文件到内核缓冲区 -&gt; CPU从内核缓冲区拷贝到用户缓冲区 -&gt; 应用程序调write系统调用把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区 -&gt; socket把内核缓冲区的内容发送到网卡上</li></ul><p>零拷贝(下载文件为例):</p><ul><li>磁盘 -&gt; 内核缓冲区 -&gt; 网络堆栈相关的内核缓冲区 -&gt; 网卡</li><li>磁盘上的数据会通过DMA被拷贝的内核缓冲区 -&gt; 操作系统把内核缓冲区与应用程序共享 -&gt; 应用程序调write系统调用将内核缓冲区的内容拷贝到socket缓冲区中 -&gt; socket把内核缓冲区的内容发送到网卡上</li></ul><p>BIO(Blocked I&#x2F;O): 面向流(单向); 同步阻塞I&#x2F;O</p><ol><li>服务端: 通过ServerSocket注册端口</li><li>服务端: 调用<code>accept()</code>监听客户端Socket请求</li><li>客户端: 调用<code>connect()</code>连接服务端</li><li>服务端&#x2F;客户端: 从Socket中获取字节输入流或输出流对数据进行读写操作</li></ol><p>NIO(Non-blocked I&#x2F;O): 面向缓冲区(双向); 非阻塞I&#x2F;O</p><ul><li>一个线程对应一个Selector选择器</li><li>一个Selector对应多个Channel通道</li><li>一个Channel对应一个Buffer(底层是一个数组)</li><li>直接缓冲区与非直接缓冲区<ul><li>直接缓冲区(非堆内存): 本地IO -&gt; 直接内存 -&gt; 本地IO</li><li>非直接缓冲区(堆内存): 本地IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地IO</li></ul></li></ul><p>Selector选择器</p><ul><li>可以通过Selector来实现一个I&#x2F;O线程并发处理N个客户端连接和读写操作</li><li>Selector接多个Channel并监听这些Channel上的事件，使用选择器的事件迭代器遍历获取选择器监听到的事件并判断事件类型分别处理，处理完后清除事件</li></ul><p>AIO(Async-Blocked I&#x2F;O): 异步非阻塞I&#x2F;O</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程</p><ul><li>进程(资源分配的基本单位): 是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>线程(执行调度的基本单位): 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是多个线程可以共享同一块内存空间和一组系统资源(堆)，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。但是频繁的切换线程可能会消耗大量的CPU资源，因为需要频繁的保存和恢复线程运行上下文。<ul><li>特性<ol><li>可见性</li><li>有序性</li><li>原子性</li></ol></li></ul></li><li>纤程:</li></ul><p>线程撕裂者: 一个核里面可以跑多个线程</p><ul><li>一颗CPU可以有多个核，正常的CPU一个核可以同时跑一个线程</li><li>线程撕裂者就是一个核里面有一个ALU(arithmetic and logic unit)服务2寄存器组，ALU可以在2个寄存器组之间快速切换，一个寄存器组存一个线程的工作数据，这样一个核看起来就是同时跑2个线程。例如4核8线程</li></ul><p>并行与并发</p><ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力</li></ul><p>线程安全:<br>经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。</p><p>死锁:<br>产生死锁的四个必要条件</p><ol><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不可剥夺条件: 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)。</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件: 存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有(i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有</li></ol><p>Java 中实现多线程的方法</p><ol><li>继承 <code>Thread</code> 类</li><li>实现 <code>Runnable</code> 接口: 如果一个类继承 Thread类，则不适合于多个线程共享资源，而实现了 Runnable 接口，就可以方便的实现资源的共享</li></ol><p>同步:<br>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入<code>synchronized</code>关键字。</p><p><code>synchronized</code>关键字:</p><ul><li><code>synchronized(expression) &#123;// 同步代码块&#125;</code>: 对表达式<code>expresssion</code>求值(值的类型须是引用类型reference type)，获取它所代表的对象，然后尝试获取这个对象的锁 -&gt; 如果能获取锁，则进入同步块执行，执行完后退出同步块，并归还对象的锁(异常退出也会归还); 如果不能获取锁，则阻塞在这里，直到能够获取锁;</li><li>特性:<ol><li>原子性: 同步代码块中的内容要么全部执行要么都不执行</li><li>可见性: 多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性。这点和<code>volatile</code>的实现类似，被<code>volatile</code>修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性</li><li>有序性: 程序执行的顺序按照代码先后执行，每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性</li><li>可重入性: <code>synchronized</code>关键字属于可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</li></ol></li><li>源码解读<ul><li>反编译使用了<code>synchronized</code>关键字的类的class文件可以看到两种实现方法:<ol><li>字节码指令(<code>monitorenter</code>,<code>monitorexit</code>): 修饰同步代码块</li></ol><ul><li><code>synchronized</code>修饰在方法块: 通过 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令获取线程的执行权的。当方法执行完毕退出以后或者出现异常的情况下会自动释放锁</li><li>JVM执行到<code>monitorenter</code>指令时它会尝试获取对象的锁，如果该对象没有锁，或者当前线程已经拥有了这个对象的锁时，它会把计数器+1；然后当执行到<code>monitorexit</code> 指令时就会将计数器-1；然后当计数器为0时，锁就释放了。如果获取锁 失败，那么当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</li><li>反编译后可以看到一个<code>monitorenter</code>和两个<code>monitorexit</code>: 这是因为第二个<code>monitorexit</code>是给异常处理释放锁用的</li><li>monitor到底是什么: monitor它就是个监视器，底层源码是C++编写的2. <code>flag=ACC_SYNCHRONIZED</code>: 修饰同步方法</li><li>这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。</li></ul></li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/realize_dream/article/details/106968443">深入理解synchronized底层源码</a></p></blockquote><p>先行发生原则(happens-before): 在发生操作B之前，操作A产生的影响能被操作B观察到。先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据</p><p><code>volatile</code>关键字: 当一个变量定义为volatile之后，它将具备两种特性</p><ol><li>保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</li><li>禁止指令重排序优化</li></ol><p>JVM中对象实例的组成:</p><ol><li>对象头:</li></ol><ul><li>Mark Word:<ul><li>对象的hashCode</li><li>锁信息: 记录对象锁当前的状态，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据<ul><li>JDK6之前: 无锁、有锁(重量级锁)</li><li>JDK6之后: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁(CAS) -&gt; 重量级锁<ul><li>偏向锁: 如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程ID等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作</li></ul></li><li>轻量级锁(2个线程版本的偏向锁): 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块</li><li>重量级锁: 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大</li></ul></li><li>分代年龄</li><li>GC标志</li></ul></li><li>Class Metadata Address: 类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例</li></ul><ol start="2"><li>实例数据: 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐</li><li>对其填充</li></ol><p>ReentrantLock(可重入锁):</p><ul><li>指的是一个线程能够对一个临界资源重复加锁</li></ul><p>LongAdder</p><ul><li>采用分段CAS: 除了真正记录数值的base属性外，还有与base相同的数据类型的cell数组，如果存在多个线程同时对Lang做自增操作，则new一个cell元素放到cell数组里供新增的线程做操作(这里会根据线程数自动扩容或缩容cell数组)，使得同时对base做自增操作的线程数变少，自旋占用的CPU变少，最后再用sum求和操作对所有cell属性和base属性做求和操作并返回，这个求出来的和就是所有线程做的操作的总和</li></ul><p>线程的状态变化:</p><ol><li>New(创建状态): 在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时它已经有了相应的内存空间和其他资源(程序计数器、本地方法栈、虚拟机栈)，但还处于不可运行状态。新建一个线程对象可采用<code>Thread</code> 类的构造方法来实现，例如 <code>Thread thread=new Thread()</code></li><li>Ready(就绪状态): 新建线程对象后，调用该线程的 <code>start()</code> 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 调度，这表明它已经具备了运行条件</li><li>Running(运行状态): 当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 <code>run()</code> 方法。<code>run()</code> 方法定义该线程的操作和功能</li><li>Blocked(阻塞状态): 一个正在执行的线程遇到<code>synchronized</code>，会进入阻塞状态。线程都将进入阻塞状态，阻塞的线程进入调度队列entry set排队，获取到锁的线程才可以转入就绪状态</li><li>Waiting(等待): 调用<code>Object.wait()</code>, <code>Thread.join()</code>方法可使一个线程进入不带时限的等待状态，直到其它线程调用了方法<code>Object.notify()</code>或<code>Object.notifyAll()</code>唤醒了等待状态的线程，被唤醒后可能进入调度队列entry set继续等待获取锁(Blocked状态)或直接获取到锁(Runnable状态)</li><li>Time_Waiting(超时等待): 调用<code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>Thread.sleep(long)</code>方法可使一个线程进入带时限的等待状态，直到其它线程调用了方法<code>Object.notify()</code>或<code>Object.notifyAll()</code>唤醒了等待状态的线程</li><li>Terminated(死亡状态): 线程调用 <code>stop()</code> 方法时或 <code>run()</code> 方法执行结束后，即处于死亡状态。</li></ol><blockquote><p><a href="https://www.cnblogs.com/zhongchang/articles/10339134.html">Java 线程状态之 WAITING</a></p></blockquote><p>常用的线程池<code>java.util.concurrent.Executors</code>类下静态方法:</p><ol><li><code>newSingleThreadExecutor()</code>: 创建了一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li><li><code>newFixedThreadPool(int nThreads)</code>: 创建了一个固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大值<code>nThreads</code>。线程池的大小一旦达到最大值后，再有新的任务提交时则放入无界阻塞队列中，等到有线程空闲时，再从队列中取出任务继续执行。</li><li><code>newCachedThreadPool()</code>: 创建了一个可缓存的线程池。当有新的任务提交时，有空闲线程则直接处理任务，没有空闲线程则创建新的线程处理任务，队列中不储存任务。线程池不对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。如果线程空闲时间超过了60秒就会被回收。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, // 核心线程数</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize, // 线程池最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime, // 超出核心线程数的线程等待new task的时间，超过则terminated</span><br><span class="hljs-params">                          TimeUnit unit, // keepAliveTime时间的单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 用于保存等待执行的任务的阻塞队列: 用于存放等待线程执行的task的队列只存放由execute方法提交的Runnable任务</span><br><span class="hljs-params">                          RejectedExecutionHandler handler // 线程池对拒绝任务的处理策略</span><br><span class="hljs-params">                          )</span>; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;())); <span class="hljs-comment">// 本身是有界队列但是这里未设置其大小限制，默认Integer.MAX_VALUE，此时相当于无界队列</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;()); <span class="hljs-comment">// 这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Executors</code>存在什么问题</p><ul><li><code>SingleThreadPool</code>和<code>FixedThreadPool</code>使用的是无界队列，其请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求而导致OOM</li><li><code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能会大量创建线程而导致OOM</li></ul><p>创建线程池的正确姿势，直接使用<code>java.util.concurrent.ThreadPoolExecutor</code>类的构造方法来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-comment">// 10个线程，最大也支持10个</span><br>        <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-comment">// 超时时间60秒</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 有界队列，容量为10，最多容纳10个task</span><br></code></pre></td></tr></table></figure><p>Q: 线程池怎么设置核心线程数?</p><ul><li>如果是CPU密集型服务线程数量等于CPU核心数</li><li>如果是I&#x2F;O密集型服务: 线程数 &#x3D; ((工作时间+休息时间)&#x2F;工作时间) * CPU核心数 * CPU利用率</li></ul><p>workQueue(工作队列): </p><ul><li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO（先进先出）原则对任务进行排序。使用该队列，线程池中能创建的最大线程数为<code>maximumPoolSize</code>。 </li><li><code>LinkedBlockingQueue</code>: 基于链表结构的无界阻塞队列，按FIFO（先进先出）原则对任务进行排序，吞吐量高于<code>ArrayBlockingQueue</code>。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li><li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列。添加任务的操作必须等到另一个线程的移除操作，否则添加操作一直处于阻塞状态。</li><li><code>PriorityBlockingQueue</code>: 一个支持优先级的无界阻塞队列。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li></ul><p>handler(饱和策略，或者又称拒绝策略): 当队列和线程池都满了，即线程池饱和了，必须采取一种策略处理提交的新任务。</p><ul><li><code>AbortPolicy</code>: 无法处理新任务时，直接抛出异常，这是默认策略。 </li><li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务。</li><li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中最靠前的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>: 直接丢弃任务。</li></ul><p>线程池的状态:</p><ol><li>RUNNING: 该状态的线程池既能接受新提交的任务，又能处理阻塞队列中任务。</li><li>SHUTDOWN: 该状态的线程池不能接收新提交的任务，但是能处理阻塞队列中的任务。处于 RUNNING 状态时，调用<code>shutdown()</code>方法会使线程池进入到该状态。 注意： <code>finalize()</code>方法在执行过程中也会隐式调用<code>shutdown()</code>方法。 </li><li>STOP: 该状态的线程池不接受新提交的任务，也不处理在阻塞队列中的任务，还会中断正在执行的任务。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态</li><li>TIDYING: 如果所有的任务都已终止，workerCount(有效线程数)&#x3D;0 。线程池进入该状态后会调用 <code>terminated()</code> 钩子方法进入TERMINATED 状态。</li><li>TERMINATED: 在<code>terminated()</code>钩子方法执行完后进入该状态，默认<code>terminated()</code>钩子方法中什么也没有做。</li></ol><p>线程池的关闭可通过<code>shutdown()</code>或者<code>shutdownNow()</code>方法 </p><ul><li><code>shutdown()</code>将线程池的状态设置为<code>SHUTDOWN</code>状态，只会中断空闲的工作线程</li><li><code>shutdownNow()</code>将线程池的状态设置为<code>STOP</code>状态，会中断所有工作线程，不管工作线程是否空闲</li><li>调用两者中任何一种方法，都会使<code>isShutdown()</code>方法的返回值为true；</li><li>线程池中所有的任务都关闭后，<code>isTerminated()</code>方法的返回值为true</li></ul><p>Q: 新的任务提交到线程池，线程池是怎样处理的？<br>步骤：</p><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。</li><li>线程池判断工作队列是否已经满。如果没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p>Q: 父线程子线程怎么共享数据?</p><ul><li>可以使用<code>InheritableThreadLocals</code>可继承线程变量这个类来实现，<code>ThreadLocals</code>是线程变量，相当于一个map，每个线程是map的key，value是<code>set()</code>进去的值，一个线程使用<code>get()</code>只能get到它自己set进去的值，所以不可用于获取父线程的数据。而<code>InheritableThreadLocals</code>会在子线程new出来的时候就把自己的value复制进去，所以子线程可以使用这个来共享获取父线程的数 据</li></ul><p>AQS(AbstractQueuedSynchronized):</p><ul><li>抽象队列同步器AQS: 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列. AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch</li><li>底层实现为: CAS + volatile</li></ul><p>CAS原理:</p><ul><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li><li>CAS操作都是通过sun包下Unsafe类实现，而Unsafe类中的方法都是native方法CAS通过调用JNI(Java Native Interface)的c++代码实现的</li><li>unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 <code>Atomic::cmpxchg</code></li><li><code>Atomic::cmpxchg</code> 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li><li>Atomic类中的value是<code>volatile</code>的，<code>volatile</code>可以保证可见性和有序性</li><li>Atomic类中设置值使用自旋锁，不断取内存中的value值，然后CAS更新，若失败则持续自旋重试更新操作</li><li>缺点:<ol><li>ABA问题:</li></ol><ul><li>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<code>AtomicStampedReference</code>类具有版本号功能</li></ul><ol start="2"><li>只能保证一个共享变量的原子操作: 多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者把多个共享变量合并成一个共享变量来操作(JDK1.5之后提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作)</li></ol></li></ul><p><code>Atomic::cmpxchg</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK_IF_MP(mp) <span class="hljs-string">&quot;cmp $0, &quot;</span> #mp <span class="hljs-string">&quot;; je 1f; lock; 1: &quot;</span><span class="hljs-comment">// 判断mp是否为多核CPU是则返回LOCK指令</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> jlong <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jlong exchange_value, <span class="hljs-keyword">volatile</span> jlong* dest, jlong compare_value)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> mp = os::<span class="hljs-built_in">is_MP</span>(); <span class="hljs-comment">// </span><br>  __arm__ __volatile__ (<span class="hljs-built_in">LOCK_IF_MP</span>(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgq %1,(%3)&quot;</span> <span class="hljs-comment">// MP=mult prosser LOCK_IF_MP返回lock指令 汇编指令cmpxchgq执行原子的CAS</span><br>                        : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)<br>                        : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)<br>                        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>);<br>  <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>乐观锁底层实现: lock + cmpxchg 指令</li><li>悲观锁底层实现: lock 指令</li><li>volatile的底层实现也是用的: lock指令</li></ul><p>缓存一致性协议: 硬件级别的协议</p><ul><li>作用: 多核CPU有多个一级缓存，保证缓存内部数据的一致,不让系统数据混乱</li><li>Intel CPU对缓存一致性协议的实现(MESI &#x3D; modified + exclusive + shared + invalid)</li><li>MESI中每个缓存行(Cache line:CPU中缓存存储数据的单元，一般为64字节)都有四个状态(假设线程 A 和线程 B 同时对一个变量执行 i++)<ol><li>核心 A 从内存中加载变量 i，并将缓存行设置为 E（独享），随后通过总线嗅探检查内存中对变量 i 的操作；</li><li>核心 B 从内存中加载变量 i，总线嗅探机制会将核心 A 与核心 B 的缓存行设置为 S（共享）</li><li>核心 A 对变量 i 进行修改，缓存行设置为 M（修改），而核心 B 被通知修改缓存行为 I（无 效）。如果存在高并发，则交给总线裁决</li><li>核心 A 将修改后数据同步回内存，并将变量设置为 E（独享）</li><li>核心 B 重新刷新缓存行，并将缓存行核心 A 和核心 B 的缓存行设置为 S（共享）</li></ol></li><li>CPU 是通过总线和内存进行数据传输的。在多核心时代下，多个核心通过同一条总线和内存以及其他硬件进行通信</li><li>通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行</li><li>伪共享问题: 伪共享是指多个线程同时读写同一个缓存行中的变量，而导致缓存行失效的问题。尽管多个线程分别访问的是不同的数据，但由于它们存在同一个缓存行中，只要任何一方修改都会使得缓存失效，降低了运算效率。解决方案: 字节填充，在变量前后填充多个字节使得 变量大小+填充的字节&#x3D;64字节，这样这个变量肯定会独占一个缓存行。</li></ul><blockquote><p><a href="https://blog.csdn.net/m18870420619/article/details/82431319">CPU缓存一致性协议MESI</a><br><a href="https://www.cnblogs.com/jokerjason/p/9584402.html">缓存行与MESI</a></p></blockquote><p>用户态内核态</p><ul><li>Linux操作系统的体系架构分为用户态和内核态</li><li>内核态: 本质上是一种软件，控制计算机硬件资源(CPU资源、存储资源、I&#x2F;O资源等)</li><li>用户态: 上层应用程序的活动空间</li><li>上层应用想要访问计算机硬件资源需要通过内核提供的访问接口(系统调用)来调用</li><li>系统调用是操作系统的最小功能单位</li><li>从用户态到内核态切换可以通过三种方式:<ol><li>系统调用</li><li>异常: 如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常</li><li>外设中断: 当外设完成用户的请求时，会向CPU发送中断信号</li></ol></li></ul><h3 id="多线程框架"><a href="#多线程框架" class="headerlink" title="多线程框架"></a>多线程框架</h3><h2 id="Disruptor-框架-英国外汇交易公司LMAX开发的一个高性能队列。主要用于线程与线程之间的消息传递-QPS-600w-为什么快-1-CAS-ArrayBlockingQueue使用了重量级锁-lock锁-，而Disruptor采用CAS操作-2-消除伪共享-解决方案-字节填充，在变量前后填充多个字节使得-变量大小-填充的字节-x3D-64字节，这样这个变量肯定会独占一个缓存行。-3-RingBuffer-环形数组，没有删除操作，超过容量会直接覆盖原有数据，避免了垃圾回收。大小必须为2的n次方，因为取余运算直接使用的是位运算，使得元素定位更快。"><a href="#Disruptor-框架-英国外汇交易公司LMAX开发的一个高性能队列。主要用于线程与线程之间的消息传递-QPS-600w-为什么快-1-CAS-ArrayBlockingQueue使用了重量级锁-lock锁-，而Disruptor采用CAS操作-2-消除伪共享-解决方案-字节填充，在变量前后填充多个字节使得-变量大小-填充的字节-x3D-64字节，这样这个变量肯定会独占一个缓存行。-3-RingBuffer-环形数组，没有删除操作，超过容量会直接覆盖原有数据，避免了垃圾回收。大小必须为2的n次方，因为取余运算直接使用的是位运算，使得元素定位更快。" class="headerlink" title="Disruptor 框架- 英国外汇交易公司LMAX开发的一个高性能队列。主要用于线程与线程之间的消息传递- QPS: 600w- 为什么快:  1. CAS: ArrayBlockingQueue使用了重量级锁(lock锁)，而Disruptor采用CAS操作  2. 消除伪共享: 解决方案: 字节填充，在变量前后填充多个字节使得 变量大小+填充的字节&#x3D;64字节，这样这个变量肯定会独占一个缓存行。  3. RingBuffer: 环形数组，没有删除操作，超过容量会直接覆盖原有数据，避免了垃圾回收。大小必须为2的n次方，因为取余运算直接使用的是位运算，使得元素定位更快。"></a>Disruptor 框架<br>- 英国外汇交易公司LMAX开发的一个高性能队列。主要用于线程与线程之间的消息传递<br>- QPS: 600w<br>- 为什么快:<br>  1. CAS: ArrayBlockingQueue使用了重量级锁(lock锁)，而Disruptor采用CAS操作<br>  2. 消除伪共享: 解决方案: 字节填充，在变量前后填充多个字节使得 变量大小+填充的字节&#x3D;64字节，这样这个变量肯定会独占一个缓存行。<br>  3. RingBuffer: 环形数组，没有删除操作，超过容量会直接覆盖原有数据，避免了垃圾回收。大小必须为2的n次方，因为取余运算直接使用的是位运算，使得元素定位更快。</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>类加载子系统: 根据给定的全限定名类名(如java.lang.Object)来装载class文件的内容到方法区(Method Area)</p><ol><li>Bootstrap ClassLoader(启动类加载器): <code>$JAVA_HOME</code>中<code>jre/lib/rt.jar</code>里所有的class，由C++实现</li><li>Extension ClassLoader(扩展类加载器): 负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME</code>中<code>jre/lib/*.jar</code>或<code>-D java.ext.dirs</code>指定目录下的jar包</li><li>App ClassLoader(系统类加载器): 负责加载classpath中指定的jar包及目录中class</li><li>Custom ClassLoader(用户自定义类加载器): 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</li></ol><p>双亲委派机制: JVM对class文件采用按需加载的方式，在加载时JVM采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，若无法完成，子类加载器才会去加载。</li></ol><p>运行时数据区(Runtime Data Area)</p><ol><li>程序计数器(Program Counter Register) &lt;- 线程不共享</li><li>本地方法栈(Native Method Stack) &lt;- 线程不共享</li><li>虚拟机栈(Java Virtual Machine Stack) &lt;- 线程不共享</li><li>方法区(Method Area) &lt;- 线程共享</li><li>堆(Heap) &lt;- 线程共享</li></ol><p>堆(Heap): 年青代:老年代&#x3D;1:2</p><ul><li>年青代(Young): Eden:From:To&#x3D;8:1:1<ul><li>Eden: 新创建的对象绝大部分会分配在Eden区。当Eden区内存不够的时候，就会触发MinorGC</li><li>Survivor 0(From): 在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄到<code>15</code>，则直接分配到老年代。</li><li>Survivor 1(To)</li></ul></li><li>老年代(Tenured): 老年代存放从年轻代存活的对象。一般来说老年代存放的都是生命期较长的对象</li></ul><p>GC(Generational Collecting)垃圾回收:</p><ul><li>Minor GC: 当伊甸园的空间满时，程序又需要创建对象，触发Minor GC</li><li>Full GC: 当老年代内存不足时，对老年代进行垃圾回收。这时可能会伴随着STW(Stop The World)</li><li>STW(Stop The World): 停止所有线程，进行垃圾回收，这时候线程会被阻塞，直到垃圾回收完成<ul><li>Q: 为什么要STW？-&gt; A: 如果不执行STW的话在Full GC的过程中如果有一个线程执行完毕，那么这个线程的局部变量表里面所指向的在堆里的对象都会变成垃圾，但是此时Full GC还没执行完，那么这次Full GC执行所得到的结果是不准确的</li></ul></li></ul><p>JVM虚拟机调优:</p><ul><li>主要是减少STW发生的频率，因为发生STW的时候会阻塞全部的用户线程，在用户看来就是应用程序卡顿</li><li>能不能通过调整JVM参数是的几乎发生Full GC?<ul><li>默认年青代:老年代&#x3D;1:2，改成2:1，那么当年轻代满的时候绝大部分昭生夕死的对象会被干掉，只有实在干不掉的才会挪到老年代</li></ul></li><li>jVisualVM: 可视化工具，可以查看JVM的内存使用情况，安装插件可以观察到堆分代模型的整个GC过程</li></ul><p>判断对象是否需要回收</p><ol><li>引用计数法: 给对象添加一个引用计数器。但是难以解决循环引用问题。</li><li>可达性分析法: 通过一系列的 <code>GC Roots</code> 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</li></ol><p>垃圾回收算法</p><ol><li>标记-清除算法(Mark-Sweep):</li></ol><ul><li>分为两个阶段：标记阶段(标记出所有需要被回收的对象) -&gt; 清除阶段(回收被标记的对象所占用的空间)</li><li>缺点: 效率不高、空间会产生大量碎片</li></ul><ol start="2"><li>复制算法(Copying): 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。Eden:From:To&#x3D;8:1:1</li><li>标记-整理算法(Mark-Compact): 在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存</li><li>分代收集(Generational Collection): 根据对象的生命周期划分几块内存区，一般是分为新生代和老年代。新生代:老年代&#x3D;1:2</li></ol><p>垃圾收集器:</p><ol><li>Serial&#x2F;Serial Old收集器: 单线程收集器，进行垃圾收集时，必须暂停所有用户线程</li></ol><ul><li>Serial: 新生代 Copying算法</li><li>Serial Old: 老年代 Mark-Compact算法</li></ul><ol start="2"><li>ParNew收集器: Serial收集器的多线程版本</li><li>Parallel Scavenge收集器: 新生代的多线程收集器回收期间不需要暂停其他用户线程 Copying算法</li><li>Parallel Old收集器: 多线程 Mark-Compact算法</li><li>CMS(Concurrent Mark Sweep)收集器: 并发收集器，优点是最短回收停顿时间 Mark-Sweep算法</li><li>G1收集器: 并行与并发收集器，并且它能建立可预测的停顿时间模型</li></ol><p>程序计数器(Program Counter Register): 每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，若为native方法则为undefined</p><p>本地方法栈(Native Method Stack): 本地方法栈用于管理本地方法的调用</p><p>虚拟机栈(Java Virtual Machine Stack): </p><ul><li>线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)</li><li>栈帧的内部结构：<ol><li>局部变量表(Local Variables): 最基本的存储单元是Slot(变量槽)，容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>操作数栈(operand Stack)(或表达式栈): 用于保存计算过程的中间结果</li><li>动态链接(DynamicLinking)(或指向运行时常量池的方法引用): 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)</li><li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义): 存放调用该方法的pc寄存器的值</li></ol></li></ul><p>方法区(Method Area): 元空间(Metaspace)是其实现，元空间并不在虚拟机中，而是使用本地内存</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis单线程为什么快?</p><ol><li>纯内存操作: 数据存放在内存中，内存的响应时间大约是100纳秒</li><li>单线程: Redis是基于内存的操作，CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，同时避免了线程切换和竞态产生的消耗 </li><li>非阻塞I&#x2F;O: Redis采用epoll做为I&#x2F;O多路复用技术的实现 ，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I&#x2F;O上浪费过多的时间 </li><li>客户端调服务端:</li><li>发送命令</li><li>执行命令: 每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题</li><li>返回结果</li></ol><p>Redis数据结构底层实现</p><ul><li>String: Simple dynamic string(SDS)<ul><li><code>buf[]</code>字节数组，用于保存字符串, <code>len</code>保存字符串的长度, <code>free</code>buf 数组中未使用字节的数量</li><li>优点: 不用担心字符串变更造成的内存溢出问题</li></ul></li><li>链表: 双向链表上扩展了头、尾节点、元素数等属性<ul><li>优点: 可以直接获得头、尾节点</li></ul></li><li>字典(Hash): 数组+链表的基础上，进行了一些rehash优化<ul><li>采用链地址法来处理冲突，然后它没有使用红黑树优化</li><li>哈希表节点采用单链表结构</li><li>rehash优化: 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子(load factor)维持在一个合理的范围之内， 程序需要对哈希表的大小进行相应的扩展或者收缩</li></ul></li><li>有序集合:<ul><li>底层实现为跳跃表: 跳表其实就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了</li></ul></li></ul><p>分布式锁</p><ul><li>使用<code>setnx</code>命令实现: 在Redis中，<code>setnx</code>命令的作用是，如果key不存在，则设置key-value并返回true，如果key存在，则不做任何操作并返回false; 利用这一机制在获取锁为设置key，设置成功返回true表示获取到锁了，执行完业务逻辑之后删除掉设置的key即可</li></ul><p>epoll: linux内核下的一个高效的处理大批量的文件操作符的一个实现</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MyISAM</p><ul><li>非聚集索引: 索引文件与数据文件分开; <code>.MYI</code>文件存索引, <code>.MYD</code>文件存数据</li><li>底层数据结构: B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</li><li>主键: 可以没有</li><li>辅助索引(Secondary key): 结构上与主索引没有任何区别，辅助索引的 key 可以重复</li></ul><p>InnoDB</p><ul><li>聚集索引: 数据文件本身就是索引文件</li><li>底层数据结构: B+Tree 作为索引结构，叶节点的 data 域保存了完整的数据记录。索引的 key 是数据表的主键，因此InnoDB 要求表必须有主键</li><li>主键: 必须有主键。如果没有显式指定，则会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则自动为 InnoDB 表生成一个隐含字段作为主键，类型为长整形。尽量在采用自增字段做表的主键，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整</li><li>辅助索引(Secondary key): 辅助索引 data 域存储相应记录主键的值而不是地址。这使得辅助索引搜索需要检索两遍索引(回表):首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录。</li></ul><p>mysql索引数据结构为什么选择B+Tree?</p><ul><li>二叉树: 无平衡机制，插入递增元素，退化成链表</li><li>红黑树(是一种二叉平衡树): 数据量大时树的深度也会很深</li><li>B Tree: 多叉，从左到右依次递增，叶子节点都在同一层</li><li>B+ Tree: 非叶子节点不存储data，叶子节点包含所有索引字段并用指针从左往右链接成链表。</li></ul><p>B+ Tree: 每个节点大小16kb限制，16kb&#x2F;每个节点大小(8字节索引元素+6字节孩子节点磁盘文件地址指针)&#x3D;1170个索引</p><ul><li>索引全部加载到内存，找到后根据磁盘文件地址进行一次磁盘I&#x2F;O读取对应的数据</li><li>只用3层的B+ Tree就支持上千万行数据的查找</li></ul><p>MVCC</p><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>组成:</p><ol><li>Name Server: 名称服务充当路由消息的提供者，可集群部署，节点之间无任何信息同步，提供命名服务，更新和发现 Broker 服务</li><li>Producer(生产者): </li><li>Broker: 消息中转角色，负责存储消息，转发消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker</li><li>Consumer(消费者):</li></ol><ul><li>Topic: 表示消息的第一级类型，一条消息必须有一个Topic</li><li>Queue: Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元</li><li>tags: Tags是Topic下的次级消息类型&#x2F;二级类型，可以在同一个Topic下基于Tags进行消息过滤。Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况</li><li>commitLog: 用于存储消息的文件。顺序写入，随机读写。消息只要被写入 commitlog 那么该消息就不会丢失。</li><li>ConsumeQueue: ConsumeQueue中并不需要存储消息的内容，而存储的是消息在CommitLog中的offset。通过broker保存的offset可以在ConsumeQueue中获取消息，从而快速的定位到commitLog的消息位置</li></ul><p>集群: 推荐多主多从</p><ul><li><p>多个master节点多个slave节点，一个master节点配一个slave节点，slave是master节点的备份</p></li><li><p>slave节点不接受生产者的消息，生产者的消息发给master节点</p></li><li><p>消费者一般从master节点消费消息</p></li><li><p>若master节点宕机，则消费者从对应的slave节点消费消息，注意：这里slave即使master宕机也不会升级，依然是slave节点</p></li><li><p>同步复制: 生产者发送同步消息需主节点和从节点都写入文件或内存(异步刷盘是内存，一般选择异步刷盘)之后才会返回确认信息给生产者</p></li><li><p>异步刷盘(高性能): 注意这里因为消息同时存在于主节点和从节点所以这里可以采用异步刷盘，丢失的概率不大</p></li><li><p>Topic: 表示消息的第一级类型，一条消息必须有一个Topic</p></li><li><p>Queue: Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元</p></li><li><p>tags: Tags是Topic下的次级消息类型&#x2F;二级类型，可以在同一个Topic下基于Tags进行消息过滤。Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况</p></li><li><p>commitLog: 用于存储消息的文件。顺序写入，随机读写。消息只要被写入 commitLog 那么该消息就不会丢失。</p></li><li><p>ConsumeQueue: ConsumeQueue中并不需要存储消息的内容，而存储的是消息在CommitLog中的offset。通过broker保存的offset可以在ConsumeQueue中获取消息，从而快速的定位到commitLog的消息位置</p></li></ul><p>消息类型</p><ul><li>同步消息: 消息发送方发出数据后，生产者会阻塞直到MQ服务方发回响应消息，表示已经写入数据到queue里了</li><li>异步消息: MQ 的异步发送，需要用户实现异步发送回调接口(SendCallback)，在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应</li><li>单向(one-way)消息: 只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别</li></ul><p>消息丢失分析:</p><ul><li>生产者发送时丢失: 同步复制+重试</li><li>RocketMQ自身丢失: 主从架构+持久化</li><li>消费者消费消息丢失: 重试+死信队列</li></ul><p>消息重复消费问题:</p><ul><li>MVCC(Multi-Version Concurrency Control多版本并发控制): 生产者发送到queue的消息需要带上这个版本号，消费者在执行业务逻辑的同时带上版本号，sql的update语句的where带上version号保证语句的幂等性。<ul><li>缺点: 这意味着生产者在发送消息之前就需要查表拿到最新的版本号，增加了生产者和消费者的耦合度</li></ul></li><li>去重表方案: 每个消息带唯一id，然后消费者维护消息表，id设成唯一，消费消息的同时insert这张表，如果抛异常就把异常吃了直接返回，后续业务逻辑不继续进行了</li></ul><p>顺序消息消费问题:</p><ol><li>一个topic对应一个queue，这样需要顺序消费的消息就在同一条queue里</li><li>重试参数改成0</li></ol><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>Partition: topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。</li></ul><p>消息传递模式</p><ul><li>点对点传递模式: 消息持久化到一个队列中，一个或多个消费者消费队列中的数据，一条消息只能被消费一次</li><li>发布-订阅模式: 消息被持久化到一个topic中，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除</li></ul><p>RocketMQ与Kafka的区别</p><ol><li>rocketMQ的NameServer和kafka的zookeeper对比</li></ol><ul><li>kafka具备选举功能: Master&#x2F;Slave的选举，有2步<ol><li>先通过ZK在所有机器中，选举出一个KafkaController</li><li>再由这个Controller，决定每个partition的Master是谁，Slave是谁</li></ol></li><li>因为有了选举功能，所以kafka某个partition的master挂了，该partition对应的某个slave会升级为主对外提供服务</li><li>rocketMQ不具备选举，Master&#x2F;Slave的角色也是固定的。当一个Master挂了之后，你可以写到其他Master上，但不能让一个Slave切换成Master</li><li>rocketMq的所有broker节点的角色都是一样，上面分配的topic和对应的queue的数量也是一样的，Mq只能保证当一个broker挂了，把原本写到这个broker的请求迁移到其他broker上面</li></ul><ol start="2"><li>kafka为什么比RocketMQ有更大的吞吐量</li></ol><ul><li>kafka在消息存储过程中会根据topic和partition的数量创建物理文件，也就是说我们创建一个topic并指定了3个partition，那么就会有3个物理文件目录，也就说说partition的数量和对应的物理文件是一一对应的</li><li>RocketMQ在消息存储方式是采用commitLog，RocketMQ的queue的数量其实是在consumeQueue里面体现的，在真正存储消息的commitLog其实就只有一个物理文件</li><li>kafka的多文件并发写入 VS RocketMQ的单文件写入，性能差异kafka完胜可想而知</li><li>kafka的大量文件存储会导致一个问题，也就说在partition特别多的时候，磁盘的访问会发生很大的瓶颈，毕竟单个文件看着是append操作，但是多个文件之间必然会导致磁盘的寻道</li></ul><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>一致性哈希算法</p><ul><li>假设你需要对文件进行缓存，你有缓存集群，对每个文件根据哈希对服务器数量取模，将每一张文件映射到一台缓存服务器上面。缺点: 如果你要增加一台服务器，那么需要对所有的文件都重新计算一遍，这样就会导致缓存雪崩，全部缓存到文件失效</li><li>为解决这个问题可以采用一致性哈希算法: 将服务器映射到一个环上面，然后根据哈希值取模，将文件映射到环上某个位置，然后这个文件存储的服务器就是映射位置顺时针遇到的第一个服务器，这样如果增加一台服务器也只会使得环上的一部分文件缓存失效，避免了缓存雪崩</li><li>缺点: 有时候可能会出现缓存不均匀的情况，即服务器映射到环上的位置是不均匀的，可以通过增加虚拟节点解决，文件顺时针遇到虚拟节点就放到虚拟节点对应的那个真实节点对应的服务器上</li></ul><h4 id="常用高并发相关工具"><a href="#常用高并发相关工具" class="headerlink" title="常用高并发相关工具"></a>常用高并发相关工具</h4><p>Apache JMeter</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java后端&quot;&gt;&lt;a href=&quot;#Java后端&quot; class=&quot;headerlink&quot; title=&quot;Java后端&quot;&gt;&lt;/a&gt;Java后端&lt;/h1&gt;&lt;h3 id=&quot;Java语言特性&quot;&gt;&lt;a href=&quot;#Java语言特性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java复习笔记：多线程与并发第一章</title>
    <link href="http://yoursite.com/2022/11/13/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://yoursite.com/2022/11/13/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2022-11-13T09:07:53.000Z</published>
    <updated>2023-03-05T10:41:28.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念回顾"><a href="#基本概念回顾" class="headerlink" title="基本概念回顾"></a>基本概念回顾</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><h4 id="进程和线程的由来"><a href="#进程和线程的由来" class="headerlink" title="进程和线程的由来"></a>进程和线程的由来</h4><ol><li>串行：早起的计算机只能执行串行任务，并且遇到用户输入的操作时便会阻塞</li><li>批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍无法并发执行</li><li>进程：进程独占内存空间，保存各自运行状态，相互不干扰且可以互相切换，为并发处理任务提供了可能</li><li>线程：共享进程的内存资源，相互间切换更便捷，支持更细粒度的任务控制，让进程内的子任务得以并发执行</li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述。进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</strong></p><p>所有与进程相关的资源都被记录在<a href="https://baike.baidu.com/item/PCB/16067368?fr=aladdin">PCB(PCB Process Control Block)</a>中。</p><p>PCB:</p><ul><li>描述信息</li><li>控制信息</li><li>资源信息<ul><li>程序段</li><li>数据段</li></ul></li><li>CPU现场</li></ul><blockquote><p>它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p></blockquote><p>进程拥有完整的<a href="https://blog.csdn.net/u014379540/article/details/52263114">虚拟内存地址空间</a>，而同一进程下的线程则共享该进程拥有的内存空间。</p><p>线程的组成：</p><ul><li>堆栈寄存器</li><li>程序计数器</li><li>TCB</li></ul><p>进程就是包括上下文切换的程序执行时间总和 &#x3D; CPU加载上下文+CPU执行+CPU保存上下文。</p><img src="进程与线程.png"><p>进程的颗粒度太大，每次都要有上下的调入，保存，调出。</p><p>假设存在进程A，其实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><p>进程A得到CPU-&gt;CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p><p>这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p><h3 id="Linux用户态和内核态转换"><a href="#Linux用户态和内核态转换" class="headerlink" title="Linux用户态和内核态转换"></a>Linux用户态和内核态转换</h3><h4 id="为什么需要转换"><a href="#为什么需要转换" class="headerlink" title="为什么需要转换"></a>为什么需要转换</h4><h4 id="内核态的多线程是如何通过轻量级线程来实现的"><a href="#内核态的多线程是如何通过轻量级线程来实现的" class="headerlink" title="内核态的多线程是如何通过轻量级线程来实现的"></a>内核态的多线程是如何通过轻量级线程来实现的</h4><h3 id="什么是系统中断"><a href="#什么是系统中断" class="headerlink" title="什么是系统中断"></a>什么是系统中断</h3><h2 id="Java中的进程和线程"><a href="#Java中的进程和线程" class="headerlink" title="Java中的进程和线程"></a>Java中的进程和线程</h2><h3 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h3><ul><li>运行一个程序会产生一个进程，进程包含至少一个线程</li><li>每个进程对应一个JVM实例，多个线程共享JVM里的堆</li><li>Java采用单线程编程模型，程序会自动创建主线程</li></ul><h3 id="Thread中的start和run方法的区别"><a href="#Thread中的start和run方法的区别" class="headerlink" title="Thread中的start和run方法的区别"></a>Thread中的<code>start</code>和<code>run</code>方法的区别</h3><p>使用<code>run</code>方法会继续使用主线程来执行重写的<code>run</code>方法里面的内容，而使用<code>start</code>方法则会开一个新线程来执行。</p><p>我们看一下start方法源码</p><blockquote><p>Thread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Causes this thread to begin execution; the Java Virtual Machine</span><br><span class="hljs-comment">     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The result is that two threads are running concurrently: the</span><br><span class="hljs-comment">     * current thread (which returns from the call to the</span><br><span class="hljs-comment">     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span><br><span class="hljs-comment">     * &lt;code&gt;run&lt;/code&gt; method).</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * It is never legal to start a thread more than once.</span><br><span class="hljs-comment">     * In particular, a thread may not be restarted once it has completed</span><br><span class="hljs-comment">     * execution.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span><br><span class="hljs-comment">     *               started.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #run()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #stop()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="hljs-comment">         * group threads created/set up by the VM. Any new functionality added</span><br><span class="hljs-comment">         * to this method in the future may have to also be added to the VM.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br>        <span class="hljs-comment">/* Notify the group that this thread is about to be started</span><br><span class="hljs-comment">         * so that it can be added to the group&#x27;s list of threads</span><br><span class="hljs-comment">         * and the group&#x27;s unstarted count can be decremented. */</span><br>        group.add(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            start0();<br>            started = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!started) &#123;<br>                    group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>                <span class="hljs-comment">/* do nothing. If start0 threw a Throwable then</span><br><span class="hljs-comment">                  it will be passed up the call stack */</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>可以看到在<code>start</code>方法里面主要是使用到了一个native的方法<code>start0()</code>，该方法调用到了外部的非Java的源码。</p><p>可以访问<a href="http://hg.openjdk.java.net/">OpenJKD</a>来查询</p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/dd10fb830ea9/src/share/native/java/lang/Thread.c">JKD8 Thread.c源码</a></p><blockquote><p>Thread.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jni.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jvm.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;java_lang_Thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THD <span class="hljs-string">&quot;Ljava/lang/Thread;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ <span class="hljs-string">&quot;Ljava/lang/Object;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STE <span class="hljs-string">&quot;Ljava/lang/StackTraceElement;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STR <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))</span><br><br><span class="hljs-type">static</span> JNINativeMethod methods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;start0&quot;</span>,           <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_StartThread&#125;,<br>    &#123;<span class="hljs-string">&quot;stop0&quot;</span>,            <span class="hljs-string">&quot;(&quot;</span> OBJ <span class="hljs-string">&quot;)V&quot;</span>, (<span class="hljs-type">void</span> *)&amp;JVM_StopThread&#125;,<br>    &#123;<span class="hljs-string">&quot;isAlive&quot;</span>,          <span class="hljs-string">&quot;()Z&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_IsThreadAlive&#125;,<br>    &#123;<span class="hljs-string">&quot;suspend0&quot;</span>,         <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_SuspendThread&#125;,<br>    &#123;<span class="hljs-string">&quot;resume0&quot;</span>,          <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_ResumeThread&#125;,<br>    &#123;<span class="hljs-string">&quot;setPriority0&quot;</span>,     <span class="hljs-string">&quot;(I)V&quot;</span>,       (<span class="hljs-type">void</span> *)&amp;JVM_SetThreadPriority&#125;,<br>    &#123;<span class="hljs-string">&quot;yield&quot;</span>,            <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_Yield&#125;,<br>    &#123;<span class="hljs-string">&quot;sleep&quot;</span>,            <span class="hljs-string">&quot;(J)V&quot;</span>,       (<span class="hljs-type">void</span> *)&amp;JVM_Sleep&#125;,<br>    &#123;<span class="hljs-string">&quot;currentThread&quot;</span>,    <span class="hljs-string">&quot;()&quot;</span> THD,     (<span class="hljs-type">void</span> *)&amp;JVM_CurrentThread&#125;,<br>    &#123;<span class="hljs-string">&quot;countStackFrames&quot;</span>, <span class="hljs-string">&quot;()I&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_CountStackFrames&#125;,<br>    &#123;<span class="hljs-string">&quot;interrupt0&quot;</span>,       <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_Interrupt&#125;,<br>    &#123;<span class="hljs-string">&quot;isInterrupted&quot;</span>,    <span class="hljs-string">&quot;(Z)Z&quot;</span>,       (<span class="hljs-type">void</span> *)&amp;JVM_IsInterrupted&#125;,<br>    &#123;<span class="hljs-string">&quot;holdsLock&quot;</span>,        <span class="hljs-string">&quot;(&quot;</span> OBJ <span class="hljs-string">&quot;)Z&quot;</span>, (<span class="hljs-type">void</span> *)&amp;JVM_HoldsLock&#125;,<br>    &#123;<span class="hljs-string">&quot;getThreads&quot;</span>,        <span class="hljs-string">&quot;()[&quot;</span> THD,   (<span class="hljs-type">void</span> *)&amp;JVM_GetAllThreads&#125;,<br>    &#123;<span class="hljs-string">&quot;dumpThreads&quot;</span>,      <span class="hljs-string">&quot;([&quot;</span> THD <span class="hljs-string">&quot;)[[&quot;</span> STE, (<span class="hljs-type">void</span> *)&amp;JVM_DumpThreads&#125;,<br>    &#123;<span class="hljs-string">&quot;setNativeName&quot;</span>,    <span class="hljs-string">&quot;(&quot;</span> STR <span class="hljs-string">&quot;)V&quot;</span>, (<span class="hljs-type">void</span> *)&amp;JVM_SetNativeThreadName&#125;,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> THD</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> OBJ</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> STE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> STR</span><br><br>JNIEXPORT <span class="hljs-type">void</span> JNICALL<br><span class="hljs-title function_">Java_java_lang_Thread_registerNatives</span><span class="hljs-params">(JNIEnv *env, jclass cls)</span><br>&#123;<br>    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>start0</code>方法调用到了<code>JVM_StartThread</code>方法，而该方法引自<code>jvm.h</code></p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/b44df6c5942c/src/share/vm/prims/jvm.cpp">JDK8 jvm.cpp源码</a></p><p>在jvm.cpp下的<code>JVM_StartThread</code>方法里有下面这句话用于创建一个线程</p><blockquote><p>jvm.cpp</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">native_thread = new JavaThread(&amp;thread_entry, sz);<br></code></pre></td></tr></table></figure><p>搜索上面用于创建线程的方法传入的参数<code>thread_entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread_entry</span><span class="hljs-params">(JavaThread* thread, TRAPS)</span> &#123;<br>  HandleMark <span class="hljs-title function_">hm</span><span class="hljs-params">(THREAD)</span>;<br>  Handle <span class="hljs-title function_">obj</span><span class="hljs-params">(THREAD, thread-&gt;threadObj())</span>;<br>  JavaValue <span class="hljs-title function_">result</span><span class="hljs-params">(T_VOID)</span>;<br>  JavaCalls::call_virtual(&amp;result,<br>                          obj,<br>                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),<br>                          vmSymbols::run_method_name(),<br>                          vmSymbols::void_method_signature(),<br>                          THREAD);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到该方法最后会调用JVM虚拟机<code>JavaCalls::call_virtual</code>，并传入<code>run_method_name</code></p><p>综上所述：</p><ul><li>调用<code>start</code>方法会：Thread#start()-&gt;JVM_StartThread-&gt;thread_entry-&gt;Thread#run()<ul><li>在<code>thread_entry</code>时创建一个新的子线程并启动去运行Thread#run()里的方法体</li></ul></li><li>调用<code>run</code>方法会：Thread#run()<ul><li>当做一个普通的方法调用去调用Thread#run()里的方法体</li></ul></li></ul><h3 id="Thread和-Runnable是什么关系"><a href="#Thread和-Runnable是什么关系" class="headerlink" title="Thread和 Runnable是什么关系"></a>Thread和 Runnable是什么关系</h3><ul><li>Thread类实现了Runnable接口，使得run支持多线程</li><li>因为类的单一继承原则，推荐使用Runnable接口</li></ul><p>实现了Runnable接口是没有start方法的，需要把其对象作为参数去创建一个Thread对象再调用start方法启动</p><h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给<code>run()</code>方法传参</h3><ol><li>构造函数传参</li><li>成员变量传参</li><li>回调函数传参</li></ol><h3 id="处理线程的返回值"><a href="#处理线程的返回值" class="headerlink" title="处理线程的返回值"></a>处理线程的返回值</h3><ol><li>主线程等待法：让主线程循环等待直到子线程返回</li><li>使用Thread类的<code>join()</code>阻塞当前主线程以等待子线程处理完毕<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.currentThread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        value = <span class="hljs-string">&quot;data&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test);<br>        t.start();<br>        t.join();<br>        System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + cw.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>通过Callable接口实现：通过FutureTask or 线程池获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过FutureTask</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        String value=<span class="hljs-string">&quot;test&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;ready to work&quot;</span>);<br>        Thread.currentThread().sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">&quot;Task down&quot;</span>);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTaskDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        <span class="hljs-keyword">if</span>(!task.isDone())&#123;<br>            System.out.println(<span class="hljs-string">&quot;task has not finished, please wait&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 显示MyCallable里面的返回值</span><br>        System.out.println(<span class="hljs-string">&quot;task return:&quot;</span> + task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">newPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        Future&lt;String&gt; future = newPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-keyword">if</span> (!task.isDone()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;task has not finished, please wait&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 显示MyCallable里面的返回值</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;task return:&quot;</span> + task.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            newPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a><code>sleep</code>和<code>wait</code>的区别</h3><ul><li><code>sleep</code>是Thread类的方法，<code>wait</code>是Object类中定义的方法</li><li><code>sleep</code>方法可以在任何地方使用</li><li><code>wait</code>方法只能在<code>synchronized</code>方法或<code>synchronized</code>快中使用</li><li><code>Thread.sleep</code>只会让出CPU，不会导致锁行为的改变</li><li><code>Object.wait</code>不仅会让出CPU，还会释放已经占有的同步资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitSleepDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread A is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread A get lock&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread A do wait lock&quot;</span>);<br>            lock.wait(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread A is done&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread B is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread B get lock&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B sleeping 10 ms&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B is done&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">thread A is waiting to get lock<br>thread A get lock<br>thread B is waiting to get lock<br>thread A do wait lock<br>thread B get lock<br>thread B sleeping 10 ms<br>thread B is done<br>thread A is done<br></code></pre></td></tr></table></figure><p>观察输出可发现，在A获得锁之后B开始等待锁，而A开始wait之后B就获得了锁</p><h3 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a><code>notify</code>和<code>notifyAll</code>的区别</h3><p>锁池 EntryList：假设线程A已经拥有了某对象的锁，而其它线程B、C想要调用这个对象的某个<code>synchronized</code>方法(或块)之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。</p><p>等待池 WaitSet：假设线程A调用了某个对象的<code>wait()</code>方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。</p><ul><li><code>notifyAll</code>会让所有处于等待池中的线程全部进入锁池去竞争获取锁的机会</li><li><code>notify</code>会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitSleepDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread A is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread A get lock&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread A do wait lock&quot;</span>);<br>            lock.wait();<br>            System.out.println(<span class="hljs-string">&quot;thread A is done&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread B is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread B get lock&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B sleeping 10 ms&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B is done&quot;</span>);<br>            lock.notify(); <span class="hljs-comment">// or lock.notifyAll();</span><br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationDemo</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (go == <span class="hljs-literal">false</span>) &#123;<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is going to notify all or one thread waiting on&quot;</span>);<br>      go = <span class="hljs-literal">true</span>;<br>      notify();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldGo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">while</span> (go != <span class="hljs-literal">true</span>) &#123;<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is going to wait on this object&quot;</span>);<br>      wait();<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is woken up&quot;</span>);<br>    &#125;<br>    go = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">NotificationDemo</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationDemo</span>();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">waitTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          test.shouldGo();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finished Execution&quot;</span>);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">notifyTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        test.go();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finished Execution&quot;</span>);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(waitTask, <span class="hljs-string">&quot;WT1&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(waitTask, <span class="hljs-string">&quot;WT2&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(waitTask, <span class="hljs-string">&quot;WT3&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(notifyTask, <span class="hljs-string">&quot;NT1&quot;</span>);<br><br>    t1.start();<br>    t2.start();<br>    t3.start();<br><br>    Thread.sleep(<span class="hljs-number">200</span>);<br><br>    t4.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Thread[WT1,5,main] is going to wait on this object<br>Thread[WT2,5,main] is going to wait on this object<br>Thread[WT3,5,main] is going to wait on this object<br>Thread[NT1,5,main] is going to notify all or one thread waiting on<br>Thread[WT1,5,main] is woken up<br>NT1 finished Execution<br>WT1 finished Execution<br></code></pre></td></tr></table></figure><ol><li>从输出来看前3行是WT1、WT2、WT3依次进入等待池，</li><li>之后NT1调用<code>notify</code>方法随机唤醒一个线程将其置入锁池，并修改<code>go = true;</code>跳出循环</li><li>这里是WT1被置入锁池，因为上一步中<code>go</code>的值被修改所以跳出循环，WT1获得锁并且修改了变量<code>go = false;</code>，然后因为NT1线程已经结束所以剩下两个线程WT2、WT3依然处于等待池。</li></ol><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><code>yield</code></h3><p>当调用<code>Thread.yield()</code>时会给线程调度器<code>scheduler</code>一个当前线程愿意让出CPU的使用的信号，但是调度去可能会无视该暗示。</p><blockquote><p>Thread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A hint to the scheduler that the current thread is willing to yield</span><br><span class="hljs-comment"> * its current use of a processor. The scheduler is free to ignore this</span><br><span class="hljs-comment"> * hint.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class="hljs-comment"> * between threads that would otherwise over-utilise a CPU. Its use</span><br><span class="hljs-comment"> * should be combined with detailed profiling and benchmarking to</span><br><span class="hljs-comment"> * ensure that it actually has the desired effect.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class="hljs-comment"> * for debugging or testing purposes, where it may help to reproduce</span><br><span class="hljs-comment"> * bugs due to race conditions. It may also be useful when designing</span><br><span class="hljs-comment"> * concurrency control constructs such as the ones in the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> java.util.concurrent.locks&#125; package.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">yieldTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          System.out.println(Thread.currentThread().getName() + i);<br>          <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) &#123;<br>            Thread.<span class="hljs-keyword">yield</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(yieldTask, <span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(yieldTask, <span class="hljs-string">&quot;B&quot;</span>);<br>    t1.start();<br>    t2.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">A0<br>B0<br>A1<br>B1<br>A2<br>B2<br>A3<br>B3<br>A4<br>B4<br>B5<br>A5<br>B6<br>B7<br>B8<br>B9<br>B10<br>A6<br>A7<br>A8<br>A9<br>A10<br></code></pre></td></tr></table></figure><p>可以看出当A线程执行到5时把CPU让给了B来执行，直到B执行到10把B让给A</p><h3 id="使用interrupt来中断线程"><a href="#使用interrupt来中断线程" class="headerlink" title="使用interrupt来中断线程"></a>使用<code>interrupt</code>来中断线程</h3><p>已被抛弃的方法：</p><ul><li><del><code>stop()</code></del>：过于暴力，被中断线程可能没有释放锁</li><li><del><code>suspend()</code></del>, <del><code>resume()</code></del></li></ul><p><code>interrupt()</code></p><ul><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常</li><li>如果线程处于正常状态，那么线程会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">interruptTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 在正常运行任务时，经常检查本线程的中断标志位，如果设置了中断标志就自行停止线程</span><br>          <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            i++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; (&quot;</span> + Thread.currentThread().getState()+ <span class="hljs-string">&quot;) loop:i=&quot;</span> + i);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-comment">// 在调用阻塞方法时正确处理InterruptedException异常</span><br>          System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; (&quot;</span> + Thread.currentThread().getState() + <span class="hljs-string">&quot;) catch InterruptedException&quot;</span>);<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(interruptTask, <span class="hljs-string">&quot;t1&quot;</span>);<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is new.&quot;</span>);<br><br>    t1.start();<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is started.&quot;</span>);<br><br>    Thread.sleep(<span class="hljs-number">300</span>);<br>    t1.interrupt();<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is interrupted.&quot;</span>);<br><br>    Thread.sleep(<span class="hljs-number">300</span>);<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is interrupted now.&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">t1 (NEW) is new.<br>t1 (RUNNABLE) is started.<br>t1 (RUNNABLE) loop:i=1<br>t1 (RUNNABLE) loop:i=2<br>t1 (RUNNABLE) catch InterruptedException<br>t1 (RUNNABLE) is interrupted.<br>t1 (TERMINATED) is interrupted now.<br></code></pre></td></tr></table></figure><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><blockquote><p>Thread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A thread state.  A thread can be in one of the following states:</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #NEW&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that has not yet started is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #RUNNABLE&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread executing in the Java virtual machine is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #BLOCKED&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that is blocked waiting for a monitor lock</span><br><span class="hljs-comment"> *     is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #WAITING&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that is waiting indefinitely for another thread to</span><br><span class="hljs-comment"> *     perform a particular action is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #TIMED_WAITING&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that is waiting for another thread to perform an action</span><br><span class="hljs-comment"> *     for up to a specified waiting time is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #TERMINATED&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that has exited is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * A thread can be in only one state at a given point in time.</span><br><span class="hljs-comment"> * These states are virtual machine states which do not reflect</span><br><span class="hljs-comment"> * any operating system thread states.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getState</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java线程状态：</p><ol><li>新建(NEW)：创建后尚未启动的线程状态</li><li>运行(RUNNABLE)：包含Running(正在执行)和Ready(正在等待CPU分配时间片)<ul><li>Ready(正在等待CPU分配时间片)：其它线程调用了该对象的<code>start()</code>方法，该线程位于可运行线程池中，等待被线程调度选中，获取CPU使用权。</li><li>Running(正在执行)：就绪状态的线程在获得CPU时间片后变为运行中状态(running)</li></ul></li><li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片(timeslice)，执行程序代码</li><li>无限期等待(WAITING)：不会被分配CPU执行时间，需要被显示唤醒，进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)<ul><li>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li>限期等待(TIMED_WAITING)：在一定时间后会由系统自动唤醒<ul><li><code>Thread.sleep()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li>阻塞(BLOCKED)：等待获取排它锁，线程试图获取一个内部对象的<code>Monitor</code>（进入<code>synchronized</code>方法或<code>synchronized</code>块）但是其他线程已经抢先获取，那此线程被阻塞，知道其他线程释放<code>Monitor</code>并且线程调度器允许当前线程获取到<code>Monitor</code>，此线程就恢复到可运行状态。</li><li>结束(TERMINATED)：已终止线程的状态，线程已经结束执行</li></ol><img src="./线程的状态.png"><img src="./等待队列.png"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000016197831?utm_source=tag-newest">一文读懂Java线程状态转换</a></li></ul><p>下图为Oracle支持各个JDK版本所到的年限</p><img src="oracleJDK vs OpenJDK.png">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念回顾&quot;&gt;&lt;a href=&quot;#基本概念回顾&quot; class=&quot;headerlink&quot; title=&quot;基本概念回顾&quot;&gt;&lt;/a&gt;基本概念回顾&lt;/h2&gt;&lt;h3 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>39. Combination Sum</title>
    <link href="http://yoursite.com/2022/10/30/No39.%20Combination%20Sum/"/>
    <id>http://yoursite.com/2022/10/30/No39.%20Combination%20Sum/</id>
    <published>2022-10-29T22:30:02.000Z</published>
    <updated>2023-03-07T14:35:56.883Z</updated>
    
    <content type="html"><![CDATA[<ol start="39"><li>Combination Sum</li></ol><p><a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations<br>of candidates where the chosen numbers sum to target. You may return the combinations in any order.<br>The same number may be chosen from candidates an unlimited number of times.<br>Two combinations are unique if the frequency of at least one of the chosen numbers is different.<br>The test cases are generated such that the number of unique combinations that sum up to target is less than 150<br>combinations for the given input.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: candidates = [2,3,6,7], target = 7<br>Output: [[2,2,3],[7]]<br></code></pre></td></tr></table></figure><p>Explanation:<br>2 and 3 are candidates, and 2 + 2 + 3 &#x3D; 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 &#x3D; 7.<br>These are the only two combinations.  </p><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: candidates = [2,3,5], target = 8<br>Output: [[2,2,2,2],[2,3,3],[3,5]]<br></code></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: candidates = [2], target = 1<br>Output: []<br></code></pre></td></tr></table></figure><p>给 元素不重复 无序 数组，求满足条件的子数组，组合问题<br>需要子数组满足的条件：子数组元素和等于某个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinationSum</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(result, candidates, path, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※</span><br><span class="hljs-comment">     * 2. 根据题意，确立结束条件</span><br><span class="hljs-comment">     * 3. 找准选择列表(与函数参数相关),与第一步紧密关联※</span><br><span class="hljs-comment">     * 4. 判断是否需要剪枝</span><br><span class="hljs-comment">     * 5. 作出选择，递归调用，进入下一层</span><br><span class="hljs-comment">     * 6. 撤销选择 返回上一层</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidates</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stillNeed</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="hljs-type">int</span>[] candidates, List&lt;Integer&gt; path, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> stillNeed)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stillNeed &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stillNeed == <span class="hljs-number">0</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>            path.add(candidates[i]);<br>            backtrack(result, candidates, path, i, stillNeed-candidates[i]);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;39&quot;&gt;
&lt;li&gt;Combination Sum&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum/&quot;&gt;https://leetcode.com/problems/com</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>216. Combination Sum II</title>
    <link href="http://yoursite.com/2022/10/30/No216.%20Combination%20Sum%20II/"/>
    <id>http://yoursite.com/2022/10/30/No216.%20Combination%20Sum%20II/</id>
    <published>2022-10-29T22:30:02.000Z</published>
    <updated>2023-03-07T14:38:45.894Z</updated>
    
    <content type="html"><![CDATA[<ol start="216"><li>Combination Sum III<br>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:<br>Only numbers 1 through 9 are used.<br>Each number is used at most once.<br>Return a list of all possible valid combinations.<br>The list must not contain the same combination twice, and the combinations may be returned in any order.</li></ol><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: k = 3, n = 7<br>Output: [[1,2,4]]<br></code></pre></td></tr></table></figure><p>Explanation:<br>1 + 2 + 4 &#x3D; 7<br>There are no other valid combinations.  </p><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: k = 3, n = 9<br>Output: [[1,2,6],[1,3,5],[2,3,4]]<br></code></pre></td></tr></table></figure><p>Explanation:<br>1 + 2 + 6 &#x3D; 9<br>1 + 3 + 5 &#x3D; 9<br>2 + 3 + 4 &#x3D; 9<br>There are no other valid combinations.  </p><p>Example 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: k = 4, n = 1<br>Output: []<br></code></pre></td></tr></table></figure><p>Explanation: There are no valid combinations.<br>Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 &#x3D; 10 and since 10 &gt; 1, there are no valid combination.</p><p>Constraints:<br>2 &lt;&#x3D; k &lt;&#x3D; 9<br>1 &lt;&#x3D; n &lt;&#x3D; 60  </p><p>给 元素重复 无序 数组，求满足条件的子数组，组合问题<br>需要子数组满足的条件：子数组元素和等于某个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinationSumIII</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(result, path, nums, <span class="hljs-number">0</span>, k, n);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> stillNeed)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stillNeed == <span class="hljs-number">0</span> &amp;&amp; level == <span class="hljs-number">0</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level &lt; <span class="hljs-number">0</span> || stillNeed &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            backtrack(result, path, nums, i+<span class="hljs-number">1</span>, level-<span class="hljs-number">1</span>, stillNeed-nums[i]);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;216&quot;&gt;
&lt;li&gt;Combination Sum III&lt;br&gt;Find all valid combinations of k numbers that sum up to n such that the following conditions are</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>90. Subsets II</title>
    <link href="http://yoursite.com/2022/10/20/No90.%20Subsets%20II/"/>
    <id>http://yoursite.com/2022/10/20/No90.%20Subsets%20II/</id>
    <published>2022-10-19T23:02:02.000Z</published>
    <updated>2023-03-07T14:34:09.624Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/subsets-ii/">https://leetcode.com/problems/subsets-ii/</a></p><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).<br>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [1,2,2]<br>Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]<br></code></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [0]<br>Output: [[],[0]]<br></code></pre></td></tr></table></figure><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10  </p><p>给 元素重复 无序 数组，求所有的子数组，组合问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsetsII</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        backtrack(result, path, nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯法 选择可能性的N叉树，每个叉代表基于当前节点的一种选择可能性(数值一样的选择可能性视作同一种可能性要进行剪枝操作)</span><br><span class="hljs-comment">     * 怎么样写回溯算法(回溯法通用解题模板)</span><br><span class="hljs-comment">     * 1. 画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※: 状态变量start，用来标识当前的选择列表的起始位置。也就是标识每一层的状态</span><br><span class="hljs-comment">     * 2. 根据题意，确立结束条件: 因为每条路径都要加入结果集，所以是统计全路径。start越过数组边界的时候即是结束条件</span><br><span class="hljs-comment">     * 3. 找准选择列表(与函数参数相关),与第一步紧密关联※: 路径即子集</span><br><span class="hljs-comment">     * 4. 判断是否需要剪枝: 需要，因为存在同样的元素所以对于同一个节点往下分别选择一样的元素算同一种可能性</span><br><span class="hljs-comment">     * 5. 作出选择，递归调用，进入下一层</span><br><span class="hljs-comment">     * 6. 撤销选择 返回上一层</span><br><span class="hljs-comment">     * 参考：https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> result 用来记录全部可能的路径的结果 list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 从树的根节点开始往下走到全部叶子节点的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 题目给的集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前节点起始下标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 记得要深拷贝不然传引用的话result list里面全是存的同一个path list的地址</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i]) &#123; <span class="hljs-comment">// 剪枝: 同样的数字不必再进入子树了</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            backtrack(result, path, nums, i+<span class="hljs-number">1</span>);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                List&lt;Integer&gt; subset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i; index &lt;= j; index++) &#123;<br>                    subset.add(nums[index]);<br>                &#125;<br>                result.add(subset);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; subsets)</span> &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; subset : subsets) &#123;<br>            System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subset.size(); i++) &#123;<br>                System.out.print(subset.get(i));<br>                <span class="hljs-keyword">if</span> (i != subset.size()-<span class="hljs-number">1</span>)<br>                    System.out.print(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/subsets-ii/&quot;&gt;https://leetcode.com/problems/subsets-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given an integer array nums that</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>No78. Subsets</title>
    <link href="http://yoursite.com/2022/10/07/No78.Subsets/"/>
    <id>http://yoursite.com/2022/10/07/No78.Subsets/</id>
    <published>2022-10-07T09:02:02.000Z</published>
    <updated>2023-03-05T10:51:40.102Z</updated>
    
    <content type="html"><![CDATA[<p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [1,2,3]<br>Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br></code></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [0]<br>Output: [[],[0]]<br></code></pre></td></tr></table></figure><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10  </p><p>All the numbers of nums are unique.</p><hr><p>给 元素不重复 无序 数组，求所有的子数组，组合问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subsets</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        backtrack(result, path, nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯法 求不重复元素数组的全组合 子集</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> result 全部子集列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 尝试选择元素的可能性树的从根节点开始到当前节点的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 不重复元素数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前准备开始尝试start index后的全部数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-comment">// 因为是求全部子数组，所以需要遍历完整棵树，递归出口就是 start == nums.length 可省略</span><br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 不需要剪枝，不存在重复元素</span><br>            path.add(nums[i]);<br>            backtrack(result, path, nums, i+<span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Given an integer array nums of unique elements, return all possible subsets (the power set).&lt;/p&gt;
&lt;p&gt;The solution set must not contain dup</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>JVM-12_执行引擎</title>
    <link href="http://yoursite.com/2022/08/24/JVM-12-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2022/08/24/JVM-12-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2022-08-24T02:14:37.000Z</published>
    <updated>2023-03-05T10:43:41.847Z</updated>
    
    <content type="html"><![CDATA[<p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><p><img src="/images/image-20200710082141643.png" alt="image-20200710082141643"></p><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><p><img src="/images/image-20200710082433146.png" alt="image-20200710082433146"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><p><img src="/images/image-20200710083036258.png" alt="image-20200710083036258"></p><p>我们用一个总的图，来说说 解释器和编译器</p><p><img src="/images/image-20200710083656277.png" alt="image-20200710083656277"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器&lt;/p&gt;
&lt;h2 id=&quot;Java代码编译和执行过程&quot;&gt;&lt;a href=&quot;#Java代码编译和执行过程&quot; class=&quot;headerlink&quot; title=&quot;Java代码编译和执行过程&quot;&gt;&lt;/a&gt;Java代码</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop</title>
    <link href="http://yoursite.com/2022/08/19/Hadoop/"/>
    <id>http://yoursite.com/2022/08/19/Hadoop/</id>
    <published>2022-08-19T09:38:04.000Z</published>
    <updated>2023-03-05T10:40:21.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Hadoop："><a href="#Hadoop：" class="headerlink" title="Hadoop："></a>Hadoop：</h3><p>Hadoop是一个框架，它是由Java语言来实现的。Hadoop是处理大数据技术.Hadoop可以处理云计算产生大数据。</p><p>CDH商业版：</p><p>Cloudera CDH是Hadoop的一个版本，比Apache Hadoop的优点如下：</p><ol><li>CDH基于稳定版Apache Hadoop，并应用了最新Bug修复或者Feature的Patch。Cloudera常年坚持季度发行Update版本，年度发行Release版本，更新速度比Apache官方快，而且在实际使用过程中CDH表现无比稳定，并没有引入新的问题。</li><li>Cloudera官方网站上安装、升级文档详细，省去Google时间。</li><li>CDH支持Yum&#x2F;Apt包，Tar包，RPM包，Cloudera Manager四种方式安装，总有一款适合您。官方网站推荐Yum&#x2F;Apt方式安装，其好处如下：</li></ol><ul><li>联网安装、升级，非常方便。当然你也可以下载rpm包到本地，使用Local Yum方式安装。</li><li>自动下载依赖软件包，比如要安装Hive，则会级联下载、安装Hadoop。</li><li>Hadoop生态系统包自动匹配，不需要你寻找与当前Hadoop匹配的Hbase，Flume，Hive等软件，Yum&#x2F;Apt会根据当前安装Hadoop版本自动寻找匹配版本的软件包，并保证兼容性。</li><li>自动创建相关目录并软链到合适的地方（如conf和logs等目录）；自动创建hdfs, mapred用户，hdfs用户是HDFS的最高权限用户，mapred用户则负责mapreduce执行过程中相关目录的权限。</li></ul><h3 id="大数据的4个V"><a href="#大数据的4个V" class="headerlink" title="大数据的4个V:"></a>大数据的4个V:</h3><ol><li>Velocity：实现快速的数据流传</li><li>Variety： 具有多样的数据类型</li><li>Volume： 存有海量的数据规模（TB，PB，EB级别）</li><li>Value：存在着巨大的价值</li></ol><hr><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><img src="Hadoop项目结构图.jpg" /><p>Hadoop实际上就是谷歌三宝的开源实现，</p><p>Hadoop MapReduce对应Google MapReduce，</p><p>HBase对应BigTable，</p><p>HDFS对应GFS。HDFS（或GFS）为上层提供高效的非结构化存储服务，</p><p>HBase（或BigTable）是提供结构化数据服务的分布式数据库，Hadoop MapReduce（或Google MapReduce）是一种并行计算的编程模型，用于作业调度。</p><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。</p><h3 id="HDFS-Hadoop-Distributed-File-System-："><a href="#HDFS-Hadoop-Distributed-File-System-：" class="headerlink" title="HDFS(Hadoop Distributed File System)："></a>HDFS(Hadoop Distributed File System)：</h3><ul><li>默认的最基本的存储单位是64M的数据块。</li><li>和普通文件系统相同的是，HDFS中的文件是被分成64M一块的数据块存储的。</li><li>不同于普通文件系统的是，HDFS中，如果一个文件小于一个数据块的大小，并不占用整个数据块存储空间。</li></ul><h3 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h3><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。</p><h3 id="联机事务处理OLTP-On-line-Transaction-Processing-、联机分析处理OLAP-On-Line-Analytical-Processing"><a href="#联机事务处理OLTP-On-line-Transaction-Processing-、联机分析处理OLAP-On-Line-Analytical-Processing" class="headerlink" title="联机事务处理OLTP(On-line Transaction Processing)、联机分析处理OLAP(On-Line Analytical Processing)"></a>联机事务处理OLTP(On-line Transaction Processing)、联机分析处理OLAP(On-Line Analytical Processing)</h3><p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 </p><img src="OLTP与OLAP之间的比较.jpg" /><p>分析型数据不允许update、delete操作</p><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><p>Sqoop(发音：skup)是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p><h3 id="ZooKepper"><a href="#ZooKepper" class="headerlink" title="ZooKepper"></a>ZooKepper</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。<br>ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p><h3 id="Mahout"><a href="#Mahout" class="headerlink" title="Mahout"></a>Mahout</h3><img src="Mahout.PNG" /><p>Mahout 是 Apache Software Foundation（ASF） 旗下的一个开源项目，提供一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。</p><h2 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h2><h3 id="支持平台"><a href="#支持平台" class="headerlink" title="支持平台"></a>支持平台</h3><ul><li>GNU&#x2F;Linux是产品开发和运行的平台。Hadoop已在有2000个节点的GNU&#x2F;Linux主机组成的集群系统上得到验证。</li><li>Win32平台是作为<code>开发平台</code>支持的。由于分布式操作尚未在Win32平台上充分测试，所以还不作为一个<code>生产平台</code>被支持。</li></ul><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><h4 id="安装-VMware"><a href="#安装-VMware" class="headerlink" title="安装 VMware"></a>安装 VMware</h4><h4 id="安装-Ubuntu"><a href="#安装-Ubuntu" class="headerlink" title="安装 Ubuntu"></a>安装 Ubuntu</h4><h4 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h4><p>解压<code>tar -vzfx jdk-1.7.0.tar.gz</code></p><p>配环境变量<code>sudo vim /etc/profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/home/master0/Desktop/jkd1.7.0_80<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>使配置文件生效：<code>source /etc/profile</code></p><h4 id="安装Hadoop-1"><a href="#安装Hadoop-1" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h4><p>配环境变量<code>sudo vim /etc/profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/home/master0/Desktop/jdk1.7.0_80<br><span class="hljs-built_in">export</span> HADOOP_HOME=/home/master0/Desktop/hadoop-2.6.0<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar:<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-2.6.0.jar:<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-2.6.0.jar:<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-1.2.jar:<span class="hljs-variable">$CLASSPATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HADOOP_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>配置<code>~/hadoop-2.6.0/etc/hadoop/hadoop-env.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># The java implementation to use.</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/home/master0/Desktop/jdk1.7.0_80<br></code></pre></td></tr></table></figure><h4 id="测试hadoop"><a href="#测试hadoop" class="headerlink" title="测试hadoop"></a>测试hadoop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop version<br></code></pre></td></tr></table></figure><hr><h4 id="使用hadoop的本地单独模式"><a href="#使用hadoop的本地单独模式" class="headerlink" title="使用hadoop的本地单独模式"></a>使用hadoop的本地单独模式</h4><p>对某目录下的文档进行单词数的统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span>  /home/hadoop/<br>$ <span class="hljs-built_in">mkdir</span>  input<br>$ <span class="hljs-built_in">cp</span>   <span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop/*.xml   input/<br>$ hadoop  jar <span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar grep input output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span><br>$ <span class="hljs-built_in">cat</span> output/*<br></code></pre></td></tr></table></figure><h4 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h4><p>修改主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/hostname<br></code></pre></td></tr></table></figure><hr><h4 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/network/interfaces<br></code></pre></td></tr></table></figure><p>编辑-&gt;虚拟网络编辑器-&gt;查看NAT模式的子网地址</p><p>例如为：231</p><p>master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto eth0<br>iface eth0 inet static<br>address 192.168.231.129<br>netmask 255.255.255.0<br>network 192.168.231.0<br>boardcast 192.168.231.255<br>gateway 192.168.231.2<br>dns-nameservers 192.168.1.1 8.8.8.8 8.8.8.4<br><br>ping 192.168.231.130<br></code></pre></td></tr></table></figure><p>serve1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto eth0<br>iface eth0 inet static<br>address 192.168.231.130<br>netmask 255.255.255.0<br>network 192.168.231.0<br>boardcast 192.168.231.255<br>gateway 192.168.231.2<br>dns-nameservers 192.168.1.1 8.8.8.8 8.8.8.4<br><br>ping 192.168.231.129<br></code></pre></td></tr></table></figure><p>若访问不了网页的话可以将物理机的dns填写在dns-nameservers第一个</p><p>若拖文件拖不进虚拟机需检查：</p><p>虚拟机ping与其对应的模式的虚拟网卡可不可以ping通</p><p>主机ping与虚拟机可不可以ping通</p><p>VMware Network Adapter VMnet1:桥接模式虚拟网卡</p><p>VMware Network Adapter VMnet8:NAT模式虚拟网卡</p><h4 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/hosts<br><br>192.168.231.129  master<br>192.168.231.130  serve1<br>192.168.231.131  serve2<br></code></pre></td></tr></table></figure><h4 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ssh<br></code></pre></td></tr></table></figure><p>安装完毕就会出现<code>/home/master/.ssh</code>文件夹</p><p>然后需要生成了一个公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -P <span class="hljs-string">&#x27;&#x27;</span><br><br>会生成<br>id_rsa  id_rsa.pub  known_hosts<br></code></pre></td></tr></table></figure><p>id_rsa为私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">-----BEGIN RSA PRIVATE KEY-----<br>MIIEpAIBAAKCAQEAp6JLYxM9lm/ciNG5SuAd/0WBBY0VN98w1KLad5GrkZhM5iZ1<br>mKnl1JHhT14//QSqtJ/tAAo8P1EZspvziS1q77DVBF4L/kInl0KEZOiFWMUOKqDj<br>y+TWLSZmBK9uP5J2cb2wnIMZ4HeWw0y8hnaCpfg4FNVm8WL/EQh++EHx4VBQv0bt<br>4s3qZ9LgYM0MGDrizYKCZ92vRE2CVgLlpAzXvD2uFfxlFwJl02l35fjaIW2ed6PV<br>HrnT8D6BrpUIdKWzWsevj3W6IfO0upBtqOygJw0RxYSx646nDDdFXIk7bzdVFXdr<br>sOjOblsPGqTJs+aApEQB3avOUZI0EixCr2h7/wIDAQABAoIBAQCY1je1lQ1J46NG<br>ezBdPAkdfNktnnwB/NQginp1GbM7g4hZLid5kS2iqX6rRltA7MhW9pi2uJ5FfEPZ<br>vKZGI8qjzq3o1XZJ0zcVief7uKQbU06fPyFx/KnpcGEDVI9IFtk2yqQDjuRA68fh<br>OE2KqvJjL/Sxyf+ZhZDYjs50ums16PHxXlhAaP8EI78Dcff5sx+ZoKTVGum4Jrdl<br>h0cXeDBcxJZg7wEtHPEUrduaiwEv88fD7aw2QwsYdCuPECncltR57iPi95hr7uaW<br>XdtRZ+mAey5sBxJmZKrlPE6kK3yAvSs1tP0yz4R4azAYQqTpLmxcfMrqWRwb3IMA<br>9Rl98FIBAoGBANpNaYJgaTvDT2Nski6sTu1oPefow4tosvPE1jZ/gWXExJ9m1OiI<br>GcZGG0nM+UCx85+//B6gyLdvmUGgxN9vzmY3myuhQ9iesep7W+DiqDnz2J/VRM98<br>eEso6P1jevlC90WJh1wNrVIuzxuN/5A5LghjNNuHCnZzJTRuSKjISjRhAoGBAMSU<br>9hdNDliOXDIIRs/vjwiRuLvbECMFqETSyFdnc91dAi2cYfwlfKFlWGSPFO/LuTvL<br>9PfWaKgfuAzMiZ5JoMPlo5iX8atX1V4Naz7e3OBR9rhyD0oO4aNyKtvDv7tIWTxm<br>eWw/4hlmPp/wGYgfxlPOrbVfJcESYk9FmRxxeoxfAoGAP87ozCcKG2HXTqRphiLv<br>Xw1dKvAqWBFeXUpnor5aQDjnkAAqs100y3OqfkPfhz18jHE9bGZqxNNl5HztjrHL<br>jq0qOfKFNkgMkRFFpdIagfX4l59q4YrsTmvCzm3JgBpG1JiCbDHDO4ZbGx7CWJGe<br>Fu2IgbJTKJQ3h7/ElTEWH4ECgYEAoxOr/vJ2hzI5+2twSwlBT+uLI5P8FAGacNWn<br>SxLQRH/m0a2cf48dj8pCBNHJnZAUby2oX30nvujpRvza4UvVKQ20pF7QJcMshuR8<br>5l/9Pb3g/WvpkRc9SdjpAvylbpj7JicgbZOlXkq6gvWsSIeLgHTBF+gBquQ0V+y1<br>sqnU7uMCgYBMSR2QDG5TuSp7pNOFBFuqhOCrUHZmKqoHCZ7rSh3etxc8D5tLXciE<br>APNWfGqSE2aT/PJgqNoxl5p42bnZrv3cXJuiD9Wid6yFzDH0oUa9K66vy1SWV+B8<br>3rHha5wLzizgNUQZjh1XSndp1WekYCLjV+Bn8b/odBClcHKX7M/BOg==<br>-----END RSA PRIVATE KEY-----<br></code></pre></td></tr></table></figure><p>id_rsa.pub为公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCnoktjEz2Wb9yI0blK4B3/RYEFjRU33zDUotp3kauRmEzmJnWYqeXUkeFPXj/9BKq0n+0ACjw/URmym/OJLWrvsNUEXgv+QieXQoRk6IVYxQ4qoOPL5NYtJmYEr24/knZxvbCcgxngd5bDTLyGdoKl+DgU1WbxYv8RCH74QfHhUFC/Ru3izepn0uBgzQwYOuLNgoJn3a9ETYJWAuWkDNe8Pa4V/GUXAmXTaXfl+NohbZ53o9UeudPwPoGulQh0pbNax6+Pdboh87S6kG2o7KAnDRHFhLHrjqcMN0VciTtvN1UVd2uw6M5uWw8apMmz5oCkRAHdq85RkjQSLEKvaHv/ master@ubuntu<br></code></pre></td></tr></table></figure><p>要想免密登录则需要被免密登录方的公钥：这里可以先将各台分机的公钥发送给主机master，然后再由master合成一个文件再发送给分机。这样每台机器都会有其它所有机器的公钥</p><p>生成公钥文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">authorized_keys如下，其实和公钥相同：<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCnoktjEz2Wb9yI0blK4B3/RYEFjRU33zDUotp3kauRmEzmJnWYqeXUkeFPXj/9BKq0n+0ACjw/URmym/OJLWrvsNUEXgv+QieXQoRk6IVYxQ4qoOPL5NYtJmYEr24/knZxvbCcgxngd5bDTLyGdoKl+DgU1WbxYv8RCH74QfHhUFC/Ru3izepn0uBgzQwYOuLNgoJn3a9ETYJWAuWkDNe8Pa4V/GUXAmXTaXfl+NohbZ53o9UeudPwPoGulQh0pbNax6+Pdboh87S6kG2o7KAnDRHFhLHrjqcMN0VciTtvN1UVd2uw6M5uWw8apMmz5oCkRAHdq85RkjQSLEKvaHv/ master@ubuntu<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">分机serve1复制公钥到master主机上：<br>scp .ssh/id_rsa.pub master@master:/home/master/id_rsa_1.pub<br>将分机serve1的公钥追加到主机的authorized_keys上<br><span class="hljs-built_in">cat</span> id_rsa_1.pub &gt;&gt; .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>重复以上两步直到主机master的authorized_keys有所有分机的公钥，再进行分发操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp .ssh/authorized_keys master@serve1:/home/master/.ssh/authorized_keys<br>scp .ssh/authorized_keys master@serve2:/home/master/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>分发完毕后即可进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh master<br>ssh serve1<br>能连接成功即可<br></code></pre></td></tr></table></figure><p>SSH免密码设置失败解决</p><ol><li>权限问题</li></ol><p>.ssh目录，以及&#x2F;home&#x2F;当前用户 需要700权限，参考以下操作调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span>   <span class="hljs-built_in">chmod</span>   777   ~/.ssh<br><br><span class="hljs-variable">$sudo</span>  <span class="hljs-built_in">chmod</span> 700  /home/当前用户<br></code></pre></td></tr></table></figure><p>.ssh目录下的authorized_keys文件需要600或644权限，参考以下操作调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span> <span class="hljs-built_in">chmod</span>   644   ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><ol start="2"><li>StrictModes问题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span> gedit /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\<span class="hljs-comment">#StrictModes yes</span><br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">StrictModes no<br></code></pre></td></tr></table></figure><p>如果还不行，可以用<code>ssh -vvv 目标机器ip</code> 查看详情</p><h4 id="配置Hadoop集群"><a href="#配置Hadoop集群" class="headerlink" title="配置Hadoop集群"></a>配置Hadoop集群</h4><p>以下将会修改多个Hadoop配置文件均位于<code>hadoop-2.6.0/etc</code>目录下</p><p>修改：<code>hadoop-env.sh</code> 、<code>yarn-env.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/hadoop-env.sh<br><br><span class="hljs-comment"># The java implementation to use.</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/home/master/jdk1.7.0_80<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/yarn-env.sh<br></code></pre></td></tr></table></figure><p>core-site.xml</p><p>core-site.xml的完整参数请参考: <a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/core-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/core-default.xml</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/core-site.xml<br></code></pre></td></tr></table></figure><p><code>/home/hadoop/tmp</code> 目录如不存在，则先mkdir手动创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://master:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-comment">&lt;!--主机名:端口号--&gt;</span>     <br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-comment">&lt;!--/tmp/hadoop-$&#123;user.name&#125;--&gt;</span>   <br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>hdfs-site.xml</p><p>hdfs-site.xml的完整参数请参考: <a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/hdfs-site.xml<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.ipc.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0.0.0.0:50020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.http.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0.0.0.0:50075<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/home/master/data/namenode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--元数据--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/home/master/data/datanode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据块--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>slave1:9001<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--备份数量--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.permissions<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--权限验证--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置slaves分机列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/slaves<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">master<br>serve1<br></code></pre></td></tr></table></figure><p>分发配置文件到集群的其它机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r hadoop-2.6.0/etc/hadoop/ master@serve1:/home/master/hadoop-2.6.0/etc/<br></code></pre></td></tr></table></figure><p>格式化hdfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs namenode -format<br></code></pre></td></tr></table></figure><p>等看到执行信息有has been successfully formatted表示格式化ok</p><p>启动 dfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-2.6.0/sbin/start-dfs.sh<br></code></pre></td></tr></table></figure><p>验证hadoop是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$jps</span><br>显示有：<br>4895 DataNode<br>4775 NameNode<br></code></pre></td></tr></table></figure><h4 id="安装-MapReduce"><a href="#安装-MapReduce" class="headerlink" title="安装 MapReduce"></a>安装 MapReduce</h4><p>mapred-site.xml的完整参数请参考<a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml</a></p><p>将mapred-site.xml.template改名成mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>yarn-site.xml</p><p>yarn-site.xml的完整参数请参考: <a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-yarn/hadoop-yarn-common/yarn-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-yarn/hadoop-yarn-common/yarn-default.xml</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8030<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8025<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8040<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="启动yarn"><a href="#启动yarn" class="headerlink" title="启动yarn"></a>启动yarn</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-2.6.0/sbin/start-yarn.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$jps</span><br>多了ResourceManager和NodeManager表示启动yarn成功<br>SecondaryNameNode<br>ResourceManager<br>NameNode<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-2.6.0/sbin/start-dfs.sh<br>hadoop-2.6.0/sbin/start-yarn.sh<br><br>jps<br>master节点上有几下3个进程：<br>7482 ResourceManager<br>7335 SecondaryNameNode<br>7159 NameNode<br>slave1、slave2上有几下2个进程：<br>2296 DataNode<br>2398 NodeManager<br><br>hadoop-2.6.0/sbin/stop-dfs.sh<br>hadoop-2.6.0/sbin/stop-yarn.sh<br></code></pre></td></tr></table></figure><p>或打开浏览器访问：hdfs管理界面: <a href="http://master:50070/">http://master:50070</a></p><p>yarn的管理界面: <a href="http://master:8088/">http://master:8088/</a></p><p>查看hadoop状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfsadmin -report //查看hdfs的状态报告<br><br>yarn  node -list   //查看yarn的基本信息<br><br>Secondary// TODO<br>NameNode 元数据<br>DataNode 数据块<br></code></pre></td></tr></table></figure><hr><h2 id="HDFS文件系统"><a href="#HDFS文件系统" class="headerlink" title="HDFS文件系统"></a>HDFS文件系统</h2><p>hadoop实现了一个分布式文件系统HDFS(Hadoop Distributed File System)</p><img src="HDFS架构.png" /><p>元数据：用于描述数据的数据。</p><p>NameNode 主服务器，用来管理整个文件系统的命名空间和元数据，以及处理来自外界的文件访问请求。整个集群中只有一个。含有：</p><ol><li>命名空间：整个分布式文件系统的目录结构</li><li>数据块与文件名的映射表</li><li>每个数据块副本的位置信息(每个数据块默认3个副本)</li></ol><p>元数据保存在NameNode的内存当中(1G内存可存放1000000个块对应的元数据信息，缺省每块64M计算可对应64T实际数据)</p><p>DataNode通过心跳包(Heartbeats)与NameNode通讯</p><p>HA(High Available)高可用</p><p>DataNode 用来实际存储和管理文件的数据块</p><p>数据块-64M(128M)数据块+备份公用一个ID</p><p>主从架构：1个NameNode对应n个DataNode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>client-java app -&gt; data NameNode(客户端向NameNode发起请求)<br>client-sid datanode-&gt; datanode -&gt; r/w -&gt; dfs file(NameNode返回对应的DataNode给客户端让客户端来通过DataNode进行访问)<br>                   -&gt; namenode(向NameNode汇报情况)<br></code></pre></td></tr></table></figure><h3 id="JVM从HDFS读取文件流程"><a href="#JVM从HDFS读取文件流程" class="headerlink" title="JVM从HDFS读取文件流程"></a>JVM从HDFS读取文件流程</h3><img src="HDFS数据的读取过程.png" /><p>client会从距离最近的机子上读取</p><h4 id="HDFS文件存储的组织与读写："><a href="#HDFS文件存储的组织与读写：" class="headerlink" title="HDFS文件存储的组织与读写："></a>HDFS文件存储的组织与读写：</h4><p>数据写入</p><ol><li>客户端调用FileSystem 实例的create 方法，创建文件。NameNode 通过一些检查，比如文件是否存在，客户端是否拥有创建权限等;通过检查之后，在NameNode 添加文件信息。注意，因为此时文件没有数据，所以NameNode 上也没有文件数据块的信息。</li><li>创建结束之后， HDFS 会返回一个输出流DFSDataOutputStream 给客户端。</li><li>客户端调用输出流DFSDataOutputStream 的write 方法向HDFS 中对应的文件写入数据。</li><li>数据首先会被分包，这些分包会写人一个输出流的内部队列Data 队列中，接收完数据分包，输出流DFSDataOutputStream 会向NameNode 申请保存文件和副本数据块的若干个DataNode ， 这若干个DataNode 会形成一个数据传输管道。DFSDataOutputStream 将数据传输给距离上最短的DataNode ，这个DataNode 接收到数据包之后会传给下一个DataNode 。数据在各DataNode之间通过管道流动，而不是全部由输出流分发，以减少传输开销。</li><li>因为各DataNode 位于不同机器上，数据需要通过网络发送，所以，为了保证所有DataNode 的数据都是准确的，接收到数据的DataNode 要向发送者发送确认包(ACK Packet ) 。对于某个数据块，只有当DFSDataOutputStream 收到了所有DataNode 的正确ACK. 才能确认传输结束。DFSDataOutputStream 内部专门维护了一个等待ACK 队列，这一队列保存已经进入管道传输数据、但是并未被完全确认的数据包。</li><li>不断执行第3 - 5 步直到数据全部写完，客户端调用close 关闭文件。</li><li>DFSDataInputStream 继续等待直到所有数据写人完毕并被确认，调用complete 方法通知NameNode 文件写入完成。NameNode 接收到complete 消息之后，等待相应数量的副本写入完毕后，告知客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看文件<br>hadoop fs -<span class="hljs-built_in">cat</span> /output/part-00000<br>查看hadoop文件系统<br>hadoop fs -<span class="hljs-built_in">ls</span> /<br>hadoop fs -<span class="hljs-built_in">ls</span> -R /output<br>hadoop fs -<span class="hljs-built_in">ls</span> /output<br>创建文件夹<br>hadoop fs -<span class="hljs-built_in">mkdir</span> /tmp<br>hadoop fs -<span class="hljs-built_in">mkdir</span> /input<br>hadoop fs -<span class="hljs-built_in">mkdir</span> /output<br>将文件放到hadoop文件系统-put 当前路径 /home/master/input 放到的路径<br>hadoop fs -put /home/master/input/* /input<br>hadoop fs -get /output output<br><br>hadoop fs -<span class="hljs-built_in">rm</span> -R /input<br>hadoop fs -<span class="hljs-built_in">rm</span> -r /output/output<br>hadoop fs -<span class="hljs-built_in">mv</span> /output/output/part-r-00000 /output/part-r-00000<br></code></pre></td></tr></table></figure><p>运行例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop jar hadoop-2.6.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar grep /input /output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Hadoop-IO"><a href="#Hadoop-IO" class="headerlink" title="Hadoop IO"></a>Hadoop IO</h3><p>HDFS数据完整性</p><p>校验和+后台进程</p><p>文件数据结构-解决大量小文件</p><p>SequenceFile：用流来读写</p><p>MapFile</p><h2 id="MapReduce-1"><a href="#MapReduce-1" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>Map&#x2F;Reduce是一个用于大规模数据处理的分布式计算模型，它最初是由Google工程师设计并实现的，Google已经将它完整的MapReduce论文公开发布了。其中对它的定义是，Map&#x2F;Reduce是一个编程模型（programming model），是一个用于处理和生成大规模数据集（processing and generating large data sets）的相关的实现。用户定义一个map函数来处理一个key&#x2F;value对以生成一批中间的key&#x2F;value对，再定义一个reduce函数将所有这些中间的有着相同key的values合并起来。很多现实世界中的任务都可用这个模型来表达。</p><img src="how-hadoop-runs-a-mapreduce-kob.jpg" /><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><img src="hadoop-mapreduce-framework-architecture.jpg" /><p>Mapper、Reduce</p><blockquote><p>运行于Hadoop的MapReduce应用程序最基本的组成部分包括一个Mapper和一个Reducer类，以及一个创建JobConf的执行程序，在一些应用中还可以包括一个Combiner类，它实际也是Reducer的实现。</p></blockquote><p>JobTracker、TaskTracker</p><blockquote><p>它们都是由一个master服务JobTracker和多个运行于多个节点的slaver服务TaskTracker两个类提供的服务调度的。master负责调度job的每一个子任务task运行于slave上，并监控它们，如果发现有失败的task就重新运行它，slave则负责直接执行每一个task。TaskTracker都需要运行在HDFS的DataNode上，而JobTracker则不需要，一般情况应该把JobTracker部署在单独的机器上。</p></blockquote><p>JobClient</p><blockquote><p>每一个job都会在用户端通过JobClient类将应用程序以及配置参数Configuration打包成jar文件存储在HDFS，并把路径提交到JobTracker的master服务，然后由master创建每一个Task（即MapTask和ReduceTask）将它们分发到各个TaskTracker服务中去执行。</p></blockquote><p>JobInProgress</p><blockquote><p>JobClient提交job后，JobTracker会创建一个JobInProgress来跟踪和调度这个job，并把它添加到job队列里。JobInProgress会根据提交的job jar中定义的输入数据集（已分解成FileSplit）创建对应的一批TaskInProgress用于监控和调度MapTask，同时在创建指定数目的TaskInProgress用于监控和调度ReduceTask，缺省为1个ReduceTask。</p></blockquote><p>TaskInProgress</p><blockquote><p>JobTracker启动任务时通过每一个TaskInProgress来launchTask，这时会把Task对象（即MapTask和ReduceTask）序列化写入相应的TaskTracker服务中，TaskTracker收到后会创建对应的TaskInProgress（此TaskInProgress实现非JobTracker中使用的TaskInProgress，作用类似）用于监控和调度该Task。启动具体的Task进程是通过TaskInProgress管理的TaskRunner对象来运行的。TaskRunner会自动装载job jar，并设置好环境变量后启动一个独立的java child进程来执行Task，即MapTask或者ReduceTask，但它们不一定运行在同一个TaskTracker中。</p></blockquote><p>MapTask、ReduceTask</p><blockquote><p>一个完整的job会自动依次执行Mapper、Combiner（在JobConf指定了Combiner时执行）和Reducer，其中Mapper和Combiner是由MapTask调用执行，Reducer则由ReduceTask调用，Combiner实际也是Reducer接口类的实现。Mapper会根据job jar中定义的输入数据集按&lt;key1,value1&gt;对读入，处理完成生成临时的&lt;key2,value2&gt;对，如果定义了Combiner，MapTask会在Mapper完成调用该Combiner将相同key的值做合并处理，以减少输出结果集。MapTask的任务全完成即交给ReduceTask进程调用Reducer处理，生成最终结果&lt;key3,value3&gt;对。这个过程在下一部分再详细介绍。</p></blockquote><img src="mapreduce运行机制.jpg" /><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="单词统计案例"><a href="#单词统计案例" class="headerlink" title="单词统计案例"></a>单词统计案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Mapper&lt;LongWritable, Text, Text, IntWritable&gt;<br>public void map(LongWritable k1, Text v1, Context context)<br>输入LongWritable k1, Text v1(LongWritable, Text)：序号,行<br>处理：从行中split出每个单词，并将每个单词的值设为1<br>输出Context context(Text, IntWritable)：单词,所有该单词的值的集合(数组)<br><br>Reducer&lt;Text, IntWritable, Text, IntWritable&gt;<br>public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)<br>输入Text key, Iterable&lt;IntWritable&gt; values(Text, IntWritable)：单词,所有该单词的值的集合(数组)<br>处理：使用迭代器Iterator来迭代每个单词的值的数组并将数组中的每个元素相加，和作为该单词新的值<br>输出Context context(Text, IntWritable)：单词,单词出现次数<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mypro1;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;   <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWordCount</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;&#123;  <br><span class="hljs-comment">// 输入LongWritable k1, Text v1(LongWritable, Text)：序号,行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable k1, Text v1, Context context)</span> <br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br><span class="hljs-comment">// 处理：从行中split出每个单词，并将每个单词的值设为1</span><br>String[]  lines= v1.toString().split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br><span class="hljs-keyword">for</span>(String word: lines)&#123;<br><span class="hljs-comment">// 输出Context context(Text, IntWritable)：单词,所有该单词的值的集合(数组)</span><br>context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(word), <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(<span class="hljs-number">1</span>));<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt;&#123;<br><span class="hljs-comment">// 输入Text key, Iterable&lt;IntWritable&gt; values(Text, IntWritable)：单词,所有该单词的值的集合(数组)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span><br> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br><span class="hljs-comment">// 处理：使用迭代器Iterator来迭代每个单词的值的数组并将数组中的每个元素相加，和作为该单词新的值</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>Iterator&lt;IntWritable&gt;  it = values.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>sum+= it.next().get();<br>&#125;<br><span class="hljs-comment">// 输出Context context(Text, IntWritable)：单词,单词出现次数</span><br>context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(sum));    <br> <br>System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>);<br>&#125;<br>    <br>&#125;<br><br><span class="hljs-comment">// 定义输入文件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String INPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/input/hdfs-site.xml&quot;</span>;<br><span class="hljs-comment">// 定义输出结果到目录</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String OUTPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/output/c/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 加载配置文件</span><br>Configuration  conf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>FileSystem  fs=FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH),conf);<br> <span class="hljs-comment">// 若输出目录已存在则删除</span><br><span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br><span class="hljs-comment">// 开启一个作业</span><br><span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf,<span class="hljs-string">&quot;myjob&quot;</span>);<br><span class="hljs-comment">// 设置作业jar包</span><br>job.setJarByClass(MyWordCount.class);<br><span class="hljs-comment">// 设置作业Mapper类</span><br>job.setMapperClass(MyMapper.class);<br><span class="hljs-comment">// 设置作业Reducer类</span><br>job.setReducerClass(MyReduce.class);<br><br><span class="hljs-comment">// Mapper&lt;LongWritable, Text, MyK2, LongWritable&gt;定义Mapper泛型输出类</span><br><br><span class="hljs-comment">// Reducer&lt;Text, IntWritable, Text, IntWritable&gt;定义Reducer泛型输出类，因输入与输出相同可省略</span><br>job.setOutputKeyClass(Text.class);<br>job.setOutputValueClass(IntWritable.class);<br><br><span class="hljs-comment">// 使用文件读取系统读取文件到作业</span><br>FileInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH));<br><span class="hljs-comment">// 使用文件读取系统输出作业结果</span><br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 5<br>2 1<br>2 2<br>9 3<br>1 8<br>4 5<br>6 2<br>0 7<br><br>Mapper&lt;LongWritable, Text, MyK2, LongWritable&gt;<br>public void map(LongWritable k1, Text v1, Context context)<br>输入LongWritable k1, Text v1(LongWritable, Text)：序号,行<br>处理<br>输出Context context(MyK2, LongWritable)：两个数,后面那个数(与排序无关,为空都可以)<br><br>Reducer&lt;MyK2, LongWritable,LongWritable, LongWritable&gt;<br>public void reduce(MyK2 myk2, Iterable&lt;LongWritable&gt; v2s,Context context)<br>输入MyK2 myk2, Iterable&lt;LongWritable&gt; v2s(MyK2, LongWritable)：两个数，后面那个数(与排序无关,为空都可以)<br>处理<br>输出Context context(LongWritable, LongWritable)：第一个数,第二个数<br><br>07<br>18<br>21<br>22<br>45<br>62<br>75<br>93<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> demo;<br><br><span class="hljs-keyword">import</span> java.io.DataInput;<br><span class="hljs-keyword">import</span> java.io.DataOutput;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.WritableComparable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;   <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyK2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WritableComparable</span>&lt;MyK2&gt;&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> myk2;  <br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> myv2;  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyK2</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// TODO Auto-generated constructor stub  </span><br> &#125;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyK2</span><span class="hljs-params">(<span class="hljs-type">long</span> myk2, <span class="hljs-type">long</span> myv2)</span> &#123;  <br>     <span class="hljs-built_in">this</span>.myk2 = myk2;  <br>     <span class="hljs-built_in">this</span>.myv2 = myv2;  <br> &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFields</span><span class="hljs-params">(DataInput in)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-built_in">this</span>.myk2=in.readLong();  <br>        <span class="hljs-built_in">this</span>.myv2=in.readLong();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(DataOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>out.writeLong(myk2);  <br>        out.writeLong(myv2);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyK2 my)</span> &#123;<br><span class="hljs-type">long</span> temp=<span class="hljs-built_in">this</span>.myk2-my.myk2; <br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) temp; <br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.myv2-my.myv2);<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, MyK2, LongWritable&gt;&#123;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable k1, Text v1, Context context)</span> <br> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException<br> &#123;<br>String[]  lines= v1.toString().split(<span class="hljs-string">&quot;\\s&quot;</span>);<br><span class="hljs-type">MyK2</span> <span class="hljs-variable">myK2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyK2</span>(Long.parseLong(lines[<span class="hljs-number">0</span>]), Long.parseLong(lines[<span class="hljs-number">1</span>]));<br>context.write(myK2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(Long.parseLong(lines[<span class="hljs-number">0</span>])));<br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span>);<br> &#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;MyK2, LongWritable,LongWritable, LongWritable&gt;&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(MyK2 myk2, Iterable&lt;LongWritable&gt; v2s,Context context)</span> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException<br> &#123;<br> context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(myk2.myk2), <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(myk2.myv2));    <br> System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>);<br> &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String INPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/input/num&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String OUTPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/output/num/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>Configuration  conf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>FileSystem  fs=FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH),conf);<br> <br><span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>Job  job=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf,<span class="hljs-string">&quot;myjob&quot;</span>);<br><br>job.setJarByClass(Sort.class);<br>job.setMapperClass(MyMapper.class);<br>job.setReducerClass(MyReduce.class);<br><br><span class="hljs-comment">// Mapper&lt;LongWritable, Text, MyK2, LongWritable&gt;定义Mapper泛型输出类</span><br>job.setMapOutputKeyClass(MyK2.class);<br>job.setMapOutputValueClass(LongWritable.class);<br><span class="hljs-comment">// Reducer&lt;MyK2, LongWritable,LongWritable, LongWritable&gt;定义Reducer泛型输出类</span><br>job.setOutputKeyClass(LongWritable.class);<br>job.setOutputValueClass(LongWritable.class);<br><br>FileInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH));<br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="图案例"><a href="#图案例" class="headerlink" title="图案例"></a>图案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：<br>childparent <br>TomLucy<br>TomJack<br>JoneLucy<br>JoneJack<br>LucyMary<br>LucyBen<br>Jack Alice<br>JackJesse<br>TerryAlice<br>TerryJesse<br>PhilipTerry<br>PhilipAlma<br>MarkTerry<br>MarkAlma<br>需求出输入中的所有的孙子与祖父母<br><br><br>Mapper&lt;LongWritable, Text, Text, Text&gt;<br>public void map(LongWritable k1, Text v1, Context context)<br>输入LongWritable k1, Text v1(LongWritable, Text)：序号,行<br>处理：读取行里的数据split，并以关系形式保存(以TomLucy为例)：<br>Tom,1,Tom,Lucy<br>Tom,2,Lucy,Tom<br>输出Context context(Text, Text)：人名，这个人与其他人的关系(数组)<br><br>Reducer&lt;Text, Text, Text, Text&gt;<br>public void reduce(Text key, Iterable&lt;Text&gt; values, Context context)<br>输入Text key, Iterable&lt;Text&gt; values(Text, Text)：人名，这个人与其他人的关系(数组)<br>处理：从数组中读出关系并将与该人有关的符合条件的人加入临时数组并输出<br>输出Context context(Text, Text)：孙子，祖父母<br><br>JoneAlice<br>JoneJesse<br>TomAlice<br>TomJesse<br>JoneMary<br>JoneBen<br>TomMary<br>TomBen<br>MarkAlice<br>MarkJesse<br>PhilipAlice<br>PhilipJesse<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mr;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem ;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.NullWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper.Context;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;   <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGL</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGLMapper</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt;&#123;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable k1, Text v1, Context context)</span> <br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br> <br><span class="hljs-comment">//  1   2  file   tab  ,</span><br>String[]  lines = v1.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br> <br><span class="hljs-keyword">if</span>(lines.length != <span class="hljs-number">2</span> || lines[<span class="hljs-number">0</span>].trim().equals(<span class="hljs-string">&quot;child&quot;</span>))<br><span class="hljs-keyword">return</span>;   <span class="hljs-comment">//child  parent</span><br><br><br>String word1=lines[<span class="hljs-number">0</span>].trim();  <span class="hljs-comment">//  tom</span><br>String word2=lines[<span class="hljs-number">1</span>].trim();  <span class="hljs-comment">//  lucy</span><br><br><br>context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(word1), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-string">&quot;,&quot;</span>+word1+<span class="hljs-string">&quot;,&quot;</span>+word2));<br>context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(word2), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;2&quot;</span>+<span class="hljs-string">&quot;,&quot;</span>+word1+<span class="hljs-string">&quot;,&quot;</span>+word2));<br>    System.out.println(<span class="hljs-string">&quot;map......&quot;</span>+word1+<span class="hljs-string">&quot;-&quot;</span>+word2);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyGLReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, Text, Text, Text&gt;&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* lucy   2+tom+lucy</span><br><span class="hljs-comment">* lucy   1+lucy+mary</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 2--&gt;split[1]  tom</span><br><span class="hljs-comment">* 1--&gt;split[2]  mary</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* k3=tom  v3=mary</span><br><span class="hljs-comment">* */</span><br>List&lt;String&gt;  grandch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>List&lt;String&gt;  grandpa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br> <br>Iterator&lt;Text&gt;  it=values.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>String  lines= it.next().toString();   <span class="hljs-comment">//2+tom+lucy</span><br>String[] words=lines.split(<span class="hljs-string">&quot;,&quot;</span>);      <span class="hljs-comment">//[&quot;2&quot;,&quot;tom&quot;,&quot;lucy&quot;]</span><br><span class="hljs-keyword">if</span>(words[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;<br>grandpa.add(words[<span class="hljs-number">2</span>]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(words[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;2&quot;</span>))&#123;<br>grandch.add(words[<span class="hljs-number">1</span>]);<br><br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span>;<br><br><br>&#125;<br> <br><span class="hljs-keyword">for</span>(String ch:grandch)<br><span class="hljs-keyword">for</span>(String pa:grandpa)&#123;<br>            context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(ch), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(pa)); <br>            System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>+ch+<span class="hljs-string">&quot; - &quot;</span>+pa);<br>&#125;<br> <br>System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>);<br>&#125;<br> <br>       <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(Context context)</span> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br> <br>       <br> <br> <br>&#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String INPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/input/gl.dat&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String OUTPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/output/c/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>Configuration  conf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>FileSystem  fs=FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH),conf);<br> <br><span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>Job  job=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf,<span class="hljs-string">&quot;myjob&quot;</span>);<br><br>job.setJarByClass(MyGL.class);<br>job.setMapperClass(MyGLMapper.class);<br>job.setReducerClass(MyGLReduce.class);<br> <br> <br>job.setOutputKeyClass(Text.class);<br>job.setOutputValueClass(Text.class);<br><br> <br><br>FileInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH));<br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><!--TODO:http://langyu.iteye.com/blog/992916--><!--TODO:http://www.cnblogs.com/zhangchaoyang/articles/2648815.html--><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>矩阵乘法公式：</p><img src="矩阵乘法公式.png" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">矩阵A(4*3)(i*n)<br>1,2,3<br>4,5,0<br>7,8,9<br>10,11,12<br><br>矩阵B(3*2)(n*j)<br>10,15<br>0,2<br>11,9<br><br>根据矩阵乘法的定义：矩阵A的列数=矩阵B的行数，即矩阵A和矩阵B都有相同的n<br>矩阵乘法的结果是产生(i*j)的矩阵C<br><br>矩阵C(4*2)(i*j)<br>43,46<br>40,70<br>169,202<br>232,280<br><br>1*10+2*0+3*11=43<br>1*15+2*2+3*9=46<br><br>计算每个矩阵C中的元素(i,j)都需要矩阵A的(i,r)与矩阵B的(r,j)相乘再加上下一个r取值[1,n]<br>接下来看看进行一个矩阵计算需要哪些信息：<br>因为每次计算r都是从1到n，所以r的值不需要保存进map，<br>需要：计算结果是在C的哪里即(i,j)，A矩阵对应的值，B矩阵对应的值，这个值来自哪个矩阵(A还是B)<br><br>那么如何唯一标识矩阵C的一个元素呢？使用矩阵C的坐标，将C的坐标(i,j)作为key<br>(哪个矩阵,对应的r,矩阵的值)作为value，这样就可以保存进行矩阵计算的全部信息了<br><br>分类讨论：<br>(i,j为计算C的第(i,j)个元素的值，r取值[1,n])<br>对于矩阵A的值：<br>key(i,j) value(a,A的列即r,A[i,r])<br>对于矩阵B的值：<br>key(i,j) value(b,B的列即r,B[r,j])<br><br>分类讨论的计算过程见下图<br></code></pre></td></tr></table></figure><img src="矩阵乘法.png" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> demo;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileSplit;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MatrixProdect</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt; &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<span class="hljs-comment">// 矩阵A的行数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">colNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">// 矩阵B的列数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">rowIndexA</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 矩阵A，当前在第几行</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">rowIndexB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 矩阵B，当前在第几行</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException &#123;<br><br><span class="hljs-type">FileSplit</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> (FileSplit) context.getInputSplit();<br><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> fs.getPath().getName();<br><br>String[] tokens = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">// 读进一行数据</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(fileName)) &#123; <span class="hljs-comment">// 通过文件名判断是矩阵A还是矩阵B</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= colNum; j++) &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(rowIndexA + <span class="hljs-string">&quot;,&quot;</span> + j);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; tokens.length; r++) &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;a,&quot;</span> + (r + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;,&quot;</span> + tokens[r]);<br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span> + fileName + <span class="hljs-string">&quot;(&quot;</span> + k + <span class="hljs-string">&quot;)&quot;</span> + v);<br>context.write(k, v);<br>&#125;<br>&#125;<br>rowIndexA++;<span class="hljs-comment">// 每执行一次map方法，扫描矩阵的下一行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;b&quot;</span>.equals(fileName)) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= rowNum; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; tokens.length; r++) &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(i + <span class="hljs-string">&quot;,&quot;</span> + (r + <span class="hljs-number">1</span>));<br><span class="hljs-type">Text</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;b,&quot;</span> + rowIndexB + <span class="hljs-string">&quot;,&quot;</span> + tokens[r]);<br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span> + fileName + <span class="hljs-string">&quot;(&quot;</span> + k + <span class="hljs-string">&quot;)&quot;</span> + v);<br>context.write(k, v);<br>&#125;<br>&#125;<br>rowIndexB++;<span class="hljs-comment">// 每执行一次map方法，扫描矩阵的下一行</span><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, Text, Text, IntWritable&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException &#123;<br><br>Map&lt;String, String&gt; mapA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>Map&lt;String, String&gt; mapB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br><br><span class="hljs-comment">// 根据矩阵来分类</span><br><span class="hljs-keyword">for</span> (Text value : values) &#123;<br>String[] val = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(val[<span class="hljs-number">0</span>])) &#123;<br>mapA.put(val[<span class="hljs-number">1</span>], val[<span class="hljs-number">2</span>]);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;b&quot;</span>.equals(val[<span class="hljs-number">0</span>])) &#123;<br>mapB.put(val[<span class="hljs-number">1</span>], val[<span class="hljs-number">2</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Iterator&lt;String&gt; mKeys = mapA.keySet().iterator();<br><span class="hljs-keyword">while</span> (mKeys.hasNext()) &#123; <span class="hljs-comment">// 取相同的r值的数相乘</span><br><span class="hljs-type">String</span> <span class="hljs-variable">mkey</span> <span class="hljs-operator">=</span> mKeys.next();<br><span class="hljs-keyword">if</span> (mapB.get(mkey) == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>result += Integer.parseInt(mapA.get(mkey)) * Integer.parseInt(mapB.get(mkey));<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span> + <span class="hljs-string">&quot;(&quot;</span> + key + <span class="hljs-string">&quot;)&quot;</span> + result);<br>context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(result));<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">INPUT_PATH_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://master:9000/input/a&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">INPUT_PATH_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://master:9000/input/b&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://master:9000/output/matrix/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br><span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH), conf);<br><br><span class="hljs-keyword">if</span> (fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br><span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf, <span class="hljs-string">&quot;myjob&quot;</span>);<br><br>job.setJarByClass(MatrixProdect.class);<br>job.setMapperClass(MyMapper.class);<br>job.setReducerClass(MyReduce.class);<br><br>job.setMapOutputKeyClass(Text.class);<br>job.setMapOutputValueClass(Text.class);<br><br>job.setOutputKeyClass(Text.class);<br>job.setOutputValueClass(IntWritable.class);<br><br>FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH_A));<br>FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH_B));<br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>计算方法与上面一样，只是矩阵的存储结构不一样。省略了值为0的元素，对于较大且稀疏的矩阵所占存储空间较小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">行,列,值<br></code></pre></td></tr></table></figure><img src="矩阵乘法2.png" /><!--<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br></code></pre></td></tr></table></figure><p>–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;h3 id=&quot;Hadoop：&quot;&gt;&lt;a href=&quot;#Hadoop：&quot; class=&quot;headerlink&quot; title=&quot;Had</summary>
      
    
    
    
    <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
    <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
    <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Hive</title>
    <link href="http://yoursite.com/2022/08/17/Hive/"/>
    <id>http://yoursite.com/2022/08/17/Hive/</id>
    <published>2022-08-17T12:09:47.000Z</published>
    <updated>2023-03-05T10:41:14.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装hive"><a href="#安装hive" class="headerlink" title="安装hive"></a>安装hive</h2><p>hive–&gt;hql–&gt;hive引擎–&gt;mapreduce Task</p><h3 id="配置mysql数据库"><a href="#配置mysql数据库" class="headerlink" title="配置mysql数据库"></a>配置mysql数据库</h3><p>前置条件：安装数据库mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install mysql-server mysql-client<br></code></pre></td></tr></table></figure><p>启动停止mysql服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo start mysql<br>sudo stop mysql  <br></code></pre></td></tr></table></figure><p>取消本地监听</p><p>取消本地监听需要修改 my.cnf 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span> vim /etc/mysql/my.cnf<br>// 找到如下内容，并注释<br><span class="hljs-comment">#bind-address = 127.0.0.1</span><br></code></pre></td></tr></table></figure><p>修改了配置文件后需要重启 mysqld 才能使这些修改生效。</p><p>检查 mysqld 进程是否已经开启： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$pgrep</span> mysqld<br></code></pre></td></tr></table></figure><p>如果进程开启，这个命令将会返回该进程的 id </p><p>root登录mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure><p>下载<a href="apache-hive-1.1.0-bin.tar.gz">apache-hive-1.1.0</a></p><p>解压到&#x2F;home&#x2F;master&#x2F;apache-hive-1.1.0</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/profile<br><br><span class="hljs-comment">#set hive environment</span><br>HIVE_HOME=/home/master/apache-hive-1.1.0<br>PATH=<span class="hljs-variable">$HIVE_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br>CLASSPATH=<span class="hljs-variable">$CLASSPATH</span>:<span class="hljs-variable">$HIVE_HOME</span>/lib<br><span class="hljs-built_in">export</span> HIVE_HOME<br><span class="hljs-built_in">export</span> PATH<br><span class="hljs-built_in">export</span> CLASSPATH<br><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>配置hive-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/master/apache-hive-1.1.0/conf<br><br>gedit hive-env.sh<br><br>HADOOP_HOME=/home/master/hadoop-2.6.0<br><br><span class="hljs-built_in">export</span> HIVE_CONF_DIR=/home/master/hadoop-2.6.0/conf<br></code></pre></td></tr></table></figure><p>配置hive-site.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> hive-default.xml.template hive-site.xml<br><br>sudo gedit hive-site.xml<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> /home/master/hive/warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>location of default database for the warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.exec.scratchdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> /home/master/hive/scratchdir<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Scratch space for Hive jobs<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.querylog.location<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    Location of Hive run time structured log file<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc:mysql://master:3306/hive_metadata?createDatabaseIfNotExist=true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>username to use against metastore database<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>password to use against metastore database<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.exec.local.scratchdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br>  <span class="hljs-comment">&lt;!--拼凑目录--&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/local/$&#123;system:user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Local scratch space for Hive jobs<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.downloaded.resources.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/local/$&#123;hive.session.id&#125;_resources<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Temporary local directory for added resources in theremote file system.<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.server2.logging.operation.log.location<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/logs/operation_logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Top leveldirectory where operation logs are stored if logging functionality isenabled<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在apache-hive-1.1.0目录下创建local目录mkdir local</p><h3 id="配置log4j"><a href="#配置log4j" class="headerlink" title="配置log4j"></a>配置log4j</h3><p>创建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> hive-exec-log4j.properties.template  hive-exec-log4j.properties<br><span class="hljs-built_in">cp</span> hive-log4j.properties.template  hive-log4j.properties<br></code></pre></td></tr></table></figure><p>修改上面两个文件中的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit hive-exec-log4j.properties<br>sudo gedit hive-log4j.properties<br><br>hive.log.dir=/home/master/apache-hive-1.1.0/logs<br>log4j.appender.EventCounter=org.apache.hadoop.log.metrics.EventCounter<br></code></pre></td></tr></table></figure><p>注意如果没有logs目录就建立一个 执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$mkdir</span> /home/master/apache-hive-1.1.0/logs<br></code></pre></td></tr></table></figure><h3 id="添加Mysql驱动包"><a href="#添加Mysql驱动包" class="headerlink" title="添加Mysql驱动包"></a>添加Mysql驱动包</h3><ol><li><p>下载驱动包<br>本实验使用的mysql是mysql 5.6 版本，配套的jdbc是<a href="mysql-connector-java-5.1.9.jar">mysql-connector-java-5.1.24-bin.jar</a><br>这个jar在网上下载就可以了，一定要根据mysql版本选择配套的版本</p></li><li><p>添加驱动包<br>把驱动包放到 $HIVE_HOME&#x2F;lib 目录下</p></li><li><p>修改hadoop的库文件<br>在$HADOOP_HOME&#x2F;share&#x2F;hadoop&#x2F;yarn&#x2F;lib下备份jline-0.9.94.jar</p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/master/hadoop-2.6.0/share/hadoop/yarn/lib<br><span class="hljs-variable">$mv</span> jline-0.9.94.jar jline-0.9.94.jar.bak<br></code></pre></td></tr></table></figure></li><li><p>Copy高版本的jline</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$cp</span> <span class="hljs-variable">$HIVE_HOME</span>/lib/jline-2.12.jar <span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/yarn/lib<br><span class="hljs-built_in">cp</span> /home/master/apache-hive-1.1.0/lib/jline-2.12.jar /home/master/hadoop-2.6.0/share/hadoop/yarn/lib<br></code></pre></td></tr></table></figure></li></ol><p>验证配置是否成功</p><p>启动hive</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hive<br></code></pre></td></tr></table></figure><p>没有报错且显示hinve&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">create table <span class="hljs-built_in">test</span>(<span class="hljs-built_in">id</span> int, name String);<br>show tables;<br>insert into <span class="hljs-built_in">test</span> values(0, <span class="hljs-string">&#x27;Sombra&#x27;</span>);<br>select * from <span class="hljs-built_in">test</span>;<br></code></pre></td></tr></table></figure><h3 id="从文件导入数据"><a href="#从文件导入数据" class="headerlink" title="从文件导入数据"></a>从文件导入数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">create table shakespaeare(child string, parent string)<br>row format delimited fields terminated by <span class="hljs-string">&#x27;,&#x27;</span><br>stored as textfile;<br><br>load data inpath <span class="hljs-string">&quot;hdfs://master:9000/input/gl.dat&quot;</span><br>into table shakespaeare;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装hive&quot;&gt;&lt;a href=&quot;#安装hive&quot; class=&quot;headerlink&quot; title=&quot;安装hive&quot;&gt;&lt;/a&gt;安装hive&lt;/h2&gt;&lt;p&gt;hive–&amp;gt;hql–&amp;gt;hive引擎–&amp;gt;mapreduce Task&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Hive" scheme="http://yoursite.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>HDFS</title>
    <link href="http://yoursite.com/2022/08/13/HDFS/"/>
    <id>http://yoursite.com/2022/08/13/HDFS/</id>
    <published>2022-08-13T09:19:43.000Z</published>
    <updated>2023-03-05T10:41:08.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HDFS启动与关闭"><a href="#HDFS启动与关闭" class="headerlink" title="HDFS启动与关闭"></a>HDFS启动与关闭</h2><p>HDFS 和普通的硬盘上的文件系统不一样，是通过Java 虚拟机运行在整个集群当中的，<br>所以当Hadoop 程序写好之后，需要启动HDFS 文件系统，才能运行。</p><p>HDFS启动过程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/start-dfs.sh<br></code></pre></td></tr></table></figure><p>这一脚本会启动NameNode ， 然后根据conf&#x2F;slaves 中的记录逐个启动DataNode ，最后<br>根据conf&#x2F;masters 中记录的Secondary NameNode 地址启动SecondaryNameNode 。</p><p>HDFS 关闭过程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/stop-dfs.sh<br></code></pre></td></tr></table></figure><p>这一脚本的运行过程正好是bin&#x2F;start-dfs.sh 的逆过程，关闭Secondary NameNode ，然后<br>是每个DataNode ，最后是NameNode自身。</p><h2 id="HDFS命令基本格式"><a href="#HDFS命令基本格式" class="headerlink" title="HDFS命令基本格式:"></a>HDFS命令基本格式:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -cmd &lt; args &gt;<br></code></pre></td></tr></table></figure><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span>  /<br></code></pre></td></tr></table></figure><p>列出hdfs文件系统根目录下的目录和文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span> -R /<br></code></pre></td></tr></table></figure><p>列出hdfs文件系统所有的目录和文件</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a><code>put</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put &lt; <span class="hljs-built_in">local</span> file &gt; &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>hdfs file的父目录一定要存在，否则命令不会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put  &lt; <span class="hljs-built_in">local</span> file or <span class="hljs-built_in">dir</span> &gt;...&lt; hdfs <span class="hljs-built_in">dir</span> &gt;<br></code></pre></td></tr></table></figure><p>hdfs dir 一定要存在，否则命令不会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put - &lt; hdsf  file&gt;<br></code></pre></td></tr></table></figure><p>从键盘读取输入到hdfs file中，按Ctrl+D结束输入，hdfs file不能存在，否则命令不会执行</p><h3 id="moveFromLocal"><a href="#moveFromLocal" class="headerlink" title="moveFromLocal"></a><code>moveFromLocal</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -moveFromLocal  &lt; <span class="hljs-built_in">local</span> src &gt; ... &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>与put相类似，命令执行后源文件 local src 被删除，也可以从从键盘读取输入到hdfs file中</p><h3 id="copyFromLocal"><a href="#copyFromLocal" class="headerlink" title="copyFromLocal"></a><code>copyFromLocal</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -copyFromLocal  &lt; <span class="hljs-built_in">local</span> src &gt; ... &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>与put相类似，也可以从从键盘读取输入到hdfs file中</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -get &lt; hdfs file &gt; &lt; <span class="hljs-built_in">local</span> file or <span class="hljs-built_in">dir</span>&gt;<br></code></pre></td></tr></table></figure><p>local file不能和 hdfs file名字不能相同，否则会提示文件已存在，没有重名的文件会复制到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -get &lt; hdfs file or <span class="hljs-built_in">dir</span> &gt; ... &lt; <span class="hljs-built_in">local</span>  <span class="hljs-built_in">dir</span> &gt;<br></code></pre></td></tr></table></figure><p>拷贝多个文件或目录到本地时，本地要为文件夹路径</p><p><code>注意：</code>如果用户不是root， local 路径要为用户文件夹下的路径，否则会出现权限问题，</p><h3 id="moveToLocal"><a href="#moveToLocal" class="headerlink" title="moveToLocal"></a><code>moveToLocal</code></h3><p>当前版本中还未实现此命令</p><h3 id="copyToLocal"><a href="#copyToLocal" class="headerlink" title="copyToLocal"></a><code>copyToLocal</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -copyToLocal &lt; <span class="hljs-built_in">local</span> src &gt; ... &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>与get相类似</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">rm</span> &lt; hdfs file &gt; ...<br>hadoop fs -<span class="hljs-built_in">rm</span> -r &lt; hdfs <span class="hljs-built_in">dir</span>&gt;...<br></code></pre></td></tr></table></figure><p>每次可以删除多个文件或目录</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mkdir</span> &lt; hdfs path&gt;<br></code></pre></td></tr></table></figure><p>只能一级一级的建目录，父目录不存在的话使用这个命令会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mkdir</span> -p &lt; hdfs path&gt; <br></code></pre></td></tr></table></figure><p>所创建的目录如果父目录不存在就创建该父目录</p><h3 id="getmerge"><a href="#getmerge" class="headerlink" title="getmerge"></a><code>getmerge</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -getmerge &lt; hdfs <span class="hljs-built_in">dir</span> &gt;  &lt; <span class="hljs-built_in">local</span> file &gt;<br></code></pre></td></tr></table></figure><p>将hdfs指定目录下所有文件排序后合并到local指定的<code>文件</code>中，文件不存在时会自动创建，文件存在时会覆盖里面的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -getmerge -<span class="hljs-built_in">nl</span>  &lt; hdfs <span class="hljs-built_in">dir</span> &gt;  &lt; <span class="hljs-built_in">local</span> file &gt;<br></code></pre></td></tr></table></figure><p>加上nl后，合并到local file中的hdfs文件之间会空出一行</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">cp</span>  &lt; hdfs file &gt;  &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>目标文件不能存在，否则命令不能执行，相当于给文件重命名并保存，源文件还存在</p><p>hadoop fs -cp &lt; hdfs file or dir &gt;… &lt; hdfs dir &gt;</p><p>目标文件夹要存在，否则命令不能执行</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mv</span> &lt; hdfs file &gt;  &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>目标文件不能存在，否则命令不能执行，相当于给文件重命名并保存，源文件不存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mv</span>  &lt; hdfs file or <span class="hljs-built_in">dir</span> &gt;...  &lt; hdfs <span class="hljs-built_in">dir</span> &gt;<br></code></pre></td></tr></table></figure><p>源路径有多个时，目标路径必须为目录，且必须存在。</p><p><code>注意：</code>跨文件系统的移动（local到hdfs或者反过来）都是不允许的</p><h3 id="count"><a href="#count" class="headerlink" title="count"></a><code>count</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -count &lt; hdfs path &gt;<br></code></pre></td></tr></table></figure><p>统计hdfs对应路径下的目录个数，文件个数，文件总计大小</p><p>显示为目录个数，文件个数，文件总计大小，输入路径</p><h3 id="du"><a href="#du" class="headerlink" title="du"></a><code>du</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">du</span> &lt; hdsf path&gt; <br></code></pre></td></tr></table></figure><p>显示hdfs对应路径下每个文件夹和文件的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">du</span> -s &lt; hdsf path&gt; <br></code></pre></td></tr></table></figure><p>显示hdfs对应路径下所有文件和的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">du</span> - h &lt; hdsf path&gt; <br></code></pre></td></tr></table></figure><p>显示hdfs对应路径下每个文件夹和文件的大小,文件的大小用方便阅读的形式表示，例如用64M代替67108864</p><h3 id="text"><a href="#text" class="headerlink" title="text"></a><code>text</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -text &lt; hdsf file&gt;<br></code></pre></td></tr></table></figure><p>将文本文件或某些格式的非文本文件通过文本格式输出</p><h3 id="setrep"><a href="#setrep" class="headerlink" title="setrep"></a><code>setrep</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -setrep -R 3 &lt; hdfs path &gt;<br></code></pre></td></tr></table></figure><p>改变一个文件在hdfs中的副本个数，上述命令中数字3为所设置的副本个数，-R选项可以对一个人目录下的所有目录+文件递归执行改变副本个数的操作</p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a><code>stat</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdoop fs -<span class="hljs-built_in">stat</span> [format] &lt; hdfs path &gt;<br></code></pre></td></tr></table></figure><p>返回对应路径的状态信息</p><p>[format]可选参数有：%b（文件大小），%o（Block大小），%n（文件名），%r（副本个数），%y（最后一次修改日期和时间）</p><p>可以这样书写<code>hadoop fs -stat %b%o%n &lt; hdfs path &gt;</code>，不过不建议，这样每个字符输出的结果不是太容易分清楚</p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a><code>tail</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">tail</span> &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>在标准输出中显示文件末尾的1KB数据</p><h3 id="archive"><a href="#archive" class="headerlink" title="archive"></a><code>archive</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop archive -archiveName name.har -p &lt; hdfs parent <span class="hljs-built_in">dir</span> &gt; &lt; src &gt;* &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>命令中参数name：压缩文件名，自己任意取；&lt; hdfs parent dir &gt; ：压缩文件所在的父目录；&lt; src &gt;：要压缩的文件名；&lt; hdfs dst &gt;：压缩文件存放路径</p><p>*示例：hadoop archive -archiveName hadoop.har -p &#x2F;user 1.txt 2.txt &#x2F;des</p><p>示例中将hdfs中&#x2F;user目录下的文件1.txt，2.txt压缩成一个名叫hadoop.har的文件存放在hdfs中&#x2F;des目录下，如果1.txt，2.txt不写就是将&#x2F;user目录下所有的目录和文件压缩成一个名叫hadoop.har的文件存放在hdfs中&#x2F;des目录下</p><p>显示har的内容可以用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span> /des/hadoop.jar<br></code></pre></td></tr></table></figure><p>显示har压缩的是那些文件可以用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span> -R har:///des/hadoop.har<br></code></pre></td></tr></table></figure><p><code>注意：</code>har文件不能进行二次压缩。如果想给.har加文件，只能找到原来的文件，重新创建一个。har文件中原来文件的数据并没有变化，har文件真正的作用是减少NameNode和DataNode过多的空间浪费。</p><h3 id="balancer"><a href="#balancer" class="headerlink" title="balancer"></a><code>balancer</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs balancer<br></code></pre></td></tr></table></figure><p>如果管理员发现某些DataNode保存数据过多，某些DataNode保存数据相对较少，可以使用上述命令手动启动内部的均衡过程</p><h3 id="dfsadmin"><a href="#dfsadmin" class="headerlink" title="dfsadmin"></a><code>dfsadmin</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfsadmin -<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>管理员可以通过dfsadmin管理HDFS，用法可以通过上述命令查看</p><p>hdfs dfsadmin -report</p><p>显示文件系统的基本数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfsadmin -safemode &lt; enter | leave | get | <span class="hljs-built_in">wait</span> &gt;<br></code></pre></td></tr></table></figure><p>enter：进入安全模式；leave：离开安全模式；get：获知是否开启安全模式；</p><p>wait：等待离开安全模式</p><h3 id="distcp"><a href="#distcp" class="headerlink" title="distcp"></a><code>distcp</code></h3><p>用来在两个HDFS之间拷贝数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HDFS启动与关闭&quot;&gt;&lt;a href=&quot;#HDFS启动与关闭&quot; class=&quot;headerlink&quot; title=&quot;HDFS启动与关闭&quot;&gt;&lt;/a&gt;HDFS启动与关闭&lt;/h2&gt;&lt;p&gt;HDFS 和普通的硬盘上的文件系统不一样，是通过Java 虚拟机运行在整个集群当中的</summary>
      
    
    
    
    <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://yoursite.com/2022/07/25/Java-NIO/"/>
    <id>http://yoursite.com/2022/07/25/Java-NIO/</id>
    <published>2022-07-25T02:25:07.000Z</published>
    <updated>2023-03-05T10:41:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO(New IO或Non Bloking IO)是从Java1.4版本开始引入的一个新的IO API，NIO支持面向缓冲区的、基于通道的IO操作，读写文件更加高效。</p><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>IO<ul><li>面向流(Stream Oriented)：相当于水管，一个steam一个方向出水的水管</li><li>阻塞IO(Blocking IO)</li><li>无选择器</li></ul></li><li>NIO<ul><li>面向缓冲区(Buffer Oriented)：相当于铁路，一条铁路上面有一个缓冲区可以装数据然后双向运输</li><li>非阻塞IO(Non Blocking IO)</li><li>选择器(Selectors)</li></ul></li></ul><p>NIO系统的核心：通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。</p><h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><ol><li>缓冲区(Buffer):在NIO中复制数据的春秋，缓冲区就是数组。</li></ol><ul><li>根据数据类型的不同可以分配对应的缓冲区，boolean类型除外</li></ul><ol start="2"><li>缓冲区存取数据的两个核心方法：</li></ol><ul><li>put()</li><li>get()</li></ul><ol start="3"><li>缓冲区四个核心属性<ol><li>int capacity(容量): 表示缓冲区中最大存储数据的容量。一旦声明不能改变。</li><li>limit: 界限，表示缓冲区中可以操作数据的大小，即limit后的数据不能进行读写</li><li>position: 位置，表示缓冲区中正在操作数据的位置，且需满足(position &lt;&#x3D; limit &lt;&#x3D; capacity)</li><li>mark: 标记，标记当前position的位置，可以通过<code>reset()</code>恢复到mark的位置</li></ol></li></ol><p>这几个属性位于<code>java.nio.Buffer</code>类里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The characteristics of Spliterators that traverse and split elements</span><br><span class="hljs-comment">     * maintained in Buffers.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SPLITERATOR_CHARACTERISTICS</span> <span class="hljs-operator">=</span><br>        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;<br><br>    <span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br></code></pre></td></tr></table></figure><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br>    <span class="hljs-comment">// 分配一个指定大小的缓冲区</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 1024</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// 写数据</span><br>    buf.put(str.getBytes());<br>    System.out.println(buf.position()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 1024</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// 切换读取数据模式</span><br>    buf.flip();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// 读数据</span><br>    <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>    buf.get(dst);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, dst.length)); <span class="hljs-comment">// abcd</span><br>    System.out.println(buf.position()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// rewind() 可重复读数据</span><br>    buf.rewind();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// clear() 清空缓冲区，但是数据依然存在且处于被遗忘状态</span><br>    buf.clear();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 1024</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    buf.put(str.getBytes());<br>    buf.flip();<br>    <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>    buf.get(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    System.out.println(buf.position()); <span class="hljs-comment">// 2</span><br>    buf.mark();<br>    buf.get(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    System.out.println(buf.position()); <span class="hljs-comment">// 4</span><br>    buf.reset();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>直接缓冲区与非直接缓冲区</li></ol><ul><li>非直接缓冲区：通过<code>allocate()</code>方法分配的缓冲区，缓冲区建立在JVM的内存中</li><li>直接缓冲区：通过<code>allocateDirect()</code>方法分配的直接缓冲区或者使用FileChannel的map()方法返回MappedByteBuffer对象，将缓冲区建立在物理内存中。可以提高效率</li></ul><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><p>用于源节点和目标节点间的连接，在NIO中复制缓冲区中数据的传输。Channel本身不存储数据，需要配合缓冲区使用。</p><h4 id="通道主要实现类"><a href="#通道主要实现类" class="headerlink" title="通道主要实现类"></a>通道主要实现类</h4><ul><li>java.nio.channels.CHannel<ul><li>FileChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li><li>DatagramChannel</li></ul></li></ul><h4 id="获取通道的几种方式"><a href="#获取通道的几种方式" class="headerlink" title="获取通道的几种方式"></a>获取通道的几种方式</h4><ol><li>Java针对支持通道的类提供了<code>getChannel()</code>方法用于获取对应的通道</li></ol><ul><li>本地IO<ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li></ul></li><li>网络IO<ul><li>Socket</li><li>ServerSocket</li><li>DatagramSocket</li></ul></li></ul><ol start="2"><li>JDK1.7提供的NIO.2针对各个通道提供了静态方法<code>open()</code></li><li>JDK1.7中的NIO.2的Files工具类的<code>newByteChannel()</code>方法</li></ol><h4 id="通道使用案例"><a href="#通道使用案例" class="headerlink" title="通道使用案例"></a>通道使用案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 直接缓冲区：利用通道实现本地文件复制(内存映射文件)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;1.png&quot;</span>), StandardOpenOption.READ);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;3.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);<br>    <span class="hljs-comment">// 内存映射文件</span><br>    <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">inMappedBuffer</span> <span class="hljs-operator">=</span> inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());<br>    <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">outMappedBuffer</span> <span class="hljs-operator">=</span> outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());<br>    <span class="hljs-comment">// 直接对缓冲区进行数据的读写操作</span><br>    <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inMappedBuffer.limit()];<br>    inMappedBuffer.get(dst);<br>    outMappedBuffer.put(dst);<br><br>    inChannel.close();<br>    outChannel.close();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;1.png&quot;</span>), StandardOpenOption.READ);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;3.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);<br><br>    inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);<br><br>    inChannel.close();<br>    outChannel.close();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="分散-Scatter-于聚集-Gather"><a href="#分散-Scatter-于聚集-Gather" class="headerlink" title="分散(Scatter)于聚集(Gather)"></a>分散(Scatter)于聚集(Gather)</h4><ul><li>分散读取(Scattering Reads): 将通道中的数据分散到多个缓冲区中</li><li>聚集写入(Gathering Writes): 将多个缓冲区中的数据聚集到通道中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-comment">// 获取通道</span><br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel1</span> <span class="hljs-operator">=</span> raf1.getChannel();<br>    <span class="hljs-comment">// 分配多个缓冲区</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">100</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    <span class="hljs-comment">// 分散读取</span><br>    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;<br>    fileChannel1.read(bufs);<br><br>    <span class="hljs-keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;<br>        byteBuffer.flip();<br>    &#125;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufs[<span class="hljs-number">0</span>].array(), <span class="hljs-number">0</span>, bufs[<span class="hljs-number">0</span>].limit()));<br><br>    <span class="hljs-comment">// 聚集写入</span><br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel2</span> <span class="hljs-operator">=</span> raf2.getChannel();<br>    fileChannel2.write(bufs);<br><br>    fileChannel1.close();<br>    fileChannel2.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符集-Charset"><a href="#字符集-Charset" class="headerlink" title="字符集(Charset)"></a>字符集(Charset)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CharacterCodingException &#123;<br>    <span class="hljs-type">Charset</span> <span class="hljs-variable">cs1</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>);<br>    <span class="hljs-comment">// 获取编码器与解码器</span><br>    <span class="hljs-type">CharsetEncoder</span> <span class="hljs-variable">ce</span> <span class="hljs-operator">=</span> cs1.newEncoder();<br>    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> cs1.newDecoder();<br><br>    <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">1024</span>);<br>    buffer.put(<span class="hljs-string">&quot;获取编码器与&quot;</span>);<br>    buffer.flip();<br><br>    <span class="hljs-comment">// 编码</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bBuf</span> <span class="hljs-operator">=</span> ce.encode(buffer);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++) &#123;<br>        System.out.println(bBuf.get());<br>    &#125;<br><br>    <span class="hljs-comment">// 解码</span><br>    bBuf.flip();<br>    <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">cBuf</span> <span class="hljs-operator">=</span> cd.decode(bBuf);<br>    System.out.println(cBuf.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h3><p>使用NIO完成网络通信需要：</p><ol><li>通道(Channel): 负责连接<ul><li>java.nio.channels.Channel接口<ul><li>SelectableChannel<ul><li>SocketChannel</li><li>ServerSocketChannel</li><li>DatagramChannel</li><li>Pipe.SinkChannel</li><li>Pipe.SourceChannel</li></ul></li></ul></li></ul></li><li>缓冲区(Buffer): 负责数据的存取</li><li>选择器(Selector): 是SelectableChannel的多路复用器。用于监控SelectableChannel的IO状况</li></ol><h3 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h3><h4 id="使用ServerSocketChannel"><a href="#使用ServerSocketChannel" class="headerlink" title="使用ServerSocketChannel"></a>使用ServerSocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.nio;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNonBlockingNIO</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));<br>        <span class="hljs-comment">// 切换成非阻塞模式</span><br>        sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 分配缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">// 发送数据</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span>(scanner.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.next();<br>            buf.put((LocalDateTime.now().toString() + <span class="hljs-string">&quot;:&quot;</span> + str).getBytes());<br>            buf.flip();<br>            sChannel.write(buf);<br>            buf.clear();<br>        &#125;<br><br>        sChannel.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-comment">// 切换成非阻塞模式</span><br>        ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 绑定连接</span><br>        ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br>        <span class="hljs-comment">// 获取选择器</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 将通道注册到选择器，并且指定监听事件</span><br>        ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        <span class="hljs-comment">// 轮询式的获取选择器上已经准备就绪的事件</span><br>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取当前选择器中所有注册的且已就绪的选择键</span><br>            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>            <span class="hljs-comment">// 迭代</span><br>            <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>                <span class="hljs-comment">// 获取准备就绪的事件</span><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-comment">// 判断是什么事件就绪</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">// 若为接收就绪</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> ssChannel.accept();<br>                    sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    sChannel.register(selector, SelectionKey.OP_READ);<br><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-comment">// 获取当前选择器上读就绪的通道</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> (SocketChannel)key.channel();<br><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>((len = sChannel.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                        buffer.flip();<br>                        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, len));<br>                        buffer.clear();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 取消选择键</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="使用DatagramChannel"><a href="#使用DatagramChannel" class="headerlink" title="使用DatagramChannel"></a>使用DatagramChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.nio;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.DatagramChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNonBlockingNIO2</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br><br>        dc.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-keyword">while</span>(scan.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scan.next();<br>            buffer.put((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString() + <span class="hljs-string">&quot;:&quot;</span> + str).getBytes());<br>            dc.send(buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));<br>            buffer.clear();<br>        &#125;<br>        dc.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br><br>        dc.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        dc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        dc.register(selector, SelectionKey.OP_READ);<br><br>        <span class="hljs-keyword">while</span>(selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> it.next();<br>                <span class="hljs-keyword">if</span>(key.isReadable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    dc.receive(buffer);<br>                    buffer.flip();<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, buffer.limit()));<br>                &#125;<br>            &#125;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.nio;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.Pipe;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPip</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取管道</span><br>        <span class="hljs-type">Pipe</span> <span class="hljs-variable">pipe</span> <span class="hljs-operator">=</span> Pipe.open();<br>        <span class="hljs-comment">// 将缓冲区中的数据写入管道</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        Pipe.<span class="hljs-type">SinkChannel</span> <span class="hljs-variable">sinkChannel</span> <span class="hljs-operator">=</span> pipe.sink();<br>        buffer.put(<span class="hljs-string">&quot;通过管道发送数据&quot;</span>.getBytes());<br>        buffer.flip();<br>        sinkChannel.write(buffer);<br><br>        <span class="hljs-comment">// 读取数据</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        Pipe.<span class="hljs-type">SourceChannel</span> <span class="hljs-variable">sourceChannel</span> <span class="hljs-operator">=</span> pipe.source();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sourceChannel.read(buffer1);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer1.array(), <span class="hljs-number">0</span>, len));<br><br>        sourceChannel.close();<br>        sinkChannel.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java NIO(New IO或Non Bloking IO)是从Java1.4版本开始引入的一个新的IO API，NIO支持面向缓冲区的、基于通道的IO操作，读写文件更加高效。&lt;/p&gt;
&lt;h2 id=&quot;Java-NIO&quot;&gt;&lt;a href=&quot;#Java-NIO&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JVM-11_直接内存</title>
    <link href="http://yoursite.com/2022/07/16/JVM-11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2022/07/16/JVM-11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</id>
    <published>2022-07-16T01:56:07.000Z</published>
    <updated>2023-03-05T10:43:37.682Z</updated>
    
    <content type="html"><![CDATA[<p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下列代码，直接分配本地内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">BUFFER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 1GB</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(BUFFER);<br></code></pre></td></tr></table></figure><h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><img src="image-20200709170907611.png"><p>NIO的方式使用了缓存区的概念</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致<code>outofMemoryError</code>异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于<code>-xmx</code>指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。<br>缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置</p><p>如果不指定，默认与堆的最大值<code>-xmx</code>参数值一致</p><img src="image-2020070923064.png">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。&lt;/p&gt;
&lt;p&gt;直接内存是在Java堆外的、直接向系统申请的内存区间。&lt;/p&gt;
&lt;p&gt;来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存&lt;/p&gt;
&lt;p&gt;通常，访问直接</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-10_对象实例化内存布局与访问定位</title>
    <link href="http://yoursite.com/2022/07/05/JVM-10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2022/07/05/JVM-10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2022-07-05T01:59:47.000Z</published>
    <updated>2023-03-05T10:43:33.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><img src="image-20200709095356247.png"><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h3 id="创建对象的步骤-共6步"><a href="#创建对象的步骤-共6步" class="headerlink" title="创建对象的步骤(共6步)"></a>创建对象的步骤(共6步)</h3><p>对象实例化的过程:</p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化"></a>1. 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出<code>ClassNotFoundException</code>异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>float, int 占4个字节</li><li>short, char 占2个字节</li><li>byte, boolean 占1个字节 </li><li>String 4 占4个字节</li><li>double, long 8 占4个字节</li></ul><p>为对象分配空间需要找到内存中至少存在一块足够大小的连续空间</p><p>判断内存是否规整</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能决定</strong>。</p><h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>在Eden区每个线程预先分配TLAB - 通过设置 <code>-XX:+UseTLAB</code>参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h3 id="4-初始化分配到的内存-属性的默认初始化"><a href="#4-初始化分配到的内存-属性的默认初始化" class="headerlink" title="4. 初始化分配到的内存(属性的默认初始化)"></a>4. 初始化分配到的内存(属性的默认初始化)</h3><p>给对象属性赋值的操作</p><ul><li><p>属性的默认初始化</p></li><li><p>显示初始化</p></li><li><p>代码块中的初始化</p></li><li><p>构造器初始化</p></li><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li></ul><h3 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p>稍后详细讲</p><h3 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6. 执行init方法进行初始化"></a>6. 执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><img src="image-20200709151033237.png"><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和 类型指针</p><ol><li>运行时元数据</li></ol><ul><li>哈希值(HashCode)：对象在堆空间里面的地址</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><ol start="2"><li>类型指针：指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</li></ol><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="image-20200709152801713.png"><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><img src="image-20200709164149920.png"><h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><img src="image-20200709164342002.png"><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><img src="image-20200709164350466.png"><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象实例化&quot;&gt;&lt;a href=&quot;#对象实例化&quot; class=&quot;headerlink&quot; title=&quot;对象实例化&quot;&gt;&lt;/a&gt;对象实例化&lt;/h2&gt;&lt;h3 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-9_方法区</title>
    <link href="http://yoursite.com/2022/06/20/JVM-9_%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://yoursite.com/2022/06/20/JVM-9_%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2022-06-20T01:26:30.000Z</published>
    <updated>2023-03-05T10:43:28.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是方法区"><a href="#什么是方法区" class="headerlink" title="什么是方法区"></a>什么是方法区</h3><h4 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h4><p>PermGen ， 就是 PermGen space ，全称是 Permanent Generation space ，是指内存的永久保存区域。这块内存主要是被JVM存放Class和Meta信息的， Class 在被 Loader 时就会被放到 PermGen space 中。</p><p>绝大部分 Java 程序员应该都见过 <code>java.lang.OutOfMemoryError: PermGen space</code> 这个异常。<br>这里的 PermGen space 其实指的就是 方法区 。不过方法区和 PermGen space又有着本质的区别。</p><p>方法区 是 JVM 的规范，所有虚拟机 必须遵守的。</p><p>PermGen space 则是 HotSpot 虚拟机 基于 JVM 规范对 方法区 的一个落地实现， 并且只有 HotSpot 才有 PermGen space。</p><p>而如 JRockit（Oracle）、J9（IBM） 虚拟机有 方法区 ，但是就没有 PermGen space。</p><p>PermGen space 是 JDK7及之前， HotSpot 虚拟机 对 方法区 的一个落地实现。在JDK8被移除。</p><p>Metaspace（元空间）是 JDK8及之后， HotSpot 虚拟机 对 方法区 的新的实现。</p><p><strong>JDK6、JDK7 时，方法区 就是 PermGen（永久代）。</strong></p><p><strong>JDK8 时，方法区就是 Metaspace（元空间）</strong></p><h3 id="复习一下Java运行时数据区"><a href="#复习一下Java运行时数据区" class="headerlink" title="复习一下Java运行时数据区"></a>复习一下Java运行时数据区</h3><img src="image-20200708093918121.png"><p>从线程共享与否的角度来看</p><img src="image-20200708094507624.png"><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h4 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h4><p>下面就涉及了对象的访问定位</p><img src="image-20200708094747667.png"><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p><a href="https://docs/roacle.com/javase/specs/jvms/se8/html">《Java虚拟机规范》</a>中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><img src="image-20200708095853544.png"><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError：PermGen space</code> 或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。            </p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过<code>-XX:MaxPermsize</code>上限）</p></blockquote><img src="image-20200708102919149.png"><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><img src="image-20200708103055914.png"><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。<strong>不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p><h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul><li>通过<code>-xx:Permsize</code>来设置永久代初始分配空间。默认值是20.75M</li><li><code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutofMemoryError:PermGen space</code>。</li></ul><img src="image-20200708111756800.png"><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</p><p>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的<code>-xx:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</p><h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li></ul><h4 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h4><ul><li><p>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</p></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ul><h4 id="内存溢出（Memory-Overflow）"><a href="#内存溢出（Memory-Overflow）" class="headerlink" title="内存溢出（Memory Overflow）"></a>内存溢出（Memory Overflow）</h4><img src="bd315c6034a85edf533cef2ef38ce826dc54756d.jpeg"><p>内存溢出排查</p><p>排查其实最主要的就是检查代码，而且内存溢出往往都是代码的问题。当然一下几点都是需要注意的：</p><ol><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>启动参数内存值设定的过小；</li></ol><p>最后就是解决了。</p><ol><li>修改JVM启动参数，直接增加内存。</li><li>检查错误日志</li><li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><img src="image-20200708161728320.png"><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><img src="image-20200708161856504.png"><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><p>JVM必须在方法区中保存类型的所有字段的相关信息以及字段的声明顺序。</p><p>字段的相关信息包括：字段名称、字段类型、字段修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同字段信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * non-final的类变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.hello();<br>        System.out.println(order.count);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p><h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><img src="image-20200708171151384.png"><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><img src="image-20200708172357052.png"><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、字段和方法的符号引用</p><h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将会被翻译成如下字节码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">new <span class="hljs-comment">#2  </span><br>dup<br>invokespecial<br></code></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备<strong>动态性</strong>。</p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p>如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        System.out.println(a+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码执行过程展示</p><img src="image-20200708204750374.png"><p>首先现将操作数500放入到操作数栈中</p><img src="image-20200708204953552.png"><p>然后存储到局部变量表中</p><img src="image-20200708205029376.png"><p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><img src="image-20200708205221737.png"><p>将500 和 100 进行一个除法运算，在把结果入栈</p><img src="image-20200708205413721.png"><p>在最后就是输出流，需要调用运行时常量池的常量</p><img src="image-20200708205708057.png"><p>最后调用invokevirtual（虚方法调用），然后返回</p><img src="image-20200708205909176.png"><p>返回时</p><img src="image-20200708210540696.png"><p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><img src="image-20200708211541300.png"><p>JDK7的时候</p><img src="image-20200708211609911.png"><p>JDK8的时候，元空间大小只受物理内存影响</p><img src="image-20200708211637952.png"><h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。<br>因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><img src="image-20200708215025527.png"><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><img src="image-20200708215218078.png"><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 <code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="image-20200708220303243.png"><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是方法区&quot;&gt;&lt;a href=&quot;#什么是方法区&quot; class=&quot;headerlink&quot; title=&quot;什么是方法区&quot;&gt;&lt;/a&gt;什么是方法区&lt;/h3&gt;&lt;h4 id=&quot;PermGen（永久代）&quot;&gt;&lt;a href=&quot;#PermGen（永久代）&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-8_堆</title>
    <link href="http://yoursite.com/2022/06/06/JVM-8_%E5%A0%86/"/>
    <id>http://yoursite.com/2022/06/06/JVM-8_%E5%A0%86/</id>
    <published>2022-06-06T07:45:52.000Z</published>
    <updated>2023-03-05T10:43:23.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：最小堆内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>下图就是使用：Java VisualVM(C:\Program Files\Java\jdk1.8.0_231\bin\jvisualvm.exe)查看堆空间的内容，通过 jdk bin提供的插件</p><img src="image-20200706200739392.png"><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p><blockquote><p>The heap is the run-time data area from which memory for all class instances and arrays is allocated</p></blockquote><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><img src="image-20200706201904057.png"><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>(Young Generation Space)新生区: Young&#x2F;New, 又被划分为Eden区和Survivor区</li><li>(Tenure generation space)养老区: Old&#x2F;Tenure</li><li>(Permanent Space)永久区: Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>(Young Generation Space)新生区: Young&#x2F;New, 又被划分为Eden区和Survivor区</li><li>(Tenure generation space)养老区: Old&#x2F;Tenure</li><li>(Meta Space)元空间: Meta</li></ul><p>约定同义词：</p><ul><li>Young Generation Space &#x3D; 新生区 &#x3D; 新生代 &#x3D; 年轻代 </li><li>Tenure generation space &#x3D; 养老区 &#x3D; 老年区 &#x3D; 老年代</li><li>Permanent Space &#x3D; 永久区 &#x3D; 永久代</li></ul><img src="image-20200706203419496.png"><p>堆空间内部结构，JDK1.8之前从永久代 -&gt;  元空间</p><img src="image-20200706203835403.png"><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li><code>-Xms</code>用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li><code>-Xmx</code>则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过<code>-xmx</code>所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将<code>-Xms</code>和<code>-Xmx</code>两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，避免频繁的扩容或释放，对系统造成额外的压力，从而提高性能</strong>。</p><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小&#x2F;64</li><li>最大内存大小：物理电脑内存大小&#x2F;4</li></ul><p>如何查看堆内存的内存分配情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jps  -&gt;  staat -gc  进程id<br></code></pre></td></tr></table></figure><p>在程序运行结束后打印堆空间详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Picture&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Picture</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Picture</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] pixels;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Picture</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pixels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后设置启动参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure><img src="javaw_s9VJ3r66ne.png"><p>错误提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space<br>at com.sicmatr1x.java.Picture.&lt;init&gt;(OOMTest.java:24)<br>at com.sicmatr1x.java.OOMTest.main(OOMTest.java:15)<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><img src="image-20200706211652779.png"><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><img src="image-20200707075847954.png"><p>下面这参数开发中一般不会调：</p><img src="image-20200707080154039.png"><ul><li><p>默认-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p></li><li><p>可以修改-XX:NewRatio&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p></li></ul><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p><p>查看新生代区占几份：<code>jinfo -flag NewRatio 60636</code></p><ul><li><code>-XX:NewRatio</code>: 设置新生代与老年代的比例。默认值是2.</li><li><code>-XX:SurvivorRatio</code>: 设置新生代中Eden区与Survivor区的比例。默认值是8。在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项<code>-xx:SurvivorRatio</code>调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></li><li><code>-XX:-UseAdaptiveSizePolicy</code>: 关闭自适应的内存分配策略  （暂时用不到）</li><li><code>-Xmn</code>: 设置新生代的空间的大小。 （一般不设置）</li></ul><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><img src="image-20200707084208115.png"><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li></ol><ul><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 Y(oung)GC &#x2F; Minor GC操作。<strong>注意：S0或S1区满的时候是不会触发YGC的。如果Survivor区满了后，将会触发一些特殊的规则(参考下面的对象分配的特殊情况)，也就是可能直接晋升老年代</strong></p><img src="image-20200707084714886.png"><ol><li>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</li></ol><img src="image-20200707085232646.png"><ol start="2"><li>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</li></ol><img src="image-20200707085737207.png"><ol start="3"><li>我们继续不断的进行对象生成 和垃圾回收，当Survivor中的对象的年龄达到15的时候(可以设置参数：<code>-Xx:MaxTenuringThreshold=15</code>进行设置，默认为15)，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象晋升到老年代中</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>针对Survivor区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生代收集，很少在老年代收集，几乎不在永久代&#x2F;元空间收集</li></ul><h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><img src="image-20200707091058346.png"><h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapInstanceTest</span> &#123;<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapInstanceTest</span>());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后设置JVM参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure><img src="垃圾回收.gif"><p>最终，在老年代和新生代都满了，就出现OOM</p><h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><p><a href="https://u062.com/dir/27497173-39290581-6bdf5f">城通网盘提取码：800763</a></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC&#x2F;oldGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><img src="image-20200707095606813.png"><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发FullGC执行的情况有如下五种：</p><ul><li>调用<code>System.gc()</code>时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sicmatr1x&quot;</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                list.add(a);<br>                a = a + a;<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[GC (Allocation Failure) [PSYoungGen: 2005K-&gt;508K(2560K)] 2005K-&gt;832K(9728K), 0.0013790 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[GC (Allocation Failure) [PSYoungGen: 2512K-&gt;496K(2560K)] 2836K-&gt;1953K(9728K), 0.0016054 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[GC (Allocation Failure) [PSYoungGen: 1757K-&gt;482K(2560K)] 6670K-&gt;5991K(9728K), 0.0010749 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[GC (Allocation Failure) [PSYoungGen: 482K-&gt;498K(2560K)] 5991K-&gt;6015K(9728K), 0.0007589 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (Allocation Failure) [PSYoungGen: 498K-&gt;0K(2560K)] [ParOldGen: 5517K-&gt;4061K(7168K)] 6015K-&gt;4061K(9728K), [Metaspace: 3219K-&gt;3219K(1056768K)], 0.0064008 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] <br>[GC (Allocation Failure) [PSYoungGen: 34K-&gt;128K(2560K)] 6399K-&gt;6493K(9728K), 0.0016660 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (Ergonomics) [PSYoungGen: 128K-&gt;0K(2560K)] [ParOldGen: 6365K-&gt;5237K(7168K)] 6493K-&gt;5237K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0046603 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] <br>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 5237K-&gt;5237K(8704K), 0.0003621 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 5237K-&gt;5216K(7168K)] 5237K-&gt;5216K(8704K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0086411 secs] [Times: user=0.05 sys=0.02, real=0.01 secs] <br>Heap<br> PSYoungGen      total 1536K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)<br>  eden space 1024K, 6% used [0x00000000ffd00000,0x00000000ffd11ac8,0x00000000ffe00000)<br>  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)<br> ParOldGen       total 7168K, used 5216K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)<br>  object space 7168K, 72% used [0x00000000ff600000,0x00000000ffb180c0,0x00000000ffd00000)<br> Metaspace       used 3257K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 353K, capacity 388K, committed 512K, reserved 1048576K<br>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOfRange(Arrays.java:3664)<br>at java.lang.String.&lt;init&gt;(String.java:207)<br>at java.lang.StringBuilder.toString(StringBuilder.java:407)<br>at com.sicmatr1x.java.GCTest.main(GCTest.java:14)<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to，s0&#x2F;s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><img src="image-20200707101511025.png"><p>其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><img src="image-20200707101543871.png"><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项<code>-xx:MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： <code>-Xx:HandlePromotionFailure</code></p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><img src="image-20200707103547712.png"><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项<code>-Xx:UseTLAB</code>设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项<code>-Xx:TLABWasteTargetPercent</code>设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><img src="image-20200707104253530.png"><h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><ul><li><p>-<code>XX：+PrintFlagsInitial</code>：查看所有的参数的默认初始值</p></li><li><p><code>-XX：+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p><code>-Xms：初始堆空间内存</code>（默认为物理内存的1&#x2F;64）</p></li><li><p><code>-Xmx：最大堆空间内存</code>（默认为物理内存的1&#x2F;4）</p></li><li><p><code>-Xmn：设置新生代的大小</code>。（初始值及最大值）</p></li><li><p><code>-XX:NewRatio</code>：配置新生代与老年代在堆结构的占比</p></li><li><p><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0&#x2F;S1空间的比例</p></li><li><p><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄</p></li><li><p><code>-XX：+PrintGCDetails</code>：输出详细的GC处理日志</p><ul><li>打印gc简要信息：<ol><li>-Xx：+PrintGC</li><li>verbose:gc</li></ol></li></ul></li><li><p><code>-XX:HandlePromotionFalilure</code>：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析（Escape Analysis）</strong>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();<br>    <span class="hljs-comment">// use v</span><br>    <span class="hljs-comment">// ....</span><br>    v = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的逃逸分析代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 逃逸分析</span><br><span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> EscapeAnalysis obj;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>():obj;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();<br>        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项<code>-xx：+DoEscapeAnalysis</code>显式开启逃逸分析</li><li>通过选项<code>-xx：+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 栈上分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String phone;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackAllocation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        Thread.sleep(<span class="hljs-number">10000000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数，表示未开启逃逸分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>运行结果，同时还触发了GC操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">花费的时间为：664 ms<br></code></pre></td></tr></table></figure><p>然后查看内存的情况，发现有大量的User存储在堆中</p><img src="image-20200707203038615.png"><p>我们在开启逃逸分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">花费的时间为：5 ms<br></code></pre></td></tr></table></figure><p>然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失</p><img src="image-20200707203441718.png"><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其转换成字节码</p><img src="image-20200707205634266.png"><h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><p>参数设置：<code>-XX:+EliminateAllocations</code>开启标量替换(默认打开)，允许将对象打散分配在栈上</p><h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations<br></code></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下(64bit下默认启动的是server模式，可用java -version查看)，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志。</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆的核心概念&quot;&gt;&lt;a href=&quot;#堆的核心概念&quot; class=&quot;headerlink&quot; title=&quot;堆的核心概念&quot;&gt;&lt;/a&gt;堆的核心概念&lt;/h2&gt;&lt;p&gt;堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-7_本地方法栈</title>
    <link href="http://yoursite.com/2022/05/20/JVM-7_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <id>http://yoursite.com/2022/05/20/JVM-7_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</id>
    <published>2022-05-20T07:03:30.000Z</published>
    <updated>2023-03-05T10:43:19.738Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><img src="image-20200706174708418.png"><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java虚拟机栈于管理Java方法的调用，而&lt;strong&gt;本地方法栈用于管理本地方法的调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本地方法栈，也是线程私有的。&lt;/p&gt;
&lt;p&gt;允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-6_本地方法接口</title>
    <link href="http://yoursite.com/2022/05/16/JVM-6_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2022/05/16/JVM-6_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-05-16T06:38:49.000Z</published>
    <updated>2023-03-05T10:43:14.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</p><img src="image-20200706164139252.png"><p>为什么使用Native Method？</p><ol><li>与Java环境的交互：有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li><li>与操作系统的交互：JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是本地方法&quot;&gt;&lt;a href=&quot;#什么是本地方法&quot; class=&quot;headerlink&quot; title=&quot;什么是本地方法&quot;&gt;&lt;/a&gt;什么是本地方法&lt;/h2&gt;&lt;p&gt;简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native </summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-5_虚拟机栈</title>
    <link href="http://yoursite.com/2022/05/01/JVM-5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://yoursite.com/2022/05/01/JVM-5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2022-05-01T02:25:19.000Z</published>
    <updated>2023-03-05T10:43:10.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p>虚拟机栈包括多个栈帧，每个栈帧包括：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法返回地址</li></ul><h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackOverflowError</code> 异常。</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<code>OutOfMemoryError</code> 异常。</p><h4 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h4><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度，可以设置到idea的VM Options里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xss1m<br>-Xss1k<br></code></pre></td></tr></table></figure><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只用当前正在执行方法的栈帧(栈顶栈帧)是有效的，也被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><img src="image-20200705204836977.png"><h3 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h3><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量。这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h4 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h4><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>long和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</p><img src="image-20200705212454445.png"><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈：Operand Stack</p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><img src="image-20200706090618332.png"><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p><h4 id="反编译字节码解读示例"><a href="#反编译字节码解读示例" class="headerlink" title="反编译字节码解读示例"></a>反编译字节码解读示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperandStackTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddOperation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  Last modified 2020-8-5; size 459 bytes<br>  MD5 checksum 0c86be65af756c867db277302bedf1fa<br>  Compiled from &quot;OperandStackTest.java&quot;<br>public class com.sicmatr1x.java.OperandStackTest<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #1 = Methodref          #3.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = Class              #20            // com/sicmatr1x/java/OperandStackTest<br>   #3 = Class              #21            // java/lang/Object<br>   #4 = Utf8               &lt;init&gt;<br>   #5 = Utf8               ()V<br>   #6 = Utf8               Code<br>   #7 = Utf8               LineNumberTable<br>   #8 = Utf8               LocalVariableTable<br>   #9 = Utf8               this<br>  #10 = Utf8               Lcom/sicmatr1x/java/OperandStackTest;<br>  #11 = Utf8               testAddOperation<br>  #12 = Utf8               i<br>  #13 = Utf8               B<br>  #14 = Utf8               j<br>  #15 = Utf8               I<br>  #16 = Utf8               k<br>  #17 = Utf8               SourceFile<br>  #18 = Utf8               OperandStackTest.java<br>  #19 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V<br>  #20 = Utf8               com/sicmatr1x/java/OperandStackTest<br>  #21 = Utf8               java/lang/Object<br>&#123;<br>  public com.sicmatr1x.java.OperandStackTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         4: return<br>      LineNumberTable:<br>        line 3: 0<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       5     0  this   Lcom/sicmatr1x/java/OperandStackTest;<br><br>  public void testAddOperation();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=2, locals=4, args_size=1<br>         0: bipush        15<br>         2: istore_1<br>         3: bipush        8<br>         5: istore_2<br>         6: iload_1<br>         7: iload_2<br>         8: iadd<br>         9: istore_3<br>        10: return<br>      LineNumberTable:<br>        line 5: 0<br>        line 6: 3<br>        line 7: 6<br>        line 8: 10<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0      11     0  this   Lcom/sicmatr1x/java/OperandStackTest;<br>            3       8     1     i   B<br>            6       5     2     j   I<br>           10       1     3     k   I<br>&#125;<br>SourceFile: &quot;OperandStackTest.java&quot;<br></code></pre></td></tr></table></figure><p>常量池：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Constant pool:<br>   #1 = Methodref          #3.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = Class              #20            // com/sicmatr1x/java/<br></code></pre></td></tr></table></figure><p>如果操作指令有用到常量池里的常量会出现<code>#2</code>这样的表示调用的是哪个常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Code:<br>  stack=1, locals=1, args_size=1<br></code></pre></td></tr></table></figure><p>这里的<code>stack=1</code>表示操作数栈深度为1，<code>locals=4</code>表示本地变量表长度为4</p><p>本地变量表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">LocalVariableTable:<br>  Start  Length  Slot  Name   Signature<br>      0      11     0  this   Lcom/sicmatr1x/java/OperandStackTest;<br>      3       8     1     i   B<br>      6       5     2     j   I<br>     10       1     3     k   I<br></code></pre></td></tr></table></figure><p>这里的start和length指的是该变量的生命周期对应操作指令的地址。这里因为没有double, long所以都是每个变量占用一个slot。byte, short, char, boolean都以int型来保存</p><p>分析操作指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0: bipush        15<br>2: istore_1<br>3: bipush        8<br>5: istore_2<br>6: iload_1<br>7: iload_2<br>8: iadd<br>9: istore_3<br>10: return<br></code></pre></td></tr></table></figure><p>手动执行指令，因为局部变量表所需的容量大小是在编译期确定下来的，所以这里没值的用[]来占位，且省略局部变量表第0号元素<code>this</code>：</p><ul><li><code>0: bipush        15</code><ul><li>PC寄存器: 0</li><li>局部变量表: <ol><li>[]</li><li>[]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[15] &lt;-栈顶</li></ul></li></ul></li><li><code>2: istore_1</code>: i指int类型，store存放到局部变量表，_1索引位1的位置<ul><li>PC寄存器: 2</li><li>局部变量表: <ol><li>[15]</li><li>[]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[] &lt;-栈顶</li></ul></li></ul></li><li><code>3: bipush        8</code><ul><li>PC寄存器: 3</li><li>局部变量表: <ol><li>[15]</li><li>[]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[8] &lt;-栈顶</li></ul></li></ul></li><li><code>5: istore_2</code><ul><li>PC寄存器: 2</li><li>局部变量表: <ol><li>[15]</li><li>[8]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[] &lt;-栈顶</li></ul></li></ul></li><li><code>6: iload_1</code>: 从局部比那里表中取索引位1的数据到操作数栈<ul><li>PC寄存器: 6</li><li>局部变量表: <ol><li>[15]</li><li>[8]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[15] &lt;-栈顶</li></ul></li></ul></li><li><code>7: iload_2</code>: 从局部比那里表中取索引位2的数据到操作数栈<ul><li>PC寄存器: 7</li><li>局部变量表: <ol><li>[15]</li><li>[8]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[8] &lt;-栈顶</li><li>[15]</li></ul></li></ul></li><li><code>8: iadd</code>: 操作数栈出栈并做加法运算<ul><li>PC寄存器: 8</li><li>局部变量表: <ol><li>[15]</li><li>[8]</li><li>[]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[23] &lt;-栈顶</li></ul></li></ul></li><li><code>9: istore_3</code><ul><li>PC寄存器: 9</li><li>局部变量表: <ol><li>[15]</li><li>[8]</li><li>[23]</li></ol></li><li>操作数栈 : <ul><li>[]</li><li>[] &lt;-栈顶</li></ul></li></ul></li></ul><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p><p>i++和++i的区别</p><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</p><blockquote><p>寄存器：指令更少，执行速度快</p></blockquote><h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h3><img src="image-20200706100311886.png"><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><img src="image-20200706101251847.png"><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h3 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）或静态绑定和晚期绑定（Late Binding）或动态绑定（auto binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><p>早期绑定：</p><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><p>晚期绑定：</p><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><p>相信大家都知道，java的三大特性：封装，继承和多态，动态绑定就和多态有关。</p><p>由于继承和重写的存在，当方法中的类型为父类的时候，编译的时候不太好判断，方法到底要和哪个类绑定，也就是调用的方法依赖于隐式参数的实际类型。</p><h4 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h4><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><p>普通调用指令：</p><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><p>动态调用指令：</p><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h4 id="invokednamic指令"><a href="#invokednamic指令" class="headerlink" title="invokednamic指令"></a>invokednamic指令</h4><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info &#x3D; “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name &#x3D; “shkstart”;    var name &#x3D; 10;    （运行时才进行检查）</p></blockquote><h4 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h4><p>注意：在调用对象方法前会将这个对象的引用压入操作数栈顶，因为后面需要需到其实际类型</p><p>Java 语言中方法重写的本质：</p><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li></ul><p>IllegalAccessError介绍：<br>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变</p><h4 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h4><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><img src="image-20200706154554604.png"><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？(StackOverflowError)<ul><li>通过虚拟机参数<code>-Xss</code>设置栈的大小</li><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的：<ul><li>固定不变的：如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，JVM将会抛出一个<code>StackOverflowError</code> 异常。</li><li>动态的：如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，JVM将会抛出一个<code>OutOfMemoryError</code> 异常。</li></ul></li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 面试题</span><br><span class="hljs-comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span><br><span class="hljs-comment"> * 何为线程安全？</span><br><span class="hljs-comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span><br><span class="hljs-comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderTest</span> &#123;<br><br>    <span class="hljs-comment">// s1的声明方式是线程安全的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程内部创建的，属于局部变量</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">method04</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-keyword">return</span> stringBuilder;<br>    &#125;<br><br>    <span class="hljs-comment">// stringBuilder 是线程不安全的，操作的是共享数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method02</span><span class="hljs-params">(StringBuilder stringBuilder)</span> &#123;<br>        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 同时并发的执行，会出现线程不安全的问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method03</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>            stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        method02(stringBuilder);<br>    &#125;<br><br>    <span class="hljs-comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">method05</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p><p>运行时数据区，是否存在Error和GC？</p><p>运行时数据区各部分是否存在Error与GC：</p><ul><li>程序计数器<ul><li>Error: 不存在</li><li>GC: 不存在，空间小速度快，没必要</li></ul></li><li>虚拟机栈<ul><li>Error: 存在，比如<code>StackOverflowError</code></li><li>GC: 不存在，只有进栈出栈，出栈即可</li></ul></li><li>本地方法栈<ul><li>Error: 存在</li><li>GC: 不存在，空间小速度快，没必要</li></ul></li><li>堆<ul><li>Error: 存在，比如<code>OutOfMemoryError</code></li><li>GC: 存在</li></ul></li><li>方法区<ul><li>Error: 存在</li><li>GC: 存在</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;堆与栈&quot;&gt;&lt;a href=&quot;#堆与栈&quot; class=&quot;headerlink&quot; title=&quot;堆与栈&quot;&gt;&lt;/a&gt;堆与栈&lt;/h3&gt;&lt;p&gt;首先栈是运行时的单位，而堆是存储的单位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。&lt;/li</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-4_程序计数器</title>
    <link href="http://yoursite.com/2022/04/16/JVM-4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/16/JVM-4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2022-04-16T02:23:57.000Z</published>
    <updated>2023-03-05T10:43:06.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p>在JVM规范中，每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间都只有一个方法在执行，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，若为native方法则为undefined</p><h4 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h4><ol><li>使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？</li></ol><p>因为CPU需要不停的切换各个线程，这时候切换回来以后就需要知道从哪开始继续执行。JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><ol start="2"><li>PC寄存器为什么会被设定为线程私有？</li></ol><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;p&gt;JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-3_运行时数据区概述及线程</title>
    <link href="http://yoursite.com/2022/04/06/JVM-3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2022/04/06/JVM-3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-04-06T02:19:23.000Z</published>
    <updated>2023-03-05T10:43:00.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区-Runtime-Data-Area-内部结构"><a href="#运行时数据区-Runtime-Data-Area-内部结构" class="headerlink" title="运行时数据区(Runtime Data Area)内部结构"></a>运行时数据区(Runtime Data Area)内部结构</h2><p>运行时数据区的完整图</p><img src="image-20200705111640511.png"><p>运行时数据区可简单分为：</p><ol><li><a href="JVM-4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.md">程序计数器(Program Counter Register, 或PC寄存器)</a></li><li><a href="JVM-5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.md">虚拟机栈(Java Virtual Machine Stack)</a></li><li><a href="JVM-6_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3.md">本地方法栈(Native Method Stack)</a></li><li><a href="JVM-8_%E5%A0%86.md">堆(Heap)</a></li><li><a href="JVM-9_%E6%96%B9%E6%B3%95%E5%8C%BA.md">方法区(Method Area)</a></li></ol><img src="image-20200705112416101.png"><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><img src="image-20200705112601211.png"><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p><h4 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h4><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;运行时数据区-Runtime-Data-Area-内部结构&quot;&gt;&lt;a href=&quot;#运行时数据区-Runtime-Data-Area-内部结构&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区(Runtime Data Area)内部结构&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
