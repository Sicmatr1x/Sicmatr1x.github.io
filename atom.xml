<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sicmatr1x&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-04-09T03:36:58.187Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sicmatr1x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无门槛人人可用本地搭建chatglm-6b-int4-slim</title>
    <link href="http://yoursite.com/2023/04/09/AI/%E6%97%A0%E9%97%A8%E6%A7%9B%E4%BA%BA%E4%BA%BA%E5%8F%AF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAchatglm-6b-int4-slim/"/>
    <id>http://yoursite.com/2023/04/09/AI/%E6%97%A0%E9%97%A8%E6%A7%9B%E4%BA%BA%E4%BA%BA%E5%8F%AF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAchatglm-6b-int4-slim/</id>
    <published>2023-04-09T01:22:00.000Z</published>
    <updated>2023-04-09T03:36:58.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="涉及项目"><a href="#涉及项目" class="headerlink" title="涉及项目"></a>涉及项目</h2><ul><li>josStorer&#x2F;selfhostedAI: <a href="https://github.com/josStorer/selfhostedAI">https://github.com/josStorer/selfhostedAI</a><ul><li>本地搭建懒人包，搭建完成后启动本地服务会启动一个本地服务器</li></ul></li><li>josStorer&#x2F;chatGPTBox: <a href="https://github.com/josStorer/chatGPTBox">https://github.com/josStorer/chatGPTBox</a><ul><li>Chrome插件: 可以发送请求到本地服务器，实现与本地模型进行交互</li></ul></li></ul><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="1-下载项目与模型文件"><a href="#1-下载项目与模型文件" class="headerlink" title="1. 下载项目与模型文件"></a>1. 下载项目与模型文件</h3><p>josStorer&#x2F;selfhostedAI项目里面包含2个模型</p><ol><li>ChatGLM 6B Int4: 该包基于ChatGLM, 遵循Apache-2.0协议开源, 内置模型为 <a href="https://huggingface.co/silver/chatglm-6b-int4-slim">https://huggingface.co/silver/chatglm-6b-int4-slim</a> 的裁切版</li><li>lama.cpp: 该包基于llama.cpp, 内置命令行交互示例为josStorer修改的版本, 以支持windows的unicode输入, 内置模型来自Chinese-LLaMA-Alpaca</li></ol><p>下载地址:</p><ul><li>百度网盘: <a href="https://pan.baidu.com/s/1wchIUHgne3gncIiLIeKBEQ?pwd=1111#list/path=%2F">https://pan.baidu.com/s/1wchIUHgne3gncIiLIeKBEQ?pwd=1111#list/path=%2F</a></li><li>GitHub Releases: <a href="https://github.com/josStorer/selfhostedAI/releases">https://github.com/josStorer/selfhostedAI/releases</a></li></ul><p>下载文件: <code>selfhostedAI-chatglm-6b-int4-windows-nvidia.7z</code></p><h3 id="2-解压缩与运行"><a href="#2-解压缩与运行" class="headerlink" title="2. 解压缩与运行"></a>2. 解压缩与运行</h3><p>解压缩到文件夹，文件结构如下图<br><img src="20230409093142.png" style="height: 300px"/></p><p>双击<code>chatglm-6b-int4.bat</code>运行</p><img src="20230409094335.png" style="height: 600px"/><p>由运行输出可知，运行需要 python3 环境和 C++ 环境。<br>这里报错<code>&#39;gcc&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。</code>是需要gcc编译器，但是我没有配置到系统变量<code>Path</code>里，但是并不影响程序的运行</p><h3 id="3-安装-Chrome-Extension-chatGPTBox"><a href="#3-安装-Chrome-Extension-chatGPTBox" class="headerlink" title="3. 安装 Chrome Extension: chatGPTBox"></a>3. 安装 Chrome Extension: chatGPTBox</h3><p>不一定要用 Chrome ，其它支持的浏览器也可以，支持的浏览器的插件地址如下:</p><ul><li>Chrome: <a href="https://chrome.google.com/webstore/detail/chatgptbox/eobbhoofkanlmddnplfhnmkfbnlhpbbo">https://chrome.google.com/webstore/detail/chatgptbox/eobbhoofkanlmddnplfhnmkfbnlhpbbo</a></li><li>Edge: <a href="https://microsoftedge.microsoft.com/addons/detail/fission-chatbox-best/enjmfilpkbbabhgeoadmdpjjpnahkogf">https://microsoftedge.microsoft.com/addons/detail/fission-chatbox-best/enjmfilpkbbabhgeoadmdpjjpnahkogf</a></li><li>Safari: <a href="https://apps.apple.com/app/fission-chatbox/id6446611121">https://apps.apple.com/app/fission-chatbox/id6446611121</a></li><li>Firefox: <a href="https://addons.mozilla.org/zh-CN/firefox/addon/chatgptbox/">https://addons.mozilla.org/zh-CN/firefox/addon/chatgptbox/</a></li></ul><p>安装完成后点开插件，如下图，需要修改以下配置项</p><ol><li>API模式: 改为自定义模型</li><li>模型名称填写为: <code>chatglm-6b-int4</code></li><li>本地服务地址默认为: <code>http://localhost:8000/chat/completions</code></li></ol><img src="20230409094956.png" style="height: 400px"/><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><h3 id="单词解释"><a href="#单词解释" class="headerlink" title="单词解释"></a>单词解释</h3><img src="20230409113619.png" /><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>然后就可以愉快的开始聊天了！<br>以下为聊天截图：</p><img src="20230409095649.png" style="height: 600px"/><p>注：在浏览器的插件中发送一句话给模型之后对应的在命令行上会打印接收到请求的日志，如下图：</p><img src="20230409095904.png" style="height: 100px"/><h3 id="求解算法题"><a href="#求解算法题" class="headerlink" title="求解算法题"></a>求解算法题</h3><img src="20230409102133.png" style="height: 600px"/><p>显然01背包问题解错了，我们尝试提示下看能不能解对</p><img src="20230409102258.png" /><p>直接无响应了，查看后台日志，好家伙爆显存了</p><img src="20230409102357.png" /><p>我的显卡是 NVIDIA GeForce RTX2060 显存6G<br>已经申请了5.07 G，然后又尝试申请116.00 MB空间申请不到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Tried to allocate 116.00 MiB (GPU 0; 6.00 GiB total capacity; 5.07 GiB already allocated; 0 bytes free; 5.31 GiB reserved in total by PyTorch)<br></code></pre></td></tr></table></figure><img src="20230409103609.png" /><p>重启后再次尝试：</p><img src="20230409104138.png" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;涉及项目&quot;&gt;&lt;a href=&quot;#涉及项目&quot; class=&quot;headerlink&quot; title=&quot;涉及项目&quot;&gt;&lt;/a&gt;涉及项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;josStorer&amp;#x2F;selfhostedAI: &lt;a href=&quot;https://github.com</summary>
      
    
    
    
    <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
    <category term="ChatGLM" scheme="http://yoursite.com/tags/ChatGLM/"/>
    
    <category term="ChatGPT" scheme="http://yoursite.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>BackPackII</title>
    <link href="http://yoursite.com/2023/03/26/LeetCode/BackPackII/"/>
    <id>http://yoursite.com/2023/03/26/LeetCode/BackPackII/</id>
    <published>2023-03-26T11:42:53.000Z</published>
    <updated>2023-03-26T08:24:07.580Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> util.PrintUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BackPackII</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态 dp(i, j): 前 i个物品放入大小为 j的背包中所获得的最大价值</span><br><span class="hljs-comment">     * weight(i): 新增物品的大小</span><br><span class="hljs-comment">     * value(i): 新增物品的价格</span><br><span class="hljs-comment">     * 递推关系:</span><br><span class="hljs-comment">     * 不放: dp(i, j) = dp(i-1, j) 表示不把第i个物品放入背包中，所以它的价值就是前i-1个物品放入大小为j的背包的最大价值</span><br><span class="hljs-comment">     * 放: dp(i-1, j - weight[i]) + value[i] 表示把第i个物品放入背包中，价值增加value[i],但是需要腾出j - weight[i]的大小放</span><br><span class="hljs-comment">     * 状态转移方程: dp(i,j) = max&#123; dp(i-1, j), dp(i-1, j - weight[i]) + value[i] &#125;</span><br><span class="hljs-comment">     * 初始状态：dp(i, 0) = dp(0, j) = 0   第0行和第0列都为0，表示没有装物品时的价值都为0</span><br><span class="hljs-comment">     * 返回值：dp(i, j)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m 大小为 m 的背包</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> A 每个物品的大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> V 每个物品的价值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 最多能装入背包的总价值是多大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backPackII</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] V)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">itemNum</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">int</span> weight[] = A;<br>        <span class="hljs-type">int</span> value[] = V;<br>        <span class="hljs-keyword">if</span> (itemNum == <span class="hljs-number">0</span> || m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// dp[最多取物品数量个][最大取背包大小]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[itemNum][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123; <span class="hljs-comment">// 可以省略</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; weight[<span class="hljs-number">0</span>]) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; itemNum; i++) &#123; <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= m; j++) &#123; <span class="hljs-comment">// 遍历重量</span><br>                <span class="hljs-keyword">if</span> (weight[i] &gt; j) &#123;<br>                    <span class="hljs-comment">// 新增物品质量大于当前背包，放不下</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 放得下，如果放入新物品要计算出背包剩余大小，看下剩余背包大小最多能装多少然后加上新增物品价格，和不放入新物品背包最大价格对比，取最大。最大价格都在上一层</span><br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        PrintUtil.printSubList(dp);<br>        <span class="hljs-keyword">return</span> dp[itemNum-<span class="hljs-number">1</span>][m];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 一维数组（滚动数组）实现</span><br><span class="hljs-comment">     * 状态 F(i, j): 前 i个物品放入大小为 j的背包中所获得的最大价值</span><br><span class="hljs-comment">     * A(i): 新增物品的大小</span><br><span class="hljs-comment">     * V(i): 新增物品的价格</span><br><span class="hljs-comment">     * 状态转移方程: dp(i,j) = max&#123; dp(i-1, j), dp(i-1, j - A[i-1]) + V[i-1] &#125;</span><br><span class="hljs-comment">     * dp[i] = 前 i个物品放入大小为 j的背包中所获得的最大价值</span><br><span class="hljs-comment">     * dp[j] = max(dp[j], dp[j - A[i-1]] + V[i-1]);</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m 大小为 m 的背包</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> A 每个物品的大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> V 每个物品的价值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 最多能装入背包的总价值是多大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backPackII1</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] V)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">itemNum</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">int</span> weight[] = A;<br>        <span class="hljs-type">int</span> value[] = V;<br>        <span class="hljs-keyword">if</span> (itemNum == <span class="hljs-number">0</span> || m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// dp[最大取背包大小]</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; weight[<span class="hljs-number">0</span>]) &#123;<br>                dp[j] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] = value[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; itemNum; i++) &#123; <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历重量</span><br>                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>            &#125;<br>        &#125;<br>        PrintUtil.printSubList(dp);<br>        <span class="hljs-keyword">return</span> dp[m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Java日期转换工具类</title>
    <link href="http://yoursite.com/2023/03/04/Java/Java%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2023/03/04/Java/Java%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2023-03-04T02:04:40.000Z</published>
    <updated>2023-03-26T08:06:02.850Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util.common;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DateUtil</span><br><span class="hljs-comment"> * jdk8 or higher</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> sicmatr1x@outlook.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2023/3/4 20:22</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateUtil</span> &#123;<br><br>    <span class="hljs-comment">// Empty checks</span><br>    <span class="hljs-comment">//-----------------------------------------------------------------------</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CharSequence cs)</span> &#123;<br>        <span class="hljs-keyword">return</span> cs == <span class="hljs-literal">null</span> || cs.length() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Date formats</span><br>    <span class="hljs-comment">//-----------------------------------------------------------------------</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_DATETIME_FORMAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; FORMATS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; FORMATS_REGEX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        FORMATS.put(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>, <span class="hljs-string">&quot;^\\d&#123;4&#125;\\d&#123;1,2&#125;\\d&#123;1,2&#125;$&quot;</span>);<br>        FORMATS.put(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>, <span class="hljs-string">&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$&quot;</span>);<br>        FORMATS.put(<span class="hljs-string">&quot;yyyy/MM/dd&quot;</span>, <span class="hljs-string">&quot;^\\d&#123;4&#125;/\\d&#123;1,2&#125;/\\d&#123;1,2&#125;$&quot;</span>);<br>        FORMATS.put(<span class="hljs-string">&quot;yyyy.MM.dd&quot;</span>, <span class="hljs-string">&quot;^\\d&#123;4&#125;\\.\\d&#123;1,2&#125;\\.\\d&#123;1,2&#125;$&quot;</span>);<br>        FORMATS.put(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, <span class="hljs-string">&quot;^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29) (20|21|22|23|[0-1][0-9]):[0-5][0-9]:[0-5][0-9]$&quot;</span>);<br><br>        FORMATS_REGEX.put(<span class="hljs-string">&quot;^\\d&#123;4&#125;\\d&#123;1,2&#125;\\d&#123;1,2&#125;$&quot;</span>, <span class="hljs-string">&quot;yyyyMMdd&quot;</span>);<br>        FORMATS_REGEX.put(<span class="hljs-string">&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        FORMATS_REGEX.put(<span class="hljs-string">&quot;^\\d&#123;4&#125;/\\d&#123;1,2&#125;/\\d&#123;1,2&#125;$&quot;</span>, <span class="hljs-string">&quot;yyyy/MM/dd&quot;</span>);<br>        FORMATS_REGEX.put(<span class="hljs-string">&quot;^\\d&#123;4&#125;\\.\\d&#123;1,2&#125;\\.\\d&#123;1,2&#125;$&quot;</span>, <span class="hljs-string">&quot;yyyy.MM.dd&quot;</span>);<br>        FORMATS_REGEX.put(<span class="hljs-string">&quot;^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29) (20|21|22|23|[0-1][0-9]):[0-5][0-9]:[0-5][0-9]$&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * test date string is match the format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> format date format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dateStr date string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true: match; false: not match</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String format, String dateStr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty(format) || isEmpty(dateStr)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!FORMATS.containsKey(format)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">formatRegex</span> <span class="hljs-operator">=</span> FORMATS.get(format);<br>        <span class="hljs-keyword">return</span> Pattern.matches(formatRegex, dateStr);<br>    &#125;<br><br>    <span class="hljs-comment">// Date formats: string -&gt; java.util.Date</span><br>    <span class="hljs-comment">//-----------------------------------------------------------------------</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * recognize the date string format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dateStr date string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date format</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Optional&lt;String&gt; <span class="hljs-title function_">recognizeFormat</span><span class="hljs-params">(String dateStr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty(dateStr)) &#123;<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>        <span class="hljs-keyword">return</span> FORMATS_REGEX.entrySet().stream()<br>                .filter(e -&gt; Pattern.matches(e.getKey(), dateStr))<br>                .map(Map.Entry::getValue)<br>                .findFirst();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * recognize the date string format, if not recognize than return default string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dateStr date string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date format</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">recognizeFormat</span><span class="hljs-params">(String dateStr, String defaultStr)</span> &#123;<br>        <span class="hljs-keyword">return</span> recognizeFormat(dateStr).orElse(defaultStr);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * smart recognize the date string format, and parse to date object</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dateStr date string need to parse</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ParseException parse error</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">smartParse</span><span class="hljs-params">(String dateStr)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty(dateStr)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Optional&lt;String&gt; format = recognizeFormat(dateStr);<br>        <span class="hljs-keyword">if</span> (format.isPresent()) &#123;<br>            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(format.get());<br>            <span class="hljs-keyword">return</span> sdf.parse(dateStr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * smart recognize the date string format, and parse to support date object</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dateStr date string need to parse</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz support class: java.util.Date, java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> support date object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ParseException parse error</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">smartParse</span><span class="hljs-params">(String dateStr, Class clazz)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> smartParse(dateStr);<br>        <span class="hljs-keyword">if</span> (date == <span class="hljs-literal">null</span> || clazz == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (clazz == Date.class) &#123;<br>            <span class="hljs-keyword">return</span> date;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == LocalDate.class) &#123;<br>            <span class="hljs-keyword">return</span> toLocalDate(date);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == LocalTime.class) &#123;<br>            <span class="hljs-keyword">return</span> toLocalTime(date);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == LocalDateTime.class) &#123;<br>            <span class="hljs-keyword">return</span> toLocalDateTime(date);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Date formats: date object -&gt; string</span><br>    <span class="hljs-comment">//-----------------------------------------------------------------------</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * some support class date object convert to date string,</span><br><span class="hljs-comment">     * if not support or illegal dateObj than return an empty string</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dateObj support class: java.util.Date, java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formatStr date format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(Object dateObj, String formatStr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dateObj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dateObj <span class="hljs-keyword">instanceof</span> String) &#123;<br>            <span class="hljs-keyword">return</span> (String) dateObj;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isEmpty(formatStr)) &#123;<br>            formatStr = DEFAULT_DATETIME_FORMAT;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dateObj <span class="hljs-keyword">instanceof</span> Date) &#123;<br>            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(formatStr);<br>            <span class="hljs-keyword">return</span> sdf.format(dateObj);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dateObj <span class="hljs-keyword">instanceof</span> LocalDate) &#123;<br>            <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(formatStr);<br>            <span class="hljs-keyword">return</span> ((LocalDate) dateObj).format(dtf);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dateObj <span class="hljs-keyword">instanceof</span> LocalTime) &#123;<br>            <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(formatStr);<br>            <span class="hljs-keyword">return</span> ((LocalTime) dateObj).format(dtf);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dateObj <span class="hljs-keyword">instanceof</span> LocalDateTime) &#123;<br>            <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(formatStr);<br>            <span class="hljs-keyword">return</span> ((LocalDateTime) dateObj).format(dtf);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.time.LocalDate -&gt; String</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> localDate java.time.LocalDate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formatStr format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(LocalDate localDate, String formatStr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (localDate == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(formatStr);<br>        <span class="hljs-keyword">return</span> localDate.format(dtf);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.time.LocalTime -&gt; String</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> localTime java.time.LocalTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formatStr format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(LocalTime localTime, String formatStr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (localTime == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(formatStr);<br>        <span class="hljs-keyword">return</span> localTime.format(dtf);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.time.LocalDateTime -&gt; String</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> localDateTime java.time.LocalDateTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formatStr format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> date string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(LocalDateTime localDateTime, String formatStr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (localDateTime == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(formatStr);<br>        <span class="hljs-keyword">return</span> localDateTime.format(dtf);<br>    &#125;<br><br>    <span class="hljs-comment">// java.util.Date -&gt; java.time.LocalDate</span><br>    <span class="hljs-comment">//                -&gt; java.time.LocalTime</span><br>    <span class="hljs-comment">//                -&gt; java.time.LocalDateTime</span><br>    <span class="hljs-comment">//-----------------------------------------------------------------------</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.util.Date -&gt; java.time.LocalDate</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> date java.util.Date</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zoneId A time-zone ID, if null than use system default</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.time.LocalDate</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDate <span class="hljs-title function_">toLocalDate</span><span class="hljs-params">(Date date, ZoneId zoneId)</span> &#123;<br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> date.toInstant();<br>        <span class="hljs-keyword">if</span> (zoneId == <span class="hljs-literal">null</span>) &#123;<br>            zoneId = ZoneId.systemDefault();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instant.atZone(zoneId).toLocalDate();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.util.Date -&gt; java.time.LocalDate</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> date java.util.Date</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.time.LocalDate</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDate <span class="hljs-title function_">toLocalDate</span><span class="hljs-params">(Date date)</span> &#123;<br>        <span class="hljs-keyword">return</span> toLocalDate(date, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.util.Date -&gt; java.time.LocalTime</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> date java.util.Date</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zoneId A time-zone ID, if null than use system default</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.time.LocalTime</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalTime <span class="hljs-title function_">toLocalTime</span><span class="hljs-params">(Date date, ZoneId zoneId)</span> &#123;<br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> date.toInstant();<br>        <span class="hljs-keyword">if</span> (zoneId == <span class="hljs-literal">null</span>) &#123;<br>            zoneId = ZoneId.systemDefault();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instant.atZone(zoneId).toLocalTime();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.util.Date -&gt; java.time.LocalTime</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> date java.util.Date</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.time.LocalTime</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalTime <span class="hljs-title function_">toLocalTime</span><span class="hljs-params">(Date date)</span> &#123;<br>        <span class="hljs-keyword">return</span> toLocalTime(date, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.util.Date -&gt; java.time.LocalDateTime</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> date java.util.Date</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zoneId A time-zone ID, if null than use system default</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.time.LocalDateTime</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDateTime <span class="hljs-title function_">toLocalDateTime</span><span class="hljs-params">(Date date, ZoneId zoneId)</span> &#123;<br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> date.toInstant();<br>        <span class="hljs-keyword">if</span> (zoneId == <span class="hljs-literal">null</span>) &#123;<br>            zoneId = ZoneId.systemDefault();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instant.atZone(zoneId).toLocalDateTime();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java.util.Date -&gt; java.time.LocalTime</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> date java.util.Date</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> java.time.LocalDateTime</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDateTime <span class="hljs-title function_">toLocalDateTime</span><span class="hljs-params">(Date date)</span> &#123;<br>        <span class="hljs-keyword">return</span> toLocalDateTime(date, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="CodeCheetSheet" scheme="http://yoursite.com/tags/CodeCheetSheet/"/>
    
  </entry>
  
  <entry>
    <title>Java后端速查表</title>
    <link href="http://yoursite.com/2023/01/20/Java/Java%E5%90%8E%E7%AB%AF%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://yoursite.com/2023/01/20/Java/Java%E5%90%8E%E7%AB%AF%E9%80%9F%E6%9F%A5%E8%A1%A8/</id>
    <published>2023-01-20T02:04:40.000Z</published>
    <updated>2023-03-26T02:41:15.292Z</updated>
    
    <content type="html"><![CDATA[<p>Index</p><ol><li>Java</li><li>Database</li><li>分布式</li><li>Spring &amp; SpringBoot</li><li>微服务</li><li>高并发</li><li>高可用</li><li>其它</li></ol><span id="more"></span><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h2><ul><li>JDK(Java Development Kit)</li><li>JRE(Java Runtime Environment)</li></ul><p>面向对象三大特征:</p><ol><li>封装: 封装是指把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li><li>继承: 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。提高代码的重用，程序的可维护性</li><li>多态: 表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</li></ol><p>Java 和 C++的区别</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li></ul><p>为什么说 Java 语言编译与解释并存？</p><ul><li>编译型语言: 是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码</li><li>解释型语言: 是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</li><li>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。</li></ul><p>为什么重写<code>equals()</code>时必须重写<code>hashCode()</code>方法？</p><ul><li>两个对象调用 equals 方法返回 true, 那么调用 hashCode 返回的值也必须一样</li><li>反之 hashCode 返回值一样 equals 可以返回 false，这种情况为哈希碰撞</li></ul><p>重载(Overload)和重写(<code>@Override</code>)的</p><ul><li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</li><li>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</li></ul><p>深拷贝 vs 浅拷贝</p><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ul><h2 id="Java基本类"><a href="#Java基本类" class="headerlink" title="Java基本类"></a>Java基本类</h2><p>异常(Throwable)： </p><ul><li>Exception（异常）：是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。<ul><li>RuntimeException<ul><li>例如：ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）</li></ul></li></ul></li><li>Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。表示代码运行时 JVM（Java 虚拟机）出现的问题。<ul><li>例如：当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li></ul><p><code>java.util.HashMap</code></p><ul><li>JDK1.7: 数组+单链表+链表(链地址法)(头插法)</li><li>JDK1.8: 数组+单链表+红黑树(当链表(尾插法)的深度达到8的时候，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O(n)变成O(logN)提高了效率)</li><li>put操作的流程：<ol><li><code>key.hashcode()</code>，时间复杂度O(1)</li><li>找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)</li><li>如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(n)</li><li>如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(logn)</li></ol></li><li>如果<code>new HashMap()</code>不传值，默认大小是 16，负载因子是 0.75，如果自己传入初始大小 k，初始化大小为 大于 k 的 2 的整数次方，例如如果传 10，大小为 16</li><li>HashMap 的哈希函数怎么设计的吗？<ul><li>hash 函数是先拿到通过 key 的 hashcode，是 32 位的 int 值，然后让 hashcode 的高 16 位和低 16 位进行异或操作。哈希函数也叫扰动函数，一定要尽可能降低 hash 碰撞，越分散越好；算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；</li></ul></li><li>为什么采用 hashcode 的高 16 位和低 16 位异或能降低 hash 碰撞？hash 函数能不能直接用 key 的 hashcode？<ul><li>因为 <code>key.hashCode()</code>函数调用的是 key 键值对象自带的哈希函数，返回 int 型散列值(int 值范围为-2147483648~2147483647)，前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。你想，如果 HashMap 数组的初始大小才 16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。</li></ul></li></ul><p><code>java.util.concurrent.ConcurrentHashMap</code></p><ul><li>采用了分段锁技术</li><li>构造方法(Segment数组里面的Entry数组全部加起来的初始化大小, Segment数组的大小)</li><li>理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment</li><li>这里给Segment加锁采用的机制是CAS，否则自旋，同时还用到了ReentrantLock(可重入锁)</li><li>JDK1.8中，ConcurrentHashMap摒弃了Segment，而是采用synchronized+CAS+红黑树来实现的。锁的粒度也从段锁缩小为结点(Node)锁</li></ul><p>1.7</p><ul><li>put(): <ol><li>通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put</li><li>尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁</li><li>重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取</li><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry</li><li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li><li>释放当前 Segment 的锁</li></ol></li><li>get():<ol><li>Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值</li></ol></li></ul><p>1.8与1.7的区别</p><ul><li>put(): <ol><li>直接定位到桶，拿到 first 节点后进行判断:</li><li>为空则 CAS 插入</li><li>为 -1 则说明在扩容，则跟着一起扩容；else 则加锁 put(类似1.7)</li></ol></li><li>get():<ol><li>由于 value 声明为 volatile，保证了修改的可见性，因此不需要加锁</li></ol></li></ul><p>面试题:</p><ol><li>HashMap数据结构及扩容机制</li><li>HashMap 1.7和1.8区别，红黑树怎么遍历的.</li><li>HashMap尾插法和头插法区别: 就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。这样做可以避免多线程操作时头插法可能会出现环形链表。</li></ol><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树(Red-Black Tree，简称R-B Tree)，它一种特殊的二叉查找树。<br>红黑树是特殊的二叉查找树，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。<br>在自平衡二叉搜索树的基础上，有颜色。即通过与颜色相关的《红黑树5性质》限定了红黑树自平衡的程度，使其不是严格意义上的平衡二叉树。平衡二叉树过于严格的限制了高度差不得超过1，会使树的结构调整过于频繁。这也是为什么要有红黑树。</p><ol><li>性质1.(红黑)节点是红色或黑色。</li><li>性质2.(黑根)根节点是黑色。</li><li>性质3.(黑叶)所有叶子都是黑色。(叶子是NULL节点)</li><li>性质4.(二黑)每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>性质5.(黑高)从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ol><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><p>传统拷贝流程(下载文件为例):</p><ul><li>磁盘 -&gt; 内核缓冲区 -&gt; 用户缓冲区 -&gt; 网络堆栈相关的内核缓冲区 -&gt; 网卡</li><li>DMA从磁盘读取文件到内核缓冲区 -&gt; CPU从内核缓冲区拷贝到用户缓冲区 -&gt; 应用程序调write系统调用把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区 -&gt; socket把内核缓冲区的内容发送到网卡上</li></ul><p>零拷贝(下载文件为例):</p><ul><li>磁盘 -&gt; 内核缓冲区 -&gt; 网络堆栈相关的内核缓冲区 -&gt; 网卡</li><li>磁盘上的数据会通过DMA被拷贝的内核缓冲区 -&gt; 操作系统把内核缓冲区与应用程序共享 -&gt; 应用程序调write系统调用将内核缓冲区的内容拷贝到socket缓冲区中 -&gt; socket把内核缓冲区的内容发送到网卡上</li></ul><p>BIO(Blocked I&#x2F;O): 面向流(单向); 同步阻塞I&#x2F;O</p><ol><li>服务端: 通过ServerSocket注册端口</li><li>服务端: 调用<code>accept()</code>监听客户端Socket请求</li><li>客户端: 调用<code>connect()</code>连接服务端</li><li>服务端&#x2F;客户端: 从Socket中获取字节输入流或输出流对数据进行读写操作</li></ol><p>NIO(Non-blocked I&#x2F;O): 面向缓冲区(双向); 非阻塞I&#x2F;O</p><ul><li>一个线程对应一个Selector选择器</li><li>一个Selector对应多个Channel通道</li><li>一个Channel对应一个Buffer(底层是一个数组)</li><li>直接缓冲区与非直接缓冲区<ul><li>直接缓冲区(非堆内存): 本地IO -&gt; 直接内存 -&gt; 本地IO</li><li>非直接缓冲区(堆内存): 本地IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地IO</li></ul></li></ul><p>Selector选择器</p><ul><li>可以通过Selector来实现一个I&#x2F;O线程并发处理N个客户端连接和读写操作</li><li>Selector接多个Channel并监听这些Channel上的事件，使用选择器的事件迭代器遍历获取选择器监听到的事件并判断事件类型分别处理，处理完后清除事件</li></ul><p>AIO(Async-Blocked I&#x2F;O): 异步非阻塞I&#x2F;O</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程</p><ul><li>进程(资源分配的基本单位): 是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>线程(执行调度的基本单位): 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是多个线程可以共享同一块内存空间和一组系统资源(堆)，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。但是频繁的切换线程可能会消耗大量的CPU资源，因为需要频繁的保存和恢复线程运行上下文。<ul><li>特性<ol><li>可见性</li><li>有序性</li><li>原子性</li></ol></li></ul></li><li>纤程: Java不涉及</li></ul><p>线程撕裂者: 一个核里面可以跑多个线程</p><ul><li>一颗CPU可以有多个核，正常的CPU一个核可以同时跑一个线程</li><li>线程撕裂者就是一个核里面有一个ALU(arithmetic and logic unit)和2寄存器组，ALU可以在2个寄存器组之间快速切换，一个寄存器组存一个线程的工作数据，这样一个核看起来就是同时跑2个线程。例如4核8线程</li></ul><p>并行与并发</p><ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS(Transaction per Second 事物数&#x2F;秒)或者QPS(Queries Per Second 查询数&#x2F;秒)来反应这个系统的处理能力</li></ul><p>线程安全:<br>经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。</p><p>死锁:<br>产生死锁的四个必要条件</p><ol><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不可剥夺条件: 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)。</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件: 存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有(i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有</li></ol><p>同步:<br>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。常见的解决方法是使用<code>synchronized</code>关键字。</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><code>synchronized</code>关键字</h3><ul><li><p><code>synchronized(expression) &#123;// 同步代码块&#125;</code>: 对表达式<code>expresssion</code>求值(值的类型须是引用类型reference type)，获取它所代表的对象，然后尝试获取这个对象的锁 -&gt; 如果能获取锁，则进入同步块执行，执行完后退出同步块，并归还对象的锁(异常退出也会归还); 如果不能获取锁，则阻塞在这里，直到能够获取锁;</p></li><li><p>特性:</p><ol><li>原子性: 同步代码块中的内容要么全部执行要么都不执行</li><li>可见性: 多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性。这点和<code>volatile</code>的实现类似，被<code>volatile</code>修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性</li><li>有序性: 程序执行的顺序按照代码先后执行，每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性</li><li>可重入性: <code>synchronized</code>关键字属于可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</li></ol></li><li><p>源码解读</p><ul><li>反编译使用了<code>synchronized</code>关键字的类的class文件可以看到两种实现方法:<ol><li>字节码指令(<code>monitorenter</code>,<code>monitorexit</code>): 修饰同步代码块</li></ol><ul><li><code>synchronized</code>修饰在方法块: 通过 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令获取线程的执行权的。当方法执行完毕退出以后或者出现异常的情况下会自动释放锁</li><li>JVM执行到<code>monitorenter</code>指令时它会尝试获取对象的锁，如果该对象没有锁，或者当前线程已经拥有了这个对象的锁时，它会把计数器+1；然后当执行到<code>monitorexit</code> 指令时就会将计数器-1；然后当计数器为0时，锁就释放了。如果获取锁失败，那么当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</li><li>反编译后可以看到一个<code>monitorenter</code>和两个<code>monitorexit</code>: 这是因为第二个<code>monitorexit</code>是给异常处理释放锁用的</li><li>monitor到底是什么: monitor它就是个监视器，底层源码是C++编写的</li></ul><ol start="2"><li><code>flag=ACC_SYNCHRONIZED</code>: 修饰同步方法</li></ol><ul><li>这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。</li></ul></li></ul></li><li><p>可重入锁: 就是一个线程不用释放，可以重复的获取一个锁n次，只是在释放的时候，也需要相应的释放n次。(简单来说：A线程在某上下文中或得了某锁，当A线程想要在次获取该锁时，不会应为锁已经被自己占用，而需要先等到锁的释放)假使A线程即获得了锁，又在等待锁的释放，就会造成死锁。</p></li></ul><p><code>monitorenter</code>, <code>monitorexit</code>的指令解析是通过InterpreterRuntime.cpp中的两个方法实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// monitorenter(JavaThread 当前获取锁的线程, BasicObjectLock 基础对象锁)</span><br><span class="hljs-built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="hljs-type">void</span>, InterpreterRuntime::<span class="hljs-built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASSERT</span><br>  thread-&gt;<span class="hljs-built_in">last_frame</span>().<span class="hljs-built_in">interpreter_frame_verify_monitor</span>(elem);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics) &#123;<br>    Atomic::<span class="hljs-built_in">inc</span>(BiasedLocking::<span class="hljs-built_in">slow_path_entry_count_addr</span>());<br>  &#125;<br>  <span class="hljs-function">Handle <span class="hljs-title">h_obj</span><span class="hljs-params">(thread, elem-&gt;obj())</span></span>;<br>  <span class="hljs-built_in">assert</span>(Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">is_in_reserved_or_null</span>(<span class="hljs-built_in">h_obj</span>()),<br>         <span class="hljs-string">&quot;must be NULL or an object&quot;</span>);<br>  <span class="hljs-keyword">if</span> (UseBiasedLocking) &#123; <span class="hljs-comment">// UseBiasedLocking是在JVM启动的时候，是否启动偏向锁的标识</span><br>    <span class="hljs-comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span><br>    <span class="hljs-comment">// 当处于不安全点时，通过 revoke_and_rebias尝试获取偏向锁，如果成功则直接返回，如果失败则进入轻量级锁获取过程</span><br>    ObjectSynchronizer::<span class="hljs-built_in">fast_enter</span>(h_obj, elem-&gt;<span class="hljs-built_in">lock</span>(), <span class="hljs-literal">true</span>, CHECK);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果偏向锁未开启，则进入 slow_enter获取轻量级锁的流程</span><br>    <span class="hljs-comment">// BasicObjectLock对象的lock属性的地址用于实现轻量级锁，即所谓的Thread ID</span><br>    ObjectSynchronizer::<span class="hljs-built_in">slow_enter</span>(h_obj, elem-&gt;<span class="hljs-built_in">lock</span>(), CHECK);<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">is_in_reserved_or_null</span>(elem-&gt;<span class="hljs-built_in">obj</span>()),<br>         <span class="hljs-string">&quot;must be NULL or an object&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASSERT</span><br>  thread-&gt;<span class="hljs-built_in">last_frame</span>().<span class="hljs-built_in">interpreter_frame_verify_monitor</span>(elem);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IRT_END<br><br><span class="hljs-comment">// monitorexit(JavaThread 当前获取锁的线程, BasicObjectLock 基础对象锁)</span><br><span class="hljs-built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="hljs-type">void</span>, InterpreterRuntime::<span class="hljs-built_in">monitorexit</span>(JavaThread* thread, BasicObjectLock* elem))<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASSERT</span><br>  thread-&gt;<span class="hljs-built_in">last_frame</span>().<span class="hljs-built_in">interpreter_frame_verify_monitor</span>(elem);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-function">Handle <span class="hljs-title">h_obj</span><span class="hljs-params">(thread, elem-&gt;obj())</span></span>;<br>  <span class="hljs-built_in">assert</span>(Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">is_in_reserved_or_null</span>(<span class="hljs-built_in">h_obj</span>()),<br>         <span class="hljs-string">&quot;must be NULL or an object&quot;</span>);<br>  <span class="hljs-keyword">if</span> (elem == <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">h_obj</span>()-&gt;<span class="hljs-built_in">is_unlocked</span>()) &#123;<br>    <span class="hljs-built_in">THROW</span>(vmSymbols::<span class="hljs-built_in">java_lang_IllegalMonitorStateException</span>());<br>  &#125;<br>  ObjectSynchronizer::<span class="hljs-built_in">slow_exit</span>(<span class="hljs-built_in">h_obj</span>(), elem-&gt;<span class="hljs-built_in">lock</span>(), thread);<br>  <span class="hljs-comment">// Free entry. This must be done here, since a pending exception might be installed on</span><br>  <span class="hljs-comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span><br>  elem-&gt;<span class="hljs-built_in">set_obj</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASSERT</span><br>  thread-&gt;<span class="hljs-built_in">last_frame</span>().<span class="hljs-built_in">interpreter_frame_verify_monitor</span>(elem);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IRT_END<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// slow_enter</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectSynchronizer::slow_enter</span><span class="hljs-params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;<br>  markOop mark = obj-&gt;<span class="hljs-built_in">mark</span>();<br>  <span class="hljs-built_in">assert</span>(!mark-&gt;<span class="hljs-built_in">has_bias_pattern</span>(), <span class="hljs-string">&quot;should not see bias pattern here&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">is_neutral</span>()) &#123;<span class="hljs-comment">// 如果当前是无锁状态, markword的</span><br>    <span class="hljs-comment">// 直接把mark保存到BasicLock对象的_displaced_header字段</span><br>    lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(mark);<br>    <span class="hljs-comment">// 通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁</span><br>    <span class="hljs-comment">// BasicObjectLock对象的lock属性为Thread ID</span><br>    <span class="hljs-keyword">if</span> (mark == (markOop) Atomic::<span class="hljs-built_in">cmpxchg_ptr</span>(lock, <span class="hljs-built_in">obj</span>()-&gt;<span class="hljs-built_in">mark_addr</span>(), mark)) &#123;<br>      <span class="hljs-built_in">TEVENT</span> (slow_enter: release stacklock) ;<br>      <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// Fall through to inflate() ...</span><br>  &#125; <br>  <span class="hljs-comment">// 如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧，表示为重入操作，不需要争抢锁</span><br>  <span class="hljs-keyword">else</span><br>  <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="hljs-built_in">is_lock_owned</span>((address)mark-&gt;<span class="hljs-built_in">locker</span>())) &#123;<br>    <span class="hljs-built_in">assert</span>(lock != mark-&gt;<span class="hljs-built_in">locker</span>(), <span class="hljs-string">&quot;must not re-lock the same lock&quot;</span>);<br>    <span class="hljs-built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="hljs-built_in">mark</span>(), <span class="hljs-string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);<br>    lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>  <span class="hljs-comment">// The following optimization isn&#x27;t particularly useful.</span><br>  <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">has_monitor</span>() &amp;&amp; mark-&gt;<span class="hljs-built_in">monitor</span>()-&gt;<span class="hljs-built_in">is_entered</span>(THREAD)) &#123;<br>    lock-&gt;<span class="hljs-built_in">set_displaced_header</span> (<span class="hljs-literal">NULL</span>) ;<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 代码执行到这里，说明有多个线程竞争轻量级锁，轻量级锁通过`inflate`进行膨胀升级为重量级锁</span><br>  lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(markOopDesc::<span class="hljs-built_in">unused_mark</span>());<br>  ObjectSynchronizer::<span class="hljs-built_in">inflate</span>(THREAD, <span class="hljs-built_in">obj</span>())-&gt;<span class="hljs-built_in">enter</span>(THREAD);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/realize_dream/article/details/106968443">深入理解synchronized底层源码</a><br><a href="https://blog.csdn.net/qq_31865983/article/details/105024397">HotSpot 三种锁实现总结</a></p></blockquote><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁的实现本质上都对应着一个入口的等待队列</p><p>公平锁和非公平锁</p><ul><li>公平锁: 多个线程按照申请锁的顺序去获得锁，线程会按顺序进入队列，永远是队列第一位先获得锁</li><li>非公平锁: 多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁</li></ul><p>ReentrantLock 中就有公平锁和非公平锁的实现。默认是采用非公平锁的策略来实现锁的竞争逻辑，它内部是使用AQS来实现所资源的竞争，没有竞争到锁资源的线程，会加入到AQS的同步队列里，这个队列是一个FIFO的双向链表。</p><p>JDK6之前: 无锁、有锁(重量级锁)<br>JDK6之后: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁(CAS) -&gt; 重量级锁</p><ol><li>偏向锁</li></ol><ul><li>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程ID等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作</li></ul><ol start="2"><li>轻量级锁</li></ol><ul><li>当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块</li><li>只需要将lock属性地址(ThreadID)通过CAS写入对象头即视为加锁成功，因为BasicLock只有一个8字节属性。当存在多个线程抢占轻量级锁的时候，只有一个能够抢占成功，获取轻量级锁恢复正常执行，其他线程都会尝试将该轻量级锁膨胀成重量级锁，也只有一个线程完成锁膨胀。</li></ul><ol start="3"><li>重量级锁</li></ol><ul><li>当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大</li></ul><p>Q: synchronized什么时候是偏向锁，轻量级锁以级重量级锁.</p><ul><li>一个线程获得了锁，那么锁就进入偏向模式。第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。如果还有第三个或以上的线程竞争锁时，锁就会被升级成重量级锁。</li></ul><p>JVM中对象实例的组成:</p><ol><li>对象头:</li></ol><ul><li>Mark Word:<ul><li>对象的hashCode</li><li>锁信息: 记录对象锁当前的状态，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据</li><li>分代年龄</li><li>GC标志</li></ul></li><li>Class Metadata Address: 类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例</li></ul><ol><li>实例数据: 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐</li><li>对其填充</li></ol><p>先行发生原则(happens-before): 在发生操作B之前，操作A产生的影响能被操作B观察到。先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><code>volatile</code>关键字</h3><p><code>volatile</code>关键字: 当一个变量定义为volatile之后，它将具备两种特性</p><ol><li>保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</li><li>禁止指令重排序优化</li></ol><ul><li>CPU指令重排序遵循2个原则:<ol><li>as-if-serial: 不管怎么重排序，(单线程)程序的执行结果不能被改变，即重排序前和排序后的执行结果应该是一样的</li><li>happens-before: JDK5后引入，用于保证程序执行的原子性、可见性和有序性</li></ol></li></ul><ol start="3"><li>保证不指令重排序的机制:</li></ol><ul><li>字节码层面: 生成的字节码不会重排序</li><li>CPU层面: 内存屏障: 屏障指令(汇编指令)加载需要保证不重排序的指令之间起到屏障的作用</li></ul><p>内存屏障<br>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（Memory Barrier）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。<br>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。<br>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以loadFence方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。<br>Unsafe 中提供了下面三个内存屏障相关方法：</p><ol><li><code>public native void loadFence();</code>: 内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</li><li><code>public native void storeFence();</code>: 内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</li><li><code>public native void fullFence();</code>: 内存屏障，禁止load、store操作重排序</li></ol><p>ReentrantLock(可重入锁):</p><ul><li>指的是一个线程能够对一个临界资源重复加锁</li></ul><p>LongAdder</p><ul><li>采用分段CAS: 除了真正记录数值的base属性外，还有与base相同的数据类型的cell数组，如果存在多个线程同时对Lang做自增操作，则new一个cell元素放到cell数组里供新增的线程做操作(这里会根据线程数自动扩容或缩容cell数组)，使得同时对base做自增操作的线程数变少，自旋占用的CPU变少，最后再用sum求和操作对所有cell属性和base属性做求和操作并返回，这个求出来的和就是所有线程做的操作的总和</li></ul><h3 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h3><p>Java 中实现多线程的方法</p><ol><li>继承 <code>Thread</code> 类</li><li>实现 <code>Runnable</code> 接口: 如果一个类继承 Thread类，则不适合于多个线程共享资源，而实现了 Runnable 接口，就可以方便的实现资源的共享</li></ol><p>线程的状态变化:</p><ol><li>New(创建状态): 在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时它已经有了相应的内存空间和其他资源(程序计数器、本地方法栈、虚拟机栈)，但还处于不可运行状态。新建一个线程对象可采用<code>Thread</code> 类的构造方法来实现，例如 <code>Thread thread=new Thread()</code></li><li>Ready(就绪状态): 新建线程对象后，调用该线程的 <code>start()</code> 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 调度，这表明它已经具备了运行条件</li><li>Running(运行状态): 当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 <code>run()</code> 方法。<code>run()</code> 方法定义该线程的操作和功能</li><li>Blocked(阻塞状态): 一个正在执行的线程遇到<code>synchronized</code>，会进入阻塞状态。线程都将进入阻塞状态，阻塞的线程进入调度队列entry set排队，获取到锁的线程才可以转入就绪状态</li><li>Waiting(等待): 调用<code>Object.wait()</code>, <code>Thread.join()</code>方法可使一个线程进入不带时限的等待状态，直到其它线程调用了方法<code>Object.notify()</code>或<code>Object.notifyAll()</code>唤醒了等待状态的线程，被唤醒后可能进入调度队列entry set继续等待获取锁(Blocked状态)或直接获取到锁(Runnable状态)</li><li>Time_Waiting(超时等待): 调用<code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>Thread.sleep(long)</code>方法可使一个线程进入带时限的等待状态，直到其它线程调用了方法<code>Object.notify()</code>或<code>Object.notifyAll()</code>唤醒了等待状态的线程</li><li>Terminated(死亡状态): 线程调用 <code>stop()</code> 方法时或 <code>run()</code> 方法执行结束后，即处于死亡状态。</li></ol><blockquote><p><a href="https://www.cnblogs.com/zhongchang/articles/10339134.html">Java 线程状态之 WAITING</a></p></blockquote><p>常用的线程池<code>java.util.concurrent.Executors</code>类下静态方法:</p><ol><li><code>newSingleThreadExecutor()</code>: 创建了一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li><li><code>newFixedThreadPool(int nThreads)</code>: 创建了一个固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大值<code>nThreads</code>。线程池的大小一旦达到最大值后，再有新的任务提交时则放入无界阻塞队列中，等到有线程空闲时，再从队列中取出任务继续执行。</li><li><code>newCachedThreadPool()</code>: 创建了一个可缓存的线程池。当有新的任务提交时，有空闲线程则直接处理任务，没有空闲线程则创建新的线程处理任务，队列中不储存任务。线程池不对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。如果线程空闲时间超过了60秒就会被回收。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, // 核心线程数</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize, // 线程池最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime, // 超出核心线程数的线程等待new task的时间，超过则terminated</span><br><span class="hljs-params">                          TimeUnit unit, // keepAliveTime时间的单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 用于保存等待执行的任务的阻塞队列: 用于存放等待线程执行的task的队列只存放由execute方法提交的Runnable任务</span><br><span class="hljs-params">                          RejectedExecutionHandler handler // 线程池对拒绝任务的处理策略</span><br><span class="hljs-params">                          )</span>; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;())); <span class="hljs-comment">// 本身是有界队列但是这里未设置其大小限制，默认Integer.MAX_VALUE，此时相当于无界队列</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;()); <span class="hljs-comment">// 这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Executors</code>存在什么问题</p><ul><li><code>SingleThreadPool</code>和<code>FixedThreadPool</code>使用的是无界队列，其请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求而导致OOM</li><li><code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能会大量创建线程而导致OOM</li></ul><p>创建线程池的正确姿势，直接使用<code>java.util.concurrent.ThreadPoolExecutor</code>类的构造方法来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-comment">// 10个线程，最大也支持10个</span><br>        <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-comment">// 超时时间60秒</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">10</span>), <span class="hljs-comment">// 有界队列，容量为10，最多容纳10个task</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="hljs-string">&quot;my-pool-%d&quot;</span>).build(), <span class="hljs-comment">// 线程名称</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()); <span class="hljs-comment">// 拒绝策略(默认)</span><br><br></code></pre></td></tr></table></figure><p>Q: 线程池怎么设置核心线程数?</p><ul><li>如果是CPU密集型服务线程数量等于CPU核心数</li><li>如果是I&#x2F;O密集型服务: 线程数 &#x3D; ((工作时间+休息时间)&#x2F;工作时间) * CPU核心数 * CPU利用率</li></ul><p>workQueue(工作队列): </p><ul><li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO（先进先出）原则对任务进行排序。使用该队列，线程池中能创建的最大线程数为<code>maximumPoolSize</code>。 </li><li><code>LinkedBlockingQueue</code>: 基于链表结构的无界阻塞队列，按FIFO（先进先出）原则对任务进行排序，吞吐量高于<code>ArrayBlockingQueue</code>。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li><li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列。添加任务的操作必须等到另一个线程的移除操作，否则添加操作一直处于阻塞状态。</li><li><code>PriorityBlockingQueue</code>: 一个支持优先级的无界阻塞队列。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li></ul><p>线程池(<code>ThreadPoolExecutor</code>)处理流程:</p><ol><li>提交任务 <code>execute(Runnable)</code></li><li>核心线程池是否已满? N: 创建线程执行任务</li><li>队列是否已满? N: 将任务存储在队列中</li><li>线程池是否已满? N: 创建非核心线程执行任务</li><li>经过以上步骤还是有新任务则执行拒绝策略</li></ol><p>handler(饱和策略，或者又称拒绝策略): 当队列和线程池都满了，即线程池饱和了，必须采取一种策略处理提交的新任务。</p><ul><li><code>AbortPolicy</code>: 无法处理新任务时，直接抛出异常，这是默认策略。 </li><li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务。</li><li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中最靠前的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>: 直接丢弃任务。</li></ul><p>线程池的状态:</p><ol><li>RUNNING: 该状态的线程池既能接受新提交的任务，又能处理阻塞队列中任务。</li><li>SHUTDOWN: 该状态的线程池不能接收新提交的任务，但是能处理阻塞队列中的任务。处于 RUNNING 状态时，调用<code>shutdown()</code>方法会使线程池进入到该状态。 注意： <code>finalize()</code>方法在执行过程中也会隐式调用<code>shutdown()</code>方法。 </li><li>STOP: 该状态的线程池不接受新提交的任务，也不处理在阻塞队列中的任务，还会中断正在执行的任务。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态</li><li>TIDYING: 如果所有的任务都已终止，workerCount(有效线程数)&#x3D;0 。线程池进入该状态后会调用 <code>terminated()</code> 钩子方法进入TERMINATED 状态。</li><li>TERMINATED: 在<code>terminated()</code>钩子方法执行完后进入该状态，默认<code>terminated()</code>钩子方法中什么也没有做。</li></ol><p>线程池的关闭可通过<code>shutdown()</code>或者<code>shutdownNow()</code>方法 </p><ul><li><code>shutdown()</code>将线程池的状态设置为<code>SHUTDOWN</code>状态，只会中断空闲的工作线程</li><li><code>shutdownNow()</code>将线程池的状态设置为<code>STOP</code>状态，会中断所有工作线程，不管工作线程是否空闲</li><li>调用两者中任何一种方法，都会使<code>isShutdown()</code>方法的返回值为true；</li><li>线程池中所有的任务都关闭后，<code>isTerminated()</code>方法的返回值为true</li></ul><p>Q: 新的任务提交到线程池，线程池是怎样处理的？<br>步骤：</p><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。</li><li>线程池判断工作队列是否已经满。如果没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p>Q: 父线程子线程怎么共享数据?</p><ul><li>可以使用<code>InheritableThreadLocals</code>可继承线程变量这个类来实现，<code>ThreadLocals</code>是线程变量，相当于一个map，每个线程是map的key，value是<code>set()</code>进去的值，一个线程使用<code>get()</code>只能get到它自己set进去的值，所以不可用于获取父线程的数据。而<code>InheritableThreadLocals</code>会在子线程new出来的时候就把自己的value复制进去，所以子线程可以使用这个来共享获取父线程的数 据</li></ul><p>Q: 线程池怎么维护线程状态，怎么处理线程异常.什么时候task需要queued</p><ul><li>TODO</li></ul><h3 id="AQS-AbstractQueuedSynchronized"><a href="#AQS-AbstractQueuedSynchronized" class="headerlink" title="AQS(AbstractQueuedSynchronized)"></a>AQS(AbstractQueuedSynchronized)</h3><ul><li>抽象队列同步器AQS: 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列. AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch</li><li>底层实现为: volatile + CAS</li><li>AQS内部维护了一个volatile修饰的共享变量，<code>state</code>主要用来标记锁的状态。</li><li>AQS通过自定义Node节点来维护一个队列，完成资源获取线程的排队工作。</li><li>AQS通过<code>park</code>和<code>unParkSuccessor</code>方法来实现阻塞和唤醒线程。</li><li>AQS内部的<code>compareAndSetState</code>方法保证了锁状态设置的原子性。</li></ul><p>默认ReentrantLock采用的是非公平锁实现，下面来分析一次ReebtrantLock加锁的过程吧，整体的过程描述如下：</p><ol><li>当线程A访问时，先判断<code>state</code>所标记值是否为0</li><li>发现<code>state</code>标识为0，接着将<code>state</code>的值通过<code>compareAndSetState()</code>方法修改为1</li><li>设置当前拥有独占访问权的线程A为自己当前线程</li><li>其他线程B再次访问，也是一上来先去判断了一下<code>state</code>状态，发现是1，自然CAS失败了，只能乖乖进入等待队列</li><li>经过一段时间，线程A访问资源结束，准备释放锁，修改<code>state</code>状态为0，准备去唤醒B线程</li><li>这时候线程C也过来了，他也来抢占锁资源，发现<code>state</code>为0，线程C果断CAS成功，抢占了锁资源，还修改当前线程为自己</li><li>线程B被A唤醒准备去获取锁，发现<code>state</code>已经是1了，锁资源已经被抢占，结果线程B又只能默默回去等等队列继续等待了</li></ol><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><ul><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li><li>CAS操作都是通过sun包下Unsafe类实现，而Unsafe类中的方法都是native方法CAS通过调用JNI(Java Native Interface)的c++代码实现的</li><li>unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 <code>Atomic::cmpxchg</code></li><li><code>Atomic::cmpxchg</code> 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li><li>Atomic类中的value是<code>volatile</code>的，<code>volatile</code>可以保证可见性和有序性</li><li>Atomic类中设置值使用自旋锁，不断取内存中的value值，然后CAS更新，若失败则持续自旋重试更新操作</li><li>缺点:<ol><li>ABA问题:</li></ol><ul><li>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<code>AtomicStampedReference</code>类具有版本号功能</li></ul><ol start="2"><li>只能保证一个共享变量的原子操作: 多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者把多个共享变量合并成一个共享变量来操作(JDK1.5之后提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作)</li></ol></li></ul><p><code>Atomic::cmpxchg</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK_IF_MP(mp) <span class="hljs-string">&quot;cmp $0, &quot;</span> #mp <span class="hljs-string">&quot;; je 1f; lock; 1: &quot;</span><span class="hljs-comment">// 判断mp是否为多核CPU是则返回LOCK指令</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> jlong <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jlong exchange_value, <span class="hljs-keyword">volatile</span> jlong* dest, jlong compare_value)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> mp = os::<span class="hljs-built_in">is_MP</span>(); <span class="hljs-comment">// </span><br>  __arm__ __volatile__ (<span class="hljs-built_in">LOCK_IF_MP</span>(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgq %1,(%3)&quot;</span> <span class="hljs-comment">// MP=mult prosser LOCK_IF_MP返回lock指令 汇编指令cmpxchgq执行原子的CAS</span><br>                        : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)<br>                        : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)<br>                        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>);<br>  <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>乐观锁底层实现: lock + cmpxchg 指令</li><li>悲观锁底层实现: lock 指令</li><li>volatile的底层实现也是用的: lock指令</li></ul><h3 id="缓存一致性协议-硬件级别的协议"><a href="#缓存一致性协议-硬件级别的协议" class="headerlink" title="缓存一致性协议: 硬件级别的协议"></a>缓存一致性协议: 硬件级别的协议</h3><ul><li>作用: 多核CPU有多个一级缓存，保证缓存内部数据的一致,不让系统数据混乱</li><li>Intel CPU对缓存一致性协议的实现(MESI &#x3D; modified + exclusive + shared + invalid)</li><li>MESI中每个缓存行(Cache line:CPU中缓存存储数据的单元，一般为64字节)都有四个状态(假设线程 A 和线程 B 同时对一个变量执行 i++)<ol><li>核心 A 从内存中加载变量 i，并将缓存行设置为 E（独享），随后通过总线嗅探检查内存中对变量 i 的操作；</li><li>核心 B 从内存中加载变量 i，总线嗅探机制会将核心 A 与核心 B 的缓存行设置为 S（共享）</li><li>核心 A 对变量 i 进行修改，缓存行设置为 M（修改），而核心 B 被通知修改缓存行为 I（无 效）。如果存在高并发，则交给总线裁决</li><li>核心 A 将修改后数据同步回内存，并将变量设置为 E（独享）</li><li>核心 B 重新刷新缓存行，并将缓存行核心 A 和核心 B 的缓存行设置为 S（共享）</li></ol></li><li>CPU 是通过总线和内存进行数据传输的。在多核心时代下，多个核心通过同一条总线和内存以及其他硬件进行通信</li><li>通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行</li><li>伪共享问题: 伪共享是指多个线程同时读写同一个缓存行中的变量，而导致缓存行失效的问题。尽管多个线程分别访问的是不同的数据，但由于它们存在同一个缓存行中，只要任何一方修改都会使得缓存失效，降低了运算效率。</li><li>解决方案: <ol><li>字节填充，在变量前后填充多个字节使得 变量大小+填充的字节&#x3D;64字节，这样这个变量肯定会独占一个缓存行。</li><li>JDK8以及之后的版本 Java 提供了<code>sun.misc.Contended</code> 注解，通过<code>@Contented</code>注解就可以解决伪共享的问题。使用<code>@Contented</code>注解后会增加128字节的padding，并且需要开启<code>-XX:-RestrictContended</code>选项后才能生效。</li></ol></li><li>Q: 你工作中遇到的一个比较大的问题是什么</li><li>A: 钻石突击队抢单，</li></ul><blockquote><p><a href="https://blog.csdn.net/m18870420619/article/details/82431319">CPU缓存一致性协议MESI</a><br><a href="https://www.cnblogs.com/jokerjason/p/9584402.html">缓存行与MESI</a></p></blockquote><h3 id="用户态内核态"><a href="#用户态内核态" class="headerlink" title="用户态内核态"></a>用户态内核态</h3><ul><li>Linux操作系统的体系架构分为用户态和内核态</li><li>内核态: 本质上是一种软件，控制计算机硬件资源(CPU资源、存储资源、I&#x2F;O资源等)</li><li>用户态: 上层应用程序的活动空间</li><li>上层应用想要访问计算机硬件资源需要通过内核提供的访问接口(系统调用)来调用</li><li>系统调用是操作系统的最小功能单位</li><li>从用户态到内核态切换可以通过三种方式:<ol><li>系统调用</li><li>异常: 如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常</li><li>外设中断: 当外设完成用户的请求时，会向CPU发送中断信号</li></ol></li></ul><h2 id="多线程框架"><a href="#多线程框架" class="headerlink" title="多线程框架"></a>多线程框架</h2><p>Disruptor 框架</p><ul><li>英国外汇交易公司LMAX开发的一个高性能队列。主要用于线程与线程之间的消息传递</li><li>QPS: 600w</li><li>为什么快:<ol><li>CAS: ArrayBlockingQueue使用了重量级锁(lock锁)，而Disruptor采用CAS操作</li><li>消除伪共享: 解决方案: 字节填充，在变量前后填充多个字节使得 变量大小+填充的字节&#x3D;64字节，这样这个变量肯定会独占一个缓存行。</li><li>RingBuffer: 环形数组，没有删除操作，超过容量会直接覆盖原有数据，避免了垃圾回收。大小必须为2的n次方，因为取余运算直接使用的是位运算，使得元素定位更快。</li></ol></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载子系统: 根据给定的全限定名类名(如java.lang.Object)来装载class文件的内容到方法区(Method Area)</p><ol><li>Bootstrap ClassLoader(启动类加载器): <code>$JAVA_HOME</code>中<code>jre/lib/rt.jar</code>里所有的class，由C++实现</li><li>Extension ClassLoader(扩展类加载器): 负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME</code>中<code>jre/lib/*.jar</code>或<code>-D java.ext.dirs</code>指定目录下的jar包</li><li>App ClassLoader(系统类加载器): 负责加载classpath中指定的jar包及目录中class</li><li>Custom ClassLoader(用户自定义类加载器): 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</li></ol><p>双亲委派机制: JVM对class文件采用按需加载的方式，在加载时JVM采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，若无法完成，子类加载器才会去加载。</li></ol><h3 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h3><p>运行时数据区(Runtime Data Area)</p><ol><li>程序计数器(Program Counter Register) &lt;- 线程不共享</li><li>本地方法栈(Native Method Stack) &lt;- 线程不共享</li><li>虚拟机栈(Java Virtual Machine Stack) &lt;- 线程不共享</li><li>方法区(Method Area) &lt;- 线程共享</li><li>堆(Heap) &lt;- 线程共享</li></ol><p>本地内存</p><ol><li>直接内存(Direct Memory)</li><li>方法区(Method Area): 1.8之后挪到了本地内存</li></ol><h4 id="1-程序计数器-Program-Counter-Register"><a href="#1-程序计数器-Program-Counter-Register" class="headerlink" title="1. 程序计数器(Program Counter Register)"></a>1. 程序计数器(Program Counter Register)</h4><p>每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，若为native方法则为undefined</p><h4 id="2-本地方法栈-Native-Method-Stack"><a href="#2-本地方法栈-Native-Method-Stack" class="headerlink" title="2. 本地方法栈(Native Method Stack)"></a>2. 本地方法栈(Native Method Stack)</h4><p>本地方法栈用于管理本地方法的调用</p><h4 id="3-虚拟机栈-Java-Virtual-Machine-Stack"><a href="#3-虚拟机栈-Java-Virtual-Machine-Stack" class="headerlink" title="3. 虚拟机栈(Java Virtual Machine Stack)"></a>3. 虚拟机栈(Java Virtual Machine Stack)</h4><ul><li>线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)</li><li>栈帧的内部结构：<ol><li>局部变量表(Local Variables): 最基本的存储单元是Slot(变量槽)，容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li><li>操作数栈(operand Stack)(或表达式栈): 用于保存计算过程的中间结果</li><li>动态链接(DynamicLinking)(或指向运行时常量池的方法引用): 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)</li><li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义): 存放调用该方法的pc寄存器的值</li></ol></li></ul><h4 id="4-方法区-Method-Area"><a href="#4-方法区-Method-Area" class="headerlink" title="4. 方法区(Method Area)"></a>4. 方法区(Method Area)</h4><p>方法区包含运行时常量池(Runtime Constant Pool)<br>元空间(Metaspace)是其实现，元空间并不在虚拟机中，而是使用本地内存<br>1.8之前方法区在运行时数据区，1.8之后挪到了本地内存</p><h4 id="5-堆-Heap"><a href="#5-堆-Heap" class="headerlink" title="5. 堆(Heap)"></a>5. 堆(Heap)</h4><p>年青代:老年代&#x3D;1:2</p><ul><li>年青代(Young): Eden:From:To&#x3D;8:1:1<ul><li>Eden: 新创建的对象绝大部分会分配在Eden区。当Eden区内存不够的时候，就会触发MinorGC</li><li>Survivor 0(From): 在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄到<code>15</code>，则直接分配到老年代。</li><li>Survivor 1(To)</li></ul></li><li>老年代(Tenured): 老年代存放从年轻代存活的对象。一般来说老年代存放的都是生命期较长的对象</li></ul><h3 id="GC-Generational-Collecting-垃圾回收"><a href="#GC-Generational-Collecting-垃圾回收" class="headerlink" title="GC(Generational Collecting)垃圾回收:"></a>GC(Generational Collecting)垃圾回收:</h3><ul><li>Minor GC: 当伊甸园的空间满时，程序又需要创建对象，触发Minor GC</li><li>Full GC: 当老年代内存不足时，对老年代进行垃圾回收。这时可能会伴随着STW(Stop The World)</li><li>STW(Stop The World): 停止所有线程，进行垃圾回收，这时候线程会被阻塞，直到垃圾回收完成<ul><li>Q: 为什么要STW？-&gt; A: 如果不执行STW的话在Full GC的过程中如果有一个线程执行完毕，那么这个线程的局部变量表里面所指向的在堆里的对象都会变成垃圾，但是此时Full GC还没执行完，那么这次Full GC执行所得到的结果是不准确的</li></ul></li></ul><p>判断对象是否需要回收</p><ol><li>引用计数法: 给对象添加一个引用计数器。但是难以解决循环引用问题。</li><li>可达性分析法: 通过一系列的 <code>GC Roots</code> 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</li></ol><p>垃圾回收算法</p><ol><li>标记-清除算法(Mark-Sweep):</li></ol><ul><li>分为两个阶段：标记阶段(标记出所有需要被回收的对象) -&gt; 清除阶段(回收被标记的对象所占用的空间)</li><li>缺点: 效率不高、空间会产生大量碎片</li></ul><ol start="2"><li>复制算法(Copying): 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。Eden:From:To&#x3D;8:1:1</li><li>标记-整理算法(Mark-Compact): 在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存</li><li>分代收集(Generational Collection): 根据对象的生命周期划分几块内存区，一般是分为新生代和老年代。新生代:老年代&#x3D;1:2</li></ol><p>垃圾收集器:</p><ol><li>Serial&#x2F;Serial Old收集器: 单线程收集器，进行垃圾收集时，必须暂停所有用户线程</li></ol><ul><li>Serial: 新生代 Copying算法</li><li>Serial Old: 老年代 Mark-Compact算法</li></ul><ol start="2"><li>ParNew收集器: Serial收集器的多线程版本</li><li>Parallel Scavenge收集器: 新生代的多线程收集器回收期间不需要暂停其他用户线程 Copying算法</li><li>Parallel Old收集器: 多线程 Mark-Compact算法</li><li>CMS(Concurrent Mark Sweep)收集器: 并发收集器，优点是最短回收停顿时间 Mark-Sweep算法</li><li>G1收集器: 并行与并发收集器，并且它能建立可预测的停顿时间模型</li></ol><h3 id="JVM虚拟机调优"><a href="#JVM虚拟机调优" class="headerlink" title="JVM虚拟机调优:"></a>JVM虚拟机调优:</h3><ul><li>主要是减少STW发生的频率，因为发生STW的时候会阻塞全部的用户线程，在用户看来就是应用程序卡顿</li><li>能不能通过调整JVM参数是的几乎发生Full GC?<ul><li>默认年青代:老年代&#x3D;1:2，改成2:1，那么当年轻代满的时候绝大部分昭生夕死的对象会被干掉，只有实在干不掉的才会挪到老年代</li></ul></li><li>jVisualVM: 可视化工具，可以查看JVM的内存使用情况，安装插件可以观察到堆分代模型的整个GC过程</li></ul><h2 id="Java-定时任务"><a href="#Java-定时任务" class="headerlink" title="Java 定时任务"></a>Java 定时任务</h2><h3 id="单机定时任务技术选型"><a href="#单机定时任务技术选型" class="headerlink" title="单机定时任务技术选型"></a>单机定时任务技术选型</h3><h4 id="java-util-Timer"><a href="#java-util-Timer" class="headerlink" title="java.util.Timer"></a><code>java.util.Timer</code></h4><p>Timer 内部使用一个叫做 TaskQueue 的类存放定时任务，它是一个基于最小堆实现的优先级队列。TaskQueue 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例代码：</span><br><span class="hljs-type">TimerTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> +<br>                <span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br>    &#125;<br>&#125;;<br>System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> + <span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-string">&quot;Timer&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br>timer.schedule(task, delay);<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer</span><br></code></pre></td></tr></table></figure><p>不过其缺陷较多，比如一个 Timer 一个线程，这就导致 Timer 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止(Timer 只捕获了 InterruptedException)。<code>ScheduledThreadPoolExecutor</code> 支持多线程执行定时任务并且功能更强大，是 Timer 的替代品。</p><h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a><code>ScheduledExecutorService</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例代码：</span><br><span class="hljs-type">TimerTask</span> <span class="hljs-variable">repeatedTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> +<br>                <span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br>    &#125;<br>&#125;;<br>System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> + <span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">delay</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br>executor.scheduleAtFixedRate(repeatedTask, delay, period, TimeUnit.MILLISECONDS);<br>Thread.sleep(delay + period * <span class="hljs-number">5</span>);<br>executor.shutdown();<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:46 CST 2021n线程名称: main</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:47 CST 2021n线程名称: pool-1-thread-1</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:48 CST 2021n线程名称: pool-1-thread-1</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:49 CST 2021n线程名称: pool-1-thread-2</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:50 CST 2021n线程名称: pool-1-thread-2</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:51 CST 2021n线程名称: pool-1-thread-2</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:40:52 CST 2021n线程名称: pool-1-thread-2</span><br></code></pre></td></tr></table></figure><p>缺点: 不论是使用 Timer 还是 ScheduledExecutorService 都无法使用 Cron 表达式指定任务执行的具体时间</p><h4 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h4><p>Spring 自带的定时调度只支持单机，并且提供的功能比较单一。底层是基于 JDK 的 ScheduledThreadPoolExecutor 线程池来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cron：使用Cron表达式。　每分钟的1，2秒运行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Scheduled(cron = &quot;1-2 * * * * ? &quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportCurrentTimeWithCronExpression</span><span class="hljs-params">()</span> &#123;<br>  log.info(<span class="hljs-string">&quot;Cron Expression: The time is now &#123;&#125;&quot;</span>, dateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分布式定时任务技术选型"><a href="#分布式定时任务技术选型" class="headerlink" title="分布式定时任务技术选型"></a>分布式定时任务技术选型</h3><p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p><ul><li>任务: 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章</li><li>调度器: 其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器</li><li>执行器: 最后就是执行器，执行器接收调度器分派的任务并执行</li></ul><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>优缺点总结：</p><ul><li>优点: 可以与 Spring 集成，并且支持动态添加任务和集群。</li><li>缺点: 分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）</li></ul><h4 id="Elastic-Job"><a href="#Elastic-Job" class="headerlink" title="Elastic-Job"></a>Elastic-Job</h4><p>基于Quartz和ZooKeeper的分布式调度解决方案<br>ElasticJob 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能<br>Elastic-Job 没有调度中心这一概念，而是使用 ZooKeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。<br>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）</p><hr><h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="常见编写SQL性能建议"><a href="#常见编写SQL性能建议" class="headerlink" title="常见编写SQL性能建议"></a>常见编写SQL性能建议</h3><ul><li>充分利用表上已经存在的索引</li><li>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</li><li>禁止使用 <code>SELECT *</code> 必须使用 <code>SELECT &lt;字段列表&gt;</code> 查询<ul><li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li><li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li><li><code>SELECT *</code> 无法使用覆盖索引</li></ul></li><li>禁止使用不含字段列表的 INSERT 语句</li><li>建议使用预编译语句进行数据库操作<ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>只传参数，比传递 SQL 语句更高效</li><li>相同语句可以一次解析，多次使用，提高处理效率。</li></ul></li><li>避免使用子查询，可以把子查询优化为 join 操作</li><li>避免使用 JOIN 关联太多的表</li><li>减少同数据库的交互次数</li><li>对应同一列进行 or 判断时，使用 in 代替 or</li><li>WHERE 从句中禁止对列进行函数转换和计算</li></ul><h3 id="数据库操作规范"><a href="#数据库操作规范" class="headerlink" title="数据库操作规范"></a>数据库操作规范</h3><ul><li>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作<ul><li>大批量操作可能会造成严重的主从延迟</li><li>避免产生大事务操作</li></ul></li><li>程序连接不同的数据库使用不同的账号，禁止跨库查询<ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MyISAM</p><ul><li>非聚集索引: 索引文件与数据文件分开; <code>.MYI</code>文件存索引, <code>.MYD</code>文件存数据</li><li>底层数据结构: B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</li><li>主键: 可以没有</li><li>辅助索引(Secondary key): 结构上与主索引没有任何区别，辅助索引的 key 可以重复</li></ul><p>InnoDB</p><ul><li>聚集索引: 数据文件本身就是索引文件</li><li>底层数据结构: B+Tree 作为索引结构，叶节点的 data 域保存了完整的数据记录。索引的 key 是数据表的主键，因此InnoDB 要求表必须有主键</li><li>主键: 必须有主键。如果没有显式指定，则会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则自动为 InnoDB 表生成一个隐含字段作为主键，类型为长整形。尽量在采用自增字段做表的主键，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整</li><li>辅助索引(Secondary key): 辅助索引 data 域存储相应记录主键的值而不是地址。这使得辅助索引搜索需要检索两遍索引(回表):首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录。</li></ul><h3 id="索引-amp-优化"><a href="#索引-amp-优化" class="headerlink" title="索引 &amp; 优化"></a>索引 &amp; 优化</h3><p>mysql索引数据结构为什么选择B+Tree?</p><ul><li>二叉排序树: 无平衡机制，插入递增元素，退化成链表</li><li>红黑树(是一种二叉平衡树): 数据量大时树的深度也会很深</li><li>B Tree: 多叉，从左到右依次递增，叶子节点都在同一层</li><li>B+ Tree: 非叶子节点不存储data，叶子节点包含所有索引字段并用指针从左往右链接成链表。</li></ul><p>B+ Tree: 每个节点大小16kb限制，16kb&#x2F;每个节点大小(8字节索引元素+6字节孩子节点磁盘文件地址指针)&#x3D;1170个索引</p><ul><li>索引全部加载到内存，找到后根据磁盘文件地址进行一次磁盘I&#x2F;O读取对应的数据</li><li>只用3层的B+ Tree就支持上千万行数据的查找</li></ul><p>索引优化</p><ul><li>限制每张表上的索引数量,建议单张表索引不超过 5 个</li><li>每个 InnoDB 表必须有个主键<ul><li>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</li><li>InnoDB 是按照主键索引的顺序来组织表的</li><li>不要使用更新频繁的列作为主键</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长），主键建议使用自增 ID 值</li></ul></li><li>设置索引字段推荐<ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列、包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul></li><li>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少</li><li>尽量避免使用外键约束</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>ACID</p><ol><li>原子性(Atomicity): 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行</li><li>一致性(Consistency): 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的</li><li>隔离性(Isolation): 多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离</li><li>持久性(Durability): 表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中</li></ol><p>事务并发存在的问题</p><ol><li>脏读: 如果一个事务读取到了另一个未提交事务修改过的数据，我们就称发生了脏读现象</li><li>不可重复读: 同一个事务内，前后多次读取，读取到的数据内容不一致</li><li>幻读: 如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录(如insert、delete、update)，就意味着发生了幻读</li></ol><p>事务隔离级别</p><ul><li>READ-UNCOMMITTED(读未提交): 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读): 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化): 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code><br>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别</p><p>InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li>快照读: 由 MVCC 机制来保证不出现幻读。</li><li>当前读: 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁(Record Lock)和间隙锁(Gap Lock)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul><h3 id="MVCC-Multi-Version-Concurrency-Control-多版本并发控制"><a href="#MVCC-Multi-Version-Concurrency-Control-多版本并发控制" class="headerlink" title="MVCC(Multi-Version Concurrency Control)多版本并发控制"></a>MVCC(Multi-Version Concurrency Control)多版本并发控制</h3><p>一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。数据库隔离级别读已提交、可重复读 都是基于MVCC实现的</p><p>查询一条记录，基于MVCC，是怎样的流程</p><ol><li>获取事务自己的版本号，即事务ID</li><li>获取Read View</li><li>查询得到的数据，然后Read View中的事务版本号进行比较。</li><li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li><li>最后返回符合规则的数据</li></ol><p>InnoDB 实现MVCC，是通过 Read View + Undo Log 实现的，Undo Log 保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。</p><ul><li>Read View: <ul><li>事务执行SQL语句时，产生的读视图。实际上在innodb中，每个SQL语句执行前都会得到一个Read View</li><li>主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据</li></ul></li><li>Undo Log:<ul><li>回滚日志，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据</li><li>当delete一条记录时，undo log 中会记录一条对应的insert记录</li><li>用途: <ol><li>事务回滚时，保证原子性和一致性</li><li>用于MVCC快照读</li></ol></li></ul></li><li>快照读: 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读</li><li>当前读: 读取的是记录数据的最新版本，显式加锁的都是当前读</li></ul><p>TODO:</p><hr><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>redis单线程为什么快?</p><ol><li>纯内存操作: 数据存放在内存中，内存的响应时间大约是100纳秒</li><li>单线程: Redis是基于内存的操作，CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，同时避免了线程切换和竞态产生的消耗 </li><li>非阻塞I&#x2F;O: Redis采用epoll做为I&#x2F;O多路复用技术的实现 ，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I&#x2F;O上浪费过多的时间</li><li>全局哈希表: </li><li>客户端调服务端:</li><li>发送命令</li><li>执行命令: 每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题</li><li>返回结果</li></ol><p>Redis数据结构底层实现</p><ul><li>String: Simple dynamic string(SDS)<ul><li><code>buf[]</code>字节数组，用于保存字符串, <code>len</code>保存字符串的长度, <code>free</code>buf 数组中未使用字节的数量</li><li>优点: 不用担心字符串变更造成的内存溢出问题</li></ul></li><li>链表: 双向链表上扩展了头、尾节点、元素数等属性<ul><li>优点: 可以直接获得头、尾节点</li></ul></li><li>字典(Hash): 数组+链表的基础上，进行了一些rehash优化<ul><li>采用链地址法来处理冲突，然后它没有使用红黑树优化</li><li>哈希表节点采用单链表结构</li><li>rehash优化: 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子(load factor)维持在一个合理的范围之内， 程序需要对哈希表的大小进行相应的扩展或者收缩</li></ul></li><li>有序集合:<ul><li>底层实现为跳跃表: 跳表其实就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了</li></ul></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li>使用<code>setnx</code>命令(SET if Not eXists)实现: 在Redis中，<code>setnx</code>命令的作用是，如果key不存在，则设置key-value并返回true，如果key存在，则不做任何操作并返回false; 利用这一机制在获取锁为设置key，设置成功返回true表示获取到锁了，执行完业务逻辑之后删除掉设置的key即可</li><li>可以在使用<code>setnx</code>命令的同时设置超时时间，假设值key的那个服务器挂了，没有删除key，那么key会在超时后自动删除以释放锁</li><li>生产案例: 钻石突击队抢单，使用<code>setnx</code>实现分布式锁，锁机构库update，抢到保单的线程抢锁来update机构库对应保单数据的督导工号。没有设置过期时间，一个微服务实例在运行完<code>setnx db-update superId</code>之后没有运行<code>del key</code>来删除key，即设置了锁之后挂了，没有释放锁，导致一个机构库的update被锁住，无法抢单。那么为什么要设置key过期时间呢？如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在（redis不设置key的过期时间，默认是永久的），以至于一直处于加锁状态。</li></ul><p>epoll: linux内核下的一个高效的处理大批量的文件操作符的一个实现</p><h3 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h3><ul><li>缓存雪崩: 缓存同一时间大面积失效，后面的请求都会落到数据库上，造成数据库短时间内无法承受大量请求而崩溃<ul><li>解决方案: <ul><li>每个key的失效时间加个随机值，避免同一时间大量的key失效</li><li>集群部署，可以将热点数据分布到各个不同的库</li></ul></li></ul></li><li>缓存穿透: 大量请求的key不存在于缓存中，例如某个黑客制造缓存中不存在的key发起大量请求，导致大量请求落到数据库<ul><li>解决方案:<ul><li>入参校验，将不合法的参数直接拦截</li><li>缓存和数据库都查不到某个key的数据，就将key写入到redis，value为null，并设置过期时间，避免下次请求落到数据库上</li><li>布隆过滤器: 布隆过滤器可以非常方便的判定一个给定的数据是否存在与海量数据中.可以将所有可能存在的请求的值存到布隆过滤器，当请求过来先判断用户发来的请求是否存在于布隆过滤器，不存在就直接拦截</li></ul></li></ul></li><li>缓存击穿: 一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key失效瞬间，持续的大并发就穿破缓存，直接请求到数据库<ul><li>解决方案:<ul><li>定时任务主动刷新缓存设计</li><li>jvm缓存+redis缓存的多级缓存: 两个缓存同时失效概率低，JVM缓存时间设随机值,比如 10秒~30秒</li><li>利用redis实现的分布式锁setnx 来实现互斥的数据库操作: 如果缓存中没有则拿到锁的去查数据库<ol><li>如果缓存没有,则尝试获取分布式锁(有超时设置)</li><li>如果没有拿到锁,则阻塞当前线程,n秒,之后再次尝试获取分布式锁(自旋)</li><li>拿到锁之后检查数据是否已经被其他线程放到redis缓存中,如果redis缓存已有,直接返回redis中的数据,释放分布式锁</li><li>如果缓存没有被刷新,则查数据库</li><li>将数据库查询的结果保存到redis缓存中</li><li>返回查询结果</li></ol></li></ul></li></ul></li></ul><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 布鲁尔定理（Brewer’s theorem）</p><p>CAP: 分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构</p><ol><li>Consistency(一致性): 所有节点访问同一份最新的数据副本</li><li>Availability(可用性): 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</li><li>Partition Tolerance(分区容错性): 分布式系统出现网络分区的时候，仍然能够对外提供服务</li></ol><ul><li><p>网络分区: 分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 网络分区</p></li><li><p>ZooKeeper 保证的是 CP。 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</p></li><li><p>Eureka 保证的则是 AP。 Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</p></li><li><p>Nacos 不仅支持 CP 也支持 AP。</p></li></ul><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。</p><p>BASE: BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求</p><ol><li>Basically Available(基本可用): 分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用</li></ol><ul><li>损失部分可用性: 1.响应时间上的损失; 2.系统功能上的损失(eg:系统的部分非核心功能无法使用)</li></ul><ol start="2"><li>Soft-state(软状态): 软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li><li>Eventually Consistent(最终一致性): 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</li></ol><p>分布式一致性的 3 种级别: </p><ol><li>强一致性: 系统写入了什么，读出来的就是什么</li><li>弱一致性: 不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态</li><li>最终一致性: 弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态</li></ol><p>实现最终一致性的具体方式:</p><ul><li>读时修复: 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据</li><li>写时修复: 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性</li><li>异步修复: 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复</li></ul><p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充:<br>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。<br>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>如果是要求强一致性，那就不能使用缓存，因为保证不了强一致性，只能保证最终一致性<br>TODO:</p><h2 id="SpringCloud-Eureka"><a href="#SpringCloud-Eureka" class="headerlink" title="SpringCloud-Eureka"></a>SpringCloud-Eureka</h2><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li>Partition: topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。</li></ul><p>消息传递模式</p><ul><li>点对点传递模式: 消息持久化到一个队列中，一个或多个消费者消费队列中的数据，一条消息只能被消费一次</li><li>发布-订阅模式: 消息被持久化到一个topic中，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除</li></ul><p>RocketMQ与Kafka的区别</p><ol><li>rocketMQ的NameServer和kafka的zookeeper对比</li></ol><ul><li>kafka具备选举功能: Master&#x2F;Slave的选举，有2步<ol><li>先通过ZK在所有机器中，选举出一个KafkaController</li><li>再由这个Controller，决定每个partition的Master是谁，Slave是谁</li></ol></li><li>因为有了选举功能，所以kafka某个partition的master挂了，该partition对应的某个slave会升级为主对外提供服务</li><li>rocketMQ不具备选举，Master&#x2F;Slave的角色也是固定的。当一个Master挂了之后，你可以写到其他Master上，但不能让一个Slave切换成Master</li><li>rocketMq的所有broker节点的角色都是一样，上面分配的topic和对应的queue的数量也是一样的，Mq只能保证当一个broker挂了，把原本写到这个broker的请求迁移到其他broker上面</li></ul><ol start="2"><li>kafka为什么比RocketMQ有更大的吞吐量</li></ol><ul><li>kafka在消息存储过程中会根据topic和partition的数量创建物理文件，也就是说我们创建一个topic并指定了3个partition，那么就会有3个物理文件目录，也就说说partition的数量和对应的物理文件是一一对应的</li><li>RocketMQ在消息存储方式是采用commitLog，RocketMQ的queue的数量其实是在consumeQueue里面体现的，在真正存储消息的commitLog其实就只有一个物理文件</li><li>kafka的多文件并发写入 VS RocketMQ的单文件写入，性能差异kafka完胜可想而知</li><li>kafka的大量文件存储会导致一个问题，也就说在partition特别多的时候，磁盘的访问会发生很大的瓶颈，毕竟单个文件看着是append操作，但是多个文件之间必然会导致磁盘的寻道</li></ul><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>组成:</p><ol><li>Name Server: 名称服务充当路由消息的提供者，可集群部署，节点之间无任何信息同步，提供命名服务，更新和发现 Broker 服务</li><li>Producer(生产者): </li><li>Broker: 消息中转角色，负责存储消息，转发消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker</li><li>Consumer(消费者):</li></ol><ul><li>Topic: 表示消息的第一级类型，一条消息必须有一个Topic</li><li>Queue: Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元</li><li>tags: Tags是Topic下的次级消息类型&#x2F;二级类型，可以在同一个Topic下基于Tags进行消息过滤。Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况</li><li>commitLog: 用于存储消息的文件。顺序写入，随机读写。消息只要被写入 commitlog 那么该消息就不会丢失。</li><li>ConsumeQueue: ConsumeQueue中并不需要存储消息的内容，而存储的是消息在CommitLog中的offset。通过broker保存的offset可以在ConsumeQueue中获取消息，从而快速的定位到commitLog的消息位置</li></ul><p>集群: 推荐多主多从</p><ul><li><p>多个master节点多个slave节点，一个master节点配一个slave节点，slave是master节点的备份</p></li><li><p>slave节点不接受生产者的消息，生产者的消息发给master节点</p></li><li><p>消费者一般从master节点消费消息</p></li><li><p>若master节点宕机，则消费者从对应的slave节点消费消息，注意：这里slave即使master宕机也不会升级，依然是slave节点</p></li><li><p>同步复制: 生产者发送同步消息需主节点和从节点都写入文件或内存(异步刷盘是内存，一般选择异步刷盘)之后才会返回确认信息给生产者</p></li><li><p>异步刷盘(高性能): 注意这里因为消息同时存在于主节点和从节点所以这里可以采用异步刷盘，丢失的概率不大</p></li><li><p>Topic: 表示消息的第一级类型，一条消息必须有一个Topic</p></li><li><p>Queue: Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元</p></li><li><p>tags: Tags是Topic下的次级消息类型&#x2F;二级类型，可以在同一个Topic下基于Tags进行消息过滤。Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况</p></li><li><p>commitLog: 用于存储消息的文件。顺序写入，随机读写。消息只要被写入 commitLog 那么该消息就不会丢失。</p></li><li><p>ConsumeQueue: ConsumeQueue中并不需要存储消息的内容，而存储的是消息在CommitLog中的offset。通过broker保存的offset可以在ConsumeQueue中获取消息，从而快速的定位到commitLog的消息位置</p></li></ul><p>消息类型</p><ul><li>同步消息: 消息发送方发出数据后，生产者会阻塞直到MQ服务方发回响应消息，表示已经写入数据到queue里了</li><li>异步消息: MQ 的异步发送，需要用户实现异步发送回调接口(SendCallback)，在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应</li><li>单向(one-way)消息: 只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别</li></ul><p>消息丢失分析:</p><ul><li>生产者发送时丢失: 同步复制+重试</li><li>RocketMQ自身丢失: 主从架构+持久化</li><li>消费者消费消息丢失: 重试+死信队列</li></ul><p>消息重复消费问题:</p><ul><li>MVCC(Multi-Version Concurrency Control多版本并发控制): 生产者发送到queue的消息需要带上这个版本号，消费者在执行业务逻辑的同时带上版本号，sql的update语句的where带上version号保证语句的幂等性。<ul><li>缺点: 这意味着生产者在发送消息之前就需要查表拿到最新的版本号，增加了生产者和消费者的耦合度</li></ul></li><li>去重表方案: 每个消息带唯一id，然后消费者维护消息表，id设成唯一，消费消息的同时insert这张表，如果抛异常就把异常吃了直接返回，后续业务逻辑不继续进行了</li></ul><p>顺序消息消费问题:</p><ol><li>一个topic对应一个queue，这样需要顺序消费的消息就在同一条queue里</li><li>重试参数改成0</li></ol><hr><h1 id="Spring-amp-SpringBoot"><a href="#Spring-amp-SpringBoot" class="headerlink" title="Spring &amp; SpringBoot"></a>Spring &amp; SpringBoot</h1><p>Spring Framework 它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发<br>Spring 提供的核心功能主要是 IoC 和 AOP</p><p>Core Container: Spring 框架的核心模块，主要提供 IoC 依赖注入功能的支持</p><ul><li>spring-core: Spring 框架基本的核心工具类</li><li>spring-beans: 提供对 bean 的创建、配置和管理等功能的支持</li><li>spring-context: 提供对国际化、事件传播、资源加载等功能的支持</li><li>spring-expression: 提供对表达式语言(Spring Expression Language)SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用</li></ul><h3 id="IoC-Inversion-of-Control-控制反转"><a href="#IoC-Inversion-of-Control-控制反转" class="headerlink" title="IoC(Inversion of Control:控制反转)"></a>IoC(Inversion of Control:控制反转)</h3><p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p><ul><li>控制: 指的是对象创建(实例化、管理)的权力</li><li>反转: 控制权交给外部环境(Spring 框架、IoC 容器)</li></ul><p>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map(key，value)，Map 中存放的是各种对象</p><p>Spring Bean: 代指的就是那些被 IoC 容器所管理的对象<br><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础</p><p>将一个类声明为 Bean 的注解</p><ul><li><code>@Component</code>: 通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注</li><li><code>@Repository</code>: 对应持久层即 Dao 层，主要用于数据库相关操作</li><li><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code>: 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</li></ul><p><code>@Component</code> 和 <code>@Bean</code> 的区别</p><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</li><li><code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 <code>@Bean</code>来实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入 Bean 的注解<br>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean</p><ul><li><code>@Autowired</code>: <code>org.springframework.bean.factory</code></li><li><code>@Resource</code>: <code>javax.annotation</code></li><li><code>@Inject</code>: <code>javax.inject</code></li></ul><p><code>@Autowired</code> 和 <code>@Resource</code> 的区别</p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），<code>@Resource</code>默认注入方式为 byName（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 name 属性来显式指定名称</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul><li>spring-aspects: 该模块为与 AspectJ 的集成提供支持。</li><li>spring-aop: 提供了面向切面的编程实现。</li><li>spring-instrument: 提供了为 JVM 添加代理(agent)的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样，这个模块的使用场景非常有限</li></ul><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理</p><p>Spring AOP 和 AspectJ AOP 有什么区别</p><ul><li>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</li><li>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)</li></ul><p>AOP常见术语</p><ul><li>目标(Target): 被通知的对象</li><li>代理(Proxy): 向目标对象应用通知之后创建的代理对象</li><li>连接点(JoinPoint): 目标对象的所属类中，定义的所有方法均为连接点</li><li>切入点(Pointcut): 被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</li><li>通知(Advice): 增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</li><li>切面(Aspect): 切入点(Pointcut)+通知(Advice)</li><li>Weaving(织入): 将通知应用到目标对象，进而生成代理对象的过程动作</li></ul><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码<br>Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)</p><p>Spring MVC 的核心组件</p><ul><li><code>DispatcherServlet</code>: 核心的中央处理器，负责接收请求、分发，并给予客户端响应。</li><li><code>HandlerMapping</code>: 处理器映射器，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li><code>HandlerAdapter</code>: 处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li><code>Handler</code>: 请求处理器，处理实际请求的处理器。</li><li><code>ViewResolver</code>: 视图解析器，根据 Handler 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端</li></ul><h3 id="Data-Access-x2F-Integration"><a href="#Data-Access-x2F-Integration" class="headerlink" title="Data Access&#x2F;Integration"></a>Data Access&#x2F;Integration</h3><ul><li>spring-jdbc: 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li>spring-tx: 提供对事务的支持。</li><li>spring-orm: 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li>spring-oxm: 提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li>spring-jms: 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承</li></ul><h3 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h3><ul><li>spring-web: 对 Web 功能的实现提供一些最基础的支持。</li><li>spring-webmvc: 提供对 Spring MVC 的实现。</li><li>spring-websocket: 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li>spring-webflux: 提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步</li></ul><h3 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h3><p>Spring 团队提倡测试驱动开发(TDD)。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit(单元测试框架)、TestNG(类似 JUnit)、Mockito(主要用来 Mock 对象)、PowerMock(解决 Mockito 的问题比如无法模拟 final, static， private 方法)等等常用的测试框架支持的都比较好</p><h3 id="Spring-框架中用到了哪些设计模式"><a href="#Spring-框架中用到了哪些设计模式" class="headerlink" title="Spring 框架中用到了哪些设计模式"></a>Spring 框架中用到了哪些设计模式</h3><ul><li>工厂设计模式: Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li>代理设计模式: Spring AOP 功能的实现。</li><li>单例设计模式: Spring 中的 Bean 默认都是单例的。</li><li>模板方法模式: Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>包装器设计模式: 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源</li><li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>适配器模式: Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller</li></ul><h3 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h3><ul><li>编程式事务: 在代码中硬编码(不推荐使用): 通过 TransactionTemplate或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>声明式事务: 在 XML 配置文件中配置或者直接基于注解（推荐使用）: 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ul><p>事务传播行为</p><ol><li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>: 使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</li><li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>: 创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰</li><li><code>TransactionDefinition.PROPAGATION_NESTED</code>: 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code></li><li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>: 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常(mandatory强制性,使用的很少)</li></ol><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚</p><ol><li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</li><li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起</li><li><code>TransactionDefinition.PROPAGATION_NEVER</code>: 以非事务方式运行，如果当前存在事务，则抛出异常</li></ol><p>事务中的隔离级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Isolation</span> &#123;<br>    <span class="hljs-comment">// 使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别</span><br>    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),<br>    <span class="hljs-comment">// 低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</span><br>    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),<br>    <span class="hljs-comment">// 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</span><br>    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),<br>    <span class="hljs-comment">// 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</span><br>    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),<br>    <span class="hljs-comment">// 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别</span><br>    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br><br>    Isolation(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Transactional(rollbackFor = Exception.class)</code>注解<br>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚<br>在 <code>@Transactional</code> 注解中如果不配置rollbackFor属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚</p><h3 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h3><p>实体之间的关联关系注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@OneToOne</span> <span class="hljs-comment">// 一对一。</span><br><span class="hljs-meta">@ManyToMany</span> <span class="hljs-comment">// 多对多。</span><br><span class="hljs-meta">@OneToMany</span> <span class="hljs-comment">// 一对多。</span><br><span class="hljs-meta">@ManyToOne</span> <span class="hljs-comment">// 多对一</span><br></code></pre></td></tr></table></figure><p>在数据库中非持久化一个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String transient1; <span class="hljs-comment">// not persistent because of static</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">transient2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Satish&quot;</span>; <span class="hljs-comment">// not persistent because of final</span><br><span class="hljs-keyword">transient</span> String transient3; <span class="hljs-comment">// not persistent because of transient</span><br><span class="hljs-meta">@Transient</span><br>String transient4; <span class="hljs-comment">// not persistent because of @Transient</span><br></code></pre></td></tr></table></figure><p>JPA 的审计功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@MappedSuperclass</span><br><span class="hljs-meta">@EntityListeners(value = AuditingEntityListener.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAuditBase</span> &#123;<br><br>    <span class="hljs-meta">@CreatedDate</span> <span class="hljs-comment">// 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</span><br>    <span class="hljs-meta">@Column(updatable = false)</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> Instant createdAt;<br><br>    <span class="hljs-meta">@LastModifiedDate</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> Instant updatedAt;<br><br>    <span class="hljs-meta">@CreatedBy</span> <span class="hljs-comment">// 表示该字段为创建人，在这个实体被 insert 的时候，会设置值</span><br>    <span class="hljs-meta">@Column(updatable = false)</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> String createdBy;<br><br>    <span class="hljs-meta">@LastModifiedBy</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> String updatedBy;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>Spring Security 重要的是实战</p><p>加密算法工具类<br>这些加密算法实现类的父类是 PasswordEncoder ，如果你想要自己实现一个加密算法的话，也需要继承 PasswordEncoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PasswordEncoder</span> &#123;<br>    <span class="hljs-comment">// 加密也就是对原始密码进行编码</span><br>    String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence var1)</span>;<br>    <span class="hljs-comment">// 比对原始密码和数据库中保存的密码</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence var1, String var2)</span>;<br>    <span class="hljs-comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>批量更换系统使用的加密算法<br>推荐的做法是通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密方案，以适应不同的业务需求<br>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的</p><h3 id="Spring-启动原理"><a href="#Spring-启动原理" class="headerlink" title="Spring 启动原理"></a>Spring 启动原理</h3><h3 id="SpringBoot-自动装配原理"><a href="#SpringBoot-自动装配原理" class="headerlink" title="SpringBoot 自动装配原理"></a>SpringBoot 自动装配原理</h3><p>通过 Spring Boot 的全局配置文件 <code>application.properties</code>或<code>application.yml</code>即可对项目进行设置比如更换端口号，配置 JPA 属性等等<br>Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot 的核心注解 SpringBootApplication:<br><code>@SpringBootApplication</code> &#x3D; <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code></p><ul><li><code>@EnableAutoConfiguration</code>： 启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>： 允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。容器中将排除TypeExcludeFilter和AutoConfigurationExcludeFilter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@ComponentScan</span> <span class="hljs-comment">// 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类</span><br><span class="hljs-meta">@EnableAutoConfiguration</span> <span class="hljs-comment">// 启用 SpringBoot 的自动配置机制</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br><br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//实际上它也是一个配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>@EnableAutoConfiguration</code>: 实现自动装配的核心注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">//作用：将main包下的所有组件注册到容器中</span><br><span class="hljs-comment">// 自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="hljs-comment">//加载自动装配类 xxxAutoconfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>AutoConfigurationImportSelector: 加载自动装配类<br>继承关系如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-comment">// 该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</span><br>    String[] selectImports(AnnotationMetadata var1);<br>&#125;<br></code></pre></td></tr></table></figure><p>selectImports方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NO_IMPORTS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-comment">// &lt;1&gt;.判断自动装配开关是否打开</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> NO_IMPORTS;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//&lt;2&gt;.获取所有需要装配的bean</span><br>            <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br>            <span class="hljs-comment">// getAutoConfigurationEntry主要负责加载自动配置类的</span><br>            AutoConfigurationImportSelector.<span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>            <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>getAutoConfigurationEntry()</code>的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">EMPTY_ENTRY</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>();<br><br>AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;<br>        <span class="hljs-comment">//&lt;1&gt;. isEnabled: 判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//&lt;2&gt;. 用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName</span><br>            <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAttributes(annotationMetadata);<br>            <span class="hljs-comment">//&lt;3&gt;. 获取需要自动装配的所有配置类，读取spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</span><br>            <span class="hljs-comment">// 一般名称为XXXAutoConfiguration的作用就是按需加载组件</span><br>            <span class="hljs-comment">// 不光是这个依赖下的META-INF/spring.factories被读取到，所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到</span><br>            <span class="hljs-comment">// eg: druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件</span><br>            List&lt;String&gt; configurations = <span class="hljs-built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>            <span class="hljs-comment">//&lt;4&gt;. 筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效</span><br>            configurations = <span class="hljs-built_in">this</span>.removeDuplicates(configurations);<br>            Set&lt;String&gt; exclusions = <span class="hljs-built_in">this</span>.getExclusions(annotationMetadata, attributes);<br>            <span class="hljs-built_in">this</span>.checkExcludedClasses(configurations, exclusions);<br>            configurations.removeAll(exclusions);<br>            configurations = <span class="hljs-built_in">this</span>.filter(configurations, autoConfigurationMetadata);<br>            <span class="hljs-built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><br><span class="hljs-comment">// 存在才会加载</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RabbitProperties.class)</span><br><span class="hljs-meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitAutoConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="autoconfig原理"><a href="#autoconfig原理" class="headerlink" title="autoconfig原理"></a>autoconfig原理</h3><h3 id="Autowired实现原理"><a href="#Autowired实现原理" class="headerlink" title="@Autowired实现原理"></a><code>@Autowired</code>实现原理</h3><h3 id="SpringBoot-注解字典"><a href="#SpringBoot-注解字典" class="headerlink" title="SpringBoot 注解字典"></a>SpringBoot 注解字典</h3><p><code>@SpringBootApplication</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> <span class="hljs-comment">// 创建 SpringBoot 项目之后会默认在主类加上</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringSecurityJwtGuideApplication</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[] args)</span> &#123;<br>        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.boot.autoconfigure;<br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span> <span class="hljs-comment">// 启用 SpringBoot 的自动配置机制</span><br><span class="hljs-comment">// 扫描被@Component (@Repository,@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>   ......<br>&#125;<br><br><span class="hljs-keyword">package</span> org.springframework.boot;<br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Autowired</code>: 自动导入对象到类中，被注入进的类同样要被 Spring 容器管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>  <span class="hljs-comment">//......</span><br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserService userService;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>: </p><ul><li><code>@Component</code>: 通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li><li><code>@Repository</code>: 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code>: 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><p><code>@RestController</code>: <code>@Controller</code>+<code>@ResponseBody</code>, 表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> + <code>@ResponseBody</code> 返回 JSON 或 XML 形式数据</p><p><code>@Scope</code>: 声明 Spring Bean 的作用域<br>四种常见的 Spring Bean 的作用域：</p><ol><li>singleton: 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype: 每次请求都会创建一个新的 bean 实例。</li><li>request: 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session: 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personSingleton</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><code>@Configuration</code>: 一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><ul><li><code>@PathVariable</code>: 用于获取路径参数</li><li><code>@RequestParam</code>: 用于获取查询参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title function_">getKlassRelatedTeachers</span><span class="hljs-params">(</span><br><span class="hljs-params">         <span class="hljs-meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span><br><span class="hljs-params">         <span class="hljs-meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> &#123;<br>    <span class="hljs-comment">// 前端调/klasses/123456/teachers?type=web</span><br>    <span class="hljs-comment">// klassId=123456,type=web</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>@RequestBody</code>: 用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<code>Content-Type</code> 为 <code>application/json</code> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign-up&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title function_">signUp</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> &#123;<br>  userService.save(userRegisterRequest);<br>  <span class="hljs-keyword">return</span> ResponseEntity.ok().build();<br>&#125;<br></code></pre></td></tr></table></figure><p>UserRegisterRequest对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRegisterRequest</span> &#123;<br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-keyword">private</span> String fullName;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;userName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;coder&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;fullName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;shuangkou&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>后端就可以直接把 json 格式的数据映射到我们的 UserRegisterRequest 类上。一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code></p><h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><p>数据源<code>application.yml</code>内容如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">test2020:</span> <span class="hljs-number">2020</span><span class="hljs-string">年</span><br><br><span class="hljs-attr">my-profile:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">David</span><br>  <span class="hljs-attr">email:</span> <span class="hljs-string">nobodynowhere@163.com</span><br><br><span class="hljs-attr">library:</span><br>  <span class="hljs-attr">location:</span> <span class="hljs-string">中国</span><br>  <span class="hljs-attr">books:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">天才基本法</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">时间的秩序</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">了不起的我</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="hljs-string">如何走出人生的艰难时刻？</span><br></code></pre></td></tr></table></figure><p><code>@Value</code>(常用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span><br>String wuhan2020;<br></code></pre></td></tr></table></figure><p><code>@ConfigurationProperties</code>(常用): 读取配置信息并与 bean 绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibraryProperties</span> &#123;<br>    <span class="hljs-meta">@NotEmpty</span><br>    <span class="hljs-keyword">private</span> String location;<br>    <span class="hljs-keyword">private</span> List&lt;Book&gt; books;<br><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@ToString</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>        String name;<br>        String description;<br>    &#125;<br>  <span class="hljs-comment">//省略getter/setter</span><br>  <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>@PropertySource(不常用): 读取指定 properties 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:website.properties&quot;)</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSite</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br><br>  <span class="hljs-comment">//省略getter/setter</span><br>  <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>JSR(Java Specification Requests) 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面<br>SpringBoot 项目的 <code>spring-boot-starter-web</code> 依赖中已经有 <code>hibernate-validator</code> 包，不需要引用相关依赖<br>更新版本的 <code>spring-boot-starter-web</code> 依赖中不再有 <code>hibernate-validator</code> 包（如2.3.11.RELEASE），需要自己引入 <code>spring-boot-starter-validation</code> 依赖<br>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></p><p>常用的字段验证的注解</p><ul><li>@NotEmpty 被注释的字符串的不能为 null 也不能为空</li><li>@NotBlank 被注释的字符串非 null，并且必须包含一个非空白字符</li><li>@Null 被注释的元素必须为 null</li><li>@NotNull 被注释的元素必须不为 null</li><li>@AssertTrue 被注释的元素必须为 true</li><li>@AssertFalse 被注释的元素必须为 false</li><li>@Pattern(regex&#x3D;,flag&#x3D;)被注释的元素必须符合指定的正则表达式</li><li>@Email 被注释的元素必须是 Email 格式。</li><li>@Min(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value)被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max&#x3D;, min&#x3D;)被注释的元素的大小必须在指定的范围内</li><li>@Digits(integer, fraction)被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past被注释的元素必须是一个过去的日期</li><li>@Future 被注释的元素必须是一个将来的日期</li></ul><p>验证请求体(RequestBody)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-meta">@NotNull(message = &quot;classId 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String classId;<br><br>    <span class="hljs-meta">@Size(max = 33)</span><br>    <span class="hljs-meta">@NotNull(message = &quot;name 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)</span><br>    <span class="hljs-meta">@NotNull(message = &quot;sex 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-meta">@Email(message = &quot;email 格式不正确&quot;)</span><br>    <span class="hljs-meta">@NotNull(message = &quot;email 不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String email;<br><br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;<br>    <span class="hljs-comment">// 需要验证的参数上加上了@Valid注解，如果验证失败，它将抛出MethodArgumentNotValidException</span><br>    <span class="hljs-meta">@PostMapping(&quot;/person&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;Person&gt; <span class="hljs-title function_">getPerson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> Person person)</span> &#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok().body(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证请求参数(Path Variables 和 Request Parameters)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-meta">@Validated</span> <span class="hljs-comment">// 这个参数可以告诉 Spring 去校验方法参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="hljs-title function_">getPersonByID</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> &#123;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok().body(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全局处理-Controller-层异常"><a href="#全局处理-Controller-层异常" class="headerlink" title="全局处理 Controller 层异常"></a>全局处理 Controller 层异常</h3><ul><li><code>@ControllerAdvice</code>: 注解定义全局异常处理类</li><li><code>@ExceptionHandler</code>: 注解声明异常处理方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求参数异常处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;<br>       <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JPA-相关"><a href="#JPA-相关" class="headerlink" title="JPA 相关"></a>JPA 相关</h3><p>暂时跳过，现在多使用MyBatis，很少用Bean和表结构对应的强结构的设计</p><h3 id="Json-数据处理"><a href="#Json-数据处理" class="headerlink" title="Json 数据处理"></a>Json 数据处理</h3><p><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成json时将userRoles属性过滤</span><br><span class="hljs-meta">@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String fullName;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String fullName;<br>    <span class="hljs-keyword">private</span> String password;<br>   <span class="hljs-comment">//生成json时将userRoles属性过滤</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>格式化 json 数据: <code>@JsonForma</code>t一般用来格式化 json 数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, timezone=&quot;GMT&quot;)</span><br><span class="hljs-keyword">private</span> Date date;<br></code></pre></td></tr></table></figure><p>扁平化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> Location location;<br>    <span class="hljs-keyword">private</span> PersonInfo personInfo;<br><br>  <span class="hljs-meta">@Getter</span><br>  <span class="hljs-meta">@Setter</span><br>  <span class="hljs-meta">@ToString</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Location</span> &#123;<br>     <span class="hljs-keyword">private</span> String provinceName;<br>     <span class="hljs-keyword">private</span> String countyName;<br>  &#125;<br>  <span class="hljs-meta">@Getter</span><br>  <span class="hljs-meta">@Setter</span><br>  <span class="hljs-meta">@ToString</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String fullName;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>未扁平化之前</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;provinceName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;湖北&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;countyName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;武汉&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;personInfo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;userName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;coder1234&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;fullName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shaungkou&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>使用@JsonUnwrapped 扁平对象之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-meta">@JsonUnwrapped</span><br>    <span class="hljs-keyword">private</span> Location location;<br>    <span class="hljs-meta">@JsonUnwrapped</span><br>    <span class="hljs-keyword">private</span> PersonInfo personInfo;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;provinceName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;湖北&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;countyName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;武汉&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;userName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;coder1234&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;fullName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shaungkou&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span><br><span class="hljs-meta">@ActiveProfiles(&quot;test&quot;)</span> <span class="hljs-comment">// 一般作用于测试类上， 用于声明生效的 Spring 配置文件</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBase</span> &#123;<br>  <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <span class="hljs-comment">//声明一个方法为测试方法</span><br><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">//被声明的测试方法的数据会回滚，避免污染测试数据</span><br><span class="hljs-meta">@WithMockUser(username = &quot;user-id-18163138155&quot;, authorities = &quot;ROLE_TEACHER&quot;)</span> <span class="hljs-comment">//Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">should_import_student_success</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h2><p>远程过程调用: RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单</p><ul><li>客户端(服务消费端): 调用远程方法的一端。</li><li>客户端 Stub(桩): 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li>网络传输: 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty(推荐)。</li><li>服务端 Stub(桩): 这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li>服务端(服务提供端): 提供远程方法的一端。</li></ul><ol><li>服务消费端(client)以本地调用的方式调用远程服务；</li><li>客户端 Stub(client stub) 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体(序列化)：RpcRequest；</li><li>客户端 Stub(client stub) 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub(桩)收到消息将消息反序列化为Java对象: RpcRequest；</li><li>服务端 Stub(桩)根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub(桩)得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse(序列化)发送至消费方；</li><li>客户端 Stub(client stub)接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。over!</li></ol><h2 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h2><h2 id="配置中心-amp-bus"><a href="#配置中心-amp-bus" class="headerlink" title="配置中心 &amp; bus"></a>配置中心 &amp; bus</h2><h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><ul><li>假设你需要对文件进行缓存，你有缓存集群，对每个文件根据哈希对服务器数量取模，将每一张文件映射到一台缓存服务器上面。缺点: 如果你要增加一台服务器，那么需要对所有的文件都重新计算一遍，这样就会导致缓存雪崩，全部缓存到文件失效</li><li>为解决这个问题可以采用一致性哈希算法: 将服务器映射到一个环上面，然后根据哈希值取模，将文件映射到环上某个位置，然后这个文件存储的服务器就是映射位置顺时针遇到的第一个服务器，这样如果增加一台服务器也只会使得环上的一部分文件缓存失效，避免了缓存雪崩</li><li>缺点: 有时候可能会出现缓存不均匀的情况，即服务器映射到环上的位置是不均匀的，可以通过增加虚拟节点解决，文件顺时针遇到虚拟节点就放到虚拟节点对应的那个真实节点对应的服务器上</li></ul><h2 id="常用高并发相关工具"><a href="#常用高并发相关工具" class="headerlink" title="常用高并发相关工具"></a>常用高并发相关工具</h2><p>Apache JMeter</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h2><h3 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h3><p>固定窗口其实就是时间窗口。固定窗口计数器算法 规定了我们单位时间处理的请求数量</p><ul><li>给定一个变量 counter 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li><li>1 分钟之内每处理一个请求之后就将 counter+1 ，当 counter&#x3D;33 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li><li>等到 1 分钟结束后，将 counter 重置 0，重新开始计数</li></ul><p>缺点: 这种限流算法无法保证限流速率，因而无法保证突然激增的流量<br>就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了</p><h3 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h3><p>固定窗口计数器算法的升级版，优化点：把时间以一定比例分片<br>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)&#x2F;60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。<br>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰&#x2F;限流的思想是一样的）</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法也比较简单。和漏桶算法算法一样，还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了</p><h2 id="单机限流"><a href="#单机限流" class="headerlink" title="单机限流"></a>单机限流</h2><p>Google Guava 自带的限流工具类 RateLimiter 。 RateLimiter 基于令牌桶算法，可以应对突发流量</p><h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><ol><li>借助中间件架限流 ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li><li>网关层限流 ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件&#x2F;框架。就比如 Spring Cloud Gateway 的分布式限流实现RedisRateLimiter就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流</li></ol><p>为什么建议 Redis+Lua 的方式</p><ul><li>减少了网络开销: 我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</li><li>原子性: 一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰</li></ul><h2 id="超时-amp-重试"><a href="#超时-amp-重试" class="headerlink" title="超时&amp;重试"></a>超时&amp;重试</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误</p><ul><li>连接超时(ConnectTimeout): 客户端与服务端建立连接的最长等待时间。</li><li>读取超时(ReadTimeout): 客户端和服务端已经建立连接，客户端等待服务端处理完请求的最长时间。实际项目中，我们关注比较多的还是读取超时。</li></ul><p>超时时间应该如何设置: 超时值设置太高或者太低都有风险。</p><ul><li>如果设置太高的话，会降低超时机制的有效性，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统依然可能会出现大量慢请求堆积的问题。</li><li>如果设置太低的话，就可能会导致在系统或者服务在某些处理请求速度变慢的情况下（比如请求突然增多），大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力，进而导致整个系统或者服务被拖垮的问题</li></ul><p>建议读取超时设置为 1500ms ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 1500ms 的基础上进行缩短。反之，读取超时值也可以在 1500ms 的基础上进行加长，不过，尽量还是不要超过 1500ms 。连接超时可以适当设置长一些，建议在 1000ms ~ 5000ms 之内</p><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障</p><ul><li>瞬态故障可以简单理解为某一瞬间系统偶然出现的故障，并不会持久。偶然性故障可以理解为哪些在某些情况下偶尔出现的故障，频率通常较低</li></ul><p>重试的次数如何设置: 重试的次数通常建议设为 3 次。并且，我们通常还会设置重试的间隔，比如说我们要重试 3 次的话，第 1 次请求失败后，等待 1 秒再进行重试，第 2 次请求失败后，等待 2 秒再进行重试，第 3 次请求失败后，等待 3 秒再进行重试</p><p>重试幂等: 需要注意保证同一个请求没有被多次执行</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h2><p>SSO 英文全称 Single Sign On，单点登录。SSO 是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>核心功能:</p><ul><li>单点登录</li><li>单点登出</li><li>支持跨域单点登录</li><li>支持跨域单点登出</li></ul><p>常见的 Web 框架对于 Session 的实现都是生成一个 SessionId 存储在浏览器 Cookie 中。然后将 Session 内容存储在服务器端内存中</p><ol><li>用户登录成功之后，生成 AuthToken 交给客户端保存。如果是浏览器，就保存在 Cookie 中。如果是手机 App 就保存在 App 本地缓存中</li><li>用户在浏览需要登录的页面时，客户端将 AuthToken 提交给 SSO 服务校验登录状态&#x2F;获取用户登录信息</li></ol><p>对于登录信息的存储，建议采用 Redis，使用 Redis 集群来存储登录信息，既可以保证高可用，又可以线性扩充。同时也可以让 SSO 服务满足负载均衡&#x2F;可伸缩的需求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Index&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;Database&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;li&gt;Spring &amp;amp; SpringBoot&lt;/li&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;高并发&lt;/li&gt;
&lt;li&gt;高可用&lt;/li&gt;
&lt;li&gt;其它&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java复习笔记：多线程与并发第一章</title>
    <link href="http://yoursite.com/2022/11/13/Java/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://yoursite.com/2022/11/13/Java/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2022-11-13T09:07:53.000Z</published>
    <updated>2023-03-26T08:12:23.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念回顾"><a href="#基本概念回顾" class="headerlink" title="基本概念回顾"></a>基本概念回顾</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><h4 id="进程和线程的由来"><a href="#进程和线程的由来" class="headerlink" title="进程和线程的由来"></a>进程和线程的由来</h4><ol><li>串行：早起的计算机只能执行串行任务，并且遇到用户输入的操作时便会阻塞</li><li>批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍无法并发执行</li><li>进程：进程独占内存空间，保存各自运行状态，相互不干扰且可以互相切换，为并发处理任务提供了可能</li><li>线程：共享进程的内存资源，相互间切换更便捷，支持更细粒度的任务控制，让进程内的子任务得以并发执行</li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述。进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</strong></p><p>所有与进程相关的资源都被记录在<a href="https://baike.baidu.com/item/PCB/16067368?fr=aladdin">PCB(PCB Process Control Block)</a>中。</p><p>PCB:</p><ul><li>描述信息</li><li>控制信息</li><li>资源信息<ul><li>程序段</li><li>数据段</li></ul></li><li>CPU现场</li></ul><blockquote><p>它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p></blockquote><p>进程拥有完整的<a href="https://blog.csdn.net/u014379540/article/details/52263114">虚拟内存地址空间</a>，而同一进程下的线程则共享该进程拥有的内存空间。</p><p>线程的组成：</p><ul><li>堆栈寄存器</li><li>程序计数器</li><li>TCB</li></ul><p>进程就是包括上下文切换的程序执行时间总和 &#x3D; CPU加载上下文+CPU执行+CPU保存上下文。</p><img src="进程与线程.png"><p>进程的颗粒度太大，每次都要有上下的调入，保存，调出。</p><p>假设存在进程A，其实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><p>进程A得到CPU-&gt;CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p><p>这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p><h3 id="Linux用户态和内核态转换"><a href="#Linux用户态和内核态转换" class="headerlink" title="Linux用户态和内核态转换"></a>Linux用户态和内核态转换</h3><h4 id="为什么需要转换"><a href="#为什么需要转换" class="headerlink" title="为什么需要转换"></a>为什么需要转换</h4><h4 id="内核态的多线程是如何通过轻量级线程来实现的"><a href="#内核态的多线程是如何通过轻量级线程来实现的" class="headerlink" title="内核态的多线程是如何通过轻量级线程来实现的"></a>内核态的多线程是如何通过轻量级线程来实现的</h4><h3 id="什么是系统中断"><a href="#什么是系统中断" class="headerlink" title="什么是系统中断"></a>什么是系统中断</h3><h2 id="Java中的进程和线程"><a href="#Java中的进程和线程" class="headerlink" title="Java中的进程和线程"></a>Java中的进程和线程</h2><h3 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h3><ul><li>运行一个程序会产生一个进程，进程包含至少一个线程</li><li>每个进程对应一个JVM实例，多个线程共享JVM里的堆</li><li>Java采用单线程编程模型，程序会自动创建主线程</li></ul><h3 id="Thread中的start和run方法的区别"><a href="#Thread中的start和run方法的区别" class="headerlink" title="Thread中的start和run方法的区别"></a>Thread中的<code>start</code>和<code>run</code>方法的区别</h3><p>使用<code>run</code>方法会继续使用主线程来执行重写的<code>run</code>方法里面的内容，而使用<code>start</code>方法则会开一个新线程来执行。</p><p>我们看一下start方法源码</p><blockquote><p>Thread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Causes this thread to begin execution; the Java Virtual Machine</span><br><span class="hljs-comment">     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The result is that two threads are running concurrently: the</span><br><span class="hljs-comment">     * current thread (which returns from the call to the</span><br><span class="hljs-comment">     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span><br><span class="hljs-comment">     * &lt;code&gt;run&lt;/code&gt; method).</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * It is never legal to start a thread more than once.</span><br><span class="hljs-comment">     * In particular, a thread may not be restarted once it has completed</span><br><span class="hljs-comment">     * execution.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span><br><span class="hljs-comment">     *               started.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #run()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #stop()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="hljs-comment">         * group threads created/set up by the VM. Any new functionality added</span><br><span class="hljs-comment">         * to this method in the future may have to also be added to the VM.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br>        <span class="hljs-comment">/* Notify the group that this thread is about to be started</span><br><span class="hljs-comment">         * so that it can be added to the group&#x27;s list of threads</span><br><span class="hljs-comment">         * and the group&#x27;s unstarted count can be decremented. */</span><br>        group.add(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            start0();<br>            started = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!started) &#123;<br>                    group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>                <span class="hljs-comment">/* do nothing. If start0 threw a Throwable then</span><br><span class="hljs-comment">                  it will be passed up the call stack */</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>可以看到在<code>start</code>方法里面主要是使用到了一个native的方法<code>start0()</code>，该方法调用到了外部的非Java的源码。</p><p>可以访问<a href="http://hg.openjdk.java.net/">OpenJKD</a>来查询</p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/dd10fb830ea9/src/share/native/java/lang/Thread.c">JKD8 Thread.c源码</a></p><blockquote><p>Thread.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jni.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jvm.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;java_lang_Thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THD <span class="hljs-string">&quot;Ljava/lang/Thread;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ <span class="hljs-string">&quot;Ljava/lang/Object;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STE <span class="hljs-string">&quot;Ljava/lang/StackTraceElement;&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STR <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))</span><br><br><span class="hljs-type">static</span> JNINativeMethod methods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;start0&quot;</span>,           <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_StartThread&#125;,<br>    &#123;<span class="hljs-string">&quot;stop0&quot;</span>,            <span class="hljs-string">&quot;(&quot;</span> OBJ <span class="hljs-string">&quot;)V&quot;</span>, (<span class="hljs-type">void</span> *)&amp;JVM_StopThread&#125;,<br>    &#123;<span class="hljs-string">&quot;isAlive&quot;</span>,          <span class="hljs-string">&quot;()Z&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_IsThreadAlive&#125;,<br>    &#123;<span class="hljs-string">&quot;suspend0&quot;</span>,         <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_SuspendThread&#125;,<br>    &#123;<span class="hljs-string">&quot;resume0&quot;</span>,          <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_ResumeThread&#125;,<br>    &#123;<span class="hljs-string">&quot;setPriority0&quot;</span>,     <span class="hljs-string">&quot;(I)V&quot;</span>,       (<span class="hljs-type">void</span> *)&amp;JVM_SetThreadPriority&#125;,<br>    &#123;<span class="hljs-string">&quot;yield&quot;</span>,            <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_Yield&#125;,<br>    &#123;<span class="hljs-string">&quot;sleep&quot;</span>,            <span class="hljs-string">&quot;(J)V&quot;</span>,       (<span class="hljs-type">void</span> *)&amp;JVM_Sleep&#125;,<br>    &#123;<span class="hljs-string">&quot;currentThread&quot;</span>,    <span class="hljs-string">&quot;()&quot;</span> THD,     (<span class="hljs-type">void</span> *)&amp;JVM_CurrentThread&#125;,<br>    &#123;<span class="hljs-string">&quot;countStackFrames&quot;</span>, <span class="hljs-string">&quot;()I&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_CountStackFrames&#125;,<br>    &#123;<span class="hljs-string">&quot;interrupt0&quot;</span>,       <span class="hljs-string">&quot;()V&quot;</span>,        (<span class="hljs-type">void</span> *)&amp;JVM_Interrupt&#125;,<br>    &#123;<span class="hljs-string">&quot;isInterrupted&quot;</span>,    <span class="hljs-string">&quot;(Z)Z&quot;</span>,       (<span class="hljs-type">void</span> *)&amp;JVM_IsInterrupted&#125;,<br>    &#123;<span class="hljs-string">&quot;holdsLock&quot;</span>,        <span class="hljs-string">&quot;(&quot;</span> OBJ <span class="hljs-string">&quot;)Z&quot;</span>, (<span class="hljs-type">void</span> *)&amp;JVM_HoldsLock&#125;,<br>    &#123;<span class="hljs-string">&quot;getThreads&quot;</span>,        <span class="hljs-string">&quot;()[&quot;</span> THD,   (<span class="hljs-type">void</span> *)&amp;JVM_GetAllThreads&#125;,<br>    &#123;<span class="hljs-string">&quot;dumpThreads&quot;</span>,      <span class="hljs-string">&quot;([&quot;</span> THD <span class="hljs-string">&quot;)[[&quot;</span> STE, (<span class="hljs-type">void</span> *)&amp;JVM_DumpThreads&#125;,<br>    &#123;<span class="hljs-string">&quot;setNativeName&quot;</span>,    <span class="hljs-string">&quot;(&quot;</span> STR <span class="hljs-string">&quot;)V&quot;</span>, (<span class="hljs-type">void</span> *)&amp;JVM_SetNativeThreadName&#125;,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> THD</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> OBJ</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> STE</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> STR</span><br><br>JNIEXPORT <span class="hljs-type">void</span> JNICALL<br><span class="hljs-title function_">Java_java_lang_Thread_registerNatives</span><span class="hljs-params">(JNIEnv *env, jclass cls)</span><br>&#123;<br>    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>start0</code>方法调用到了<code>JVM_StartThread</code>方法，而该方法引自<code>jvm.h</code></p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/b44df6c5942c/src/share/vm/prims/jvm.cpp">JDK8 jvm.cpp源码</a></p><p>在jvm.cpp下的<code>JVM_StartThread</code>方法里有下面这句话用于创建一个线程</p><blockquote><p>jvm.cpp</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">native_thread = new JavaThread(&amp;thread_entry, sz);<br></code></pre></td></tr></table></figure><p>搜索上面用于创建线程的方法传入的参数<code>thread_entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread_entry</span><span class="hljs-params">(JavaThread* thread, TRAPS)</span> &#123;<br>  HandleMark <span class="hljs-title function_">hm</span><span class="hljs-params">(THREAD)</span>;<br>  Handle <span class="hljs-title function_">obj</span><span class="hljs-params">(THREAD, thread-&gt;threadObj())</span>;<br>  JavaValue <span class="hljs-title function_">result</span><span class="hljs-params">(T_VOID)</span>;<br>  JavaCalls::call_virtual(&amp;result,<br>                          obj,<br>                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),<br>                          vmSymbols::run_method_name(),<br>                          vmSymbols::void_method_signature(),<br>                          THREAD);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到该方法最后会调用JVM虚拟机<code>JavaCalls::call_virtual</code>，并传入<code>run_method_name</code></p><p>综上所述：</p><ul><li>调用<code>start</code>方法会：Thread#start()-&gt;JVM_StartThread-&gt;thread_entry-&gt;Thread#run()<ul><li>在<code>thread_entry</code>时创建一个新的子线程并启动去运行Thread#run()里的方法体</li></ul></li><li>调用<code>run</code>方法会：Thread#run()<ul><li>当做一个普通的方法调用去调用Thread#run()里的方法体</li></ul></li></ul><h3 id="Thread和-Runnable是什么关系"><a href="#Thread和-Runnable是什么关系" class="headerlink" title="Thread和 Runnable是什么关系"></a>Thread和 Runnable是什么关系</h3><ul><li>Thread类实现了Runnable接口，使得run支持多线程</li><li>因为类的单一继承原则，推荐使用Runnable接口</li></ul><p>实现了Runnable接口是没有start方法的，需要把其对象作为参数去创建一个Thread对象再调用start方法启动</p><h3 id="如何给run-方法传参"><a href="#如何给run-方法传参" class="headerlink" title="如何给run()方法传参"></a>如何给<code>run()</code>方法传参</h3><ol><li>构造函数传参</li><li>成员变量传参</li><li>回调函数传参</li></ol><h3 id="处理线程的返回值"><a href="#处理线程的返回值" class="headerlink" title="处理线程的返回值"></a>处理线程的返回值</h3><ol><li>主线程等待法：让主线程循环等待直到子线程返回</li><li>使用Thread类的<code>join()</code>阻塞当前主线程以等待子线程处理完毕<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.currentThread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        value = <span class="hljs-string">&quot;data&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test);<br>        t.start();<br>        t.join();<br>        System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + cw.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>通过Callable接口实现：通过FutureTask or 线程池获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过FutureTask</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        String value=<span class="hljs-string">&quot;test&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;ready to work&quot;</span>);<br>        Thread.currentThread().sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">&quot;Task down&quot;</span>);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTaskDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        <span class="hljs-keyword">if</span>(!task.isDone())&#123;<br>            System.out.println(<span class="hljs-string">&quot;task has not finished, please wait&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 显示MyCallable里面的返回值</span><br>        System.out.println(<span class="hljs-string">&quot;task return:&quot;</span> + task.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">newPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        Future&lt;String&gt; future = newPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-keyword">if</span> (!task.isDone()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;task has not finished, please wait&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 显示MyCallable里面的返回值</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;task return:&quot;</span> + task.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            newPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a><code>sleep</code>和<code>wait</code>的区别</h3><ul><li><code>sleep</code>是Thread类的方法，<code>wait</code>是Object类中定义的方法</li><li><code>sleep</code>方法可以在任何地方使用</li><li><code>wait</code>方法只能在<code>synchronized</code>方法或<code>synchronized</code>快中使用</li><li><code>Thread.sleep</code>只会让出CPU，不会导致锁行为的改变</li><li><code>Object.wait</code>不仅会让出CPU，还会释放已经占有的同步资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitSleepDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread A is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread A get lock&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread A do wait lock&quot;</span>);<br>            lock.wait(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread A is done&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread B is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread B get lock&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B sleeping 10 ms&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B is done&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">thread A is waiting to get lock<br>thread A get lock<br>thread B is waiting to get lock<br>thread A do wait lock<br>thread B get lock<br>thread B sleeping 10 ms<br>thread B is done<br>thread A is done<br></code></pre></td></tr></table></figure><p>观察输出可发现，在A获得锁之后B开始等待锁，而A开始wait之后B就获得了锁</p><h3 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a><code>notify</code>和<code>notifyAll</code>的区别</h3><p>锁池 EntryList：假设线程A已经拥有了某对象的锁，而其它线程B、C想要调用这个对象的某个<code>synchronized</code>方法(或块)之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。</p><p>等待池 WaitSet：假设线程A调用了某个对象的<code>wait()</code>方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。</p><ul><li><code>notifyAll</code>会让所有处于等待池中的线程全部进入锁池去竞争获取锁的机会</li><li><code>notify</code>会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitSleepDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread A is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread A get lock&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread A do wait lock&quot;</span>);<br>            lock.wait();<br>            System.out.println(<span class="hljs-string">&quot;thread A is done&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread B is waiting to get lock&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread B get lock&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B sleeping 10 ms&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread B is done&quot;</span>);<br>            lock.notify(); <span class="hljs-comment">// or lock.notifyAll();</span><br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationDemo</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (go == <span class="hljs-literal">false</span>) &#123;<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is going to notify all or one thread waiting on&quot;</span>);<br>      go = <span class="hljs-literal">true</span>;<br>      notify();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldGo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">while</span> (go != <span class="hljs-literal">true</span>) &#123;<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is going to wait on this object&quot;</span>);<br>      wait();<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is woken up&quot;</span>);<br>    &#125;<br>    go = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">NotificationDemo</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationDemo</span>();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">waitTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          test.shouldGo();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finished Execution&quot;</span>);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">notifyTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        test.go();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finished Execution&quot;</span>);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(waitTask, <span class="hljs-string">&quot;WT1&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(waitTask, <span class="hljs-string">&quot;WT2&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(waitTask, <span class="hljs-string">&quot;WT3&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(notifyTask, <span class="hljs-string">&quot;NT1&quot;</span>);<br><br>    t1.start();<br>    t2.start();<br>    t3.start();<br><br>    Thread.sleep(<span class="hljs-number">200</span>);<br><br>    t4.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Thread[WT1,5,main] is going to wait on this object<br>Thread[WT2,5,main] is going to wait on this object<br>Thread[WT3,5,main] is going to wait on this object<br>Thread[NT1,5,main] is going to notify all or one thread waiting on<br>Thread[WT1,5,main] is woken up<br>NT1 finished Execution<br>WT1 finished Execution<br></code></pre></td></tr></table></figure><ol><li>从输出来看前3行是WT1、WT2、WT3依次进入等待池，</li><li>之后NT1调用<code>notify</code>方法随机唤醒一个线程将其置入锁池，并修改<code>go = true;</code>跳出循环</li><li>这里是WT1被置入锁池，因为上一步中<code>go</code>的值被修改所以跳出循环，WT1获得锁并且修改了变量<code>go = false;</code>，然后因为NT1线程已经结束所以剩下两个线程WT2、WT3依然处于等待池。</li></ol><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><code>yield</code></h3><p>当调用<code>Thread.yield()</code>时会给线程调度器<code>scheduler</code>一个当前线程愿意让出CPU的使用的信号，但是调度去可能会无视该暗示。</p><blockquote><p>Thread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A hint to the scheduler that the current thread is willing to yield</span><br><span class="hljs-comment"> * its current use of a processor. The scheduler is free to ignore this</span><br><span class="hljs-comment"> * hint.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class="hljs-comment"> * between threads that would otherwise over-utilise a CPU. Its use</span><br><span class="hljs-comment"> * should be combined with detailed profiling and benchmarking to</span><br><span class="hljs-comment"> * ensure that it actually has the desired effect.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class="hljs-comment"> * for debugging or testing purposes, where it may help to reproduce</span><br><span class="hljs-comment"> * bugs due to race conditions. It may also be useful when designing</span><br><span class="hljs-comment"> * concurrency control constructs such as the ones in the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> java.util.concurrent.locks&#125; package.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">yieldTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>          System.out.println(Thread.currentThread().getName() + i);<br>          <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) &#123;<br>            Thread.<span class="hljs-keyword">yield</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(yieldTask, <span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(yieldTask, <span class="hljs-string">&quot;B&quot;</span>);<br>    t1.start();<br>    t2.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">A0<br>B0<br>A1<br>B1<br>A2<br>B2<br>A3<br>B3<br>A4<br>B4<br>B5<br>A5<br>B6<br>B7<br>B8<br>B9<br>B10<br>A6<br>A7<br>A8<br>A9<br>A10<br></code></pre></td></tr></table></figure><p>可以看出当A线程执行到5时把CPU让给了B来执行，直到B执行到10把B让给A</p><h3 id="使用interrupt来中断线程"><a href="#使用interrupt来中断线程" class="headerlink" title="使用interrupt来中断线程"></a>使用<code>interrupt</code>来中断线程</h3><p>已被抛弃的方法：</p><ul><li><del><code>stop()</code></del>：过于暴力，被中断线程可能没有释放锁</li><li><del><code>suspend()</code></del>, <del><code>resume()</code></del></li></ul><p><code>interrupt()</code></p><ul><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常</li><li>如果线程处于正常状态，那么线程会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">interruptTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 在正常运行任务时，经常检查本线程的中断标志位，如果设置了中断标志就自行停止线程</span><br>          <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            i++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; (&quot;</span> + Thread.currentThread().getState()+ <span class="hljs-string">&quot;) loop:i=&quot;</span> + i);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-comment">// 在调用阻塞方法时正确处理InterruptedException异常</span><br>          System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; (&quot;</span> + Thread.currentThread().getState() + <span class="hljs-string">&quot;) catch InterruptedException&quot;</span>);<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(interruptTask, <span class="hljs-string">&quot;t1&quot;</span>);<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is new.&quot;</span>);<br><br>    t1.start();<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is started.&quot;</span>);<br><br>    Thread.sleep(<span class="hljs-number">300</span>);<br>    t1.interrupt();<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is interrupted.&quot;</span>);<br><br>    Thread.sleep(<span class="hljs-number">300</span>);<br>    System.out.println(t1.getName() + <span class="hljs-string">&quot; (&quot;</span> + t1.getState() + <span class="hljs-string">&quot;) is interrupted now.&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">t1 (NEW) is new.<br>t1 (RUNNABLE) is started.<br>t1 (RUNNABLE) loop:i=1<br>t1 (RUNNABLE) loop:i=2<br>t1 (RUNNABLE) catch InterruptedException<br>t1 (RUNNABLE) is interrupted.<br>t1 (TERMINATED) is interrupted now.<br></code></pre></td></tr></table></figure><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><blockquote><p>Thread.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A thread state.  A thread can be in one of the following states:</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #NEW&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that has not yet started is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #RUNNABLE&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread executing in the Java virtual machine is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #BLOCKED&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that is blocked waiting for a monitor lock</span><br><span class="hljs-comment"> *     is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #WAITING&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that is waiting indefinitely for another thread to</span><br><span class="hljs-comment"> *     perform a particular action is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #TIMED_WAITING&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that is waiting for another thread to perform an action</span><br><span class="hljs-comment"> *     for up to a specified waiting time is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #TERMINATED&#125;&lt;br&gt;</span><br><span class="hljs-comment"> *     A thread that has exited is in this state.</span><br><span class="hljs-comment"> *     &lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * A thread can be in only one state at a given point in time.</span><br><span class="hljs-comment"> * These states are virtual machine states which do not reflect</span><br><span class="hljs-comment"> * any operating system thread states.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getState</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java线程状态：</p><ol><li>新建(NEW)：创建后尚未启动的线程状态</li><li>运行(RUNNABLE)：包含Running(正在执行)和Ready(正在等待CPU分配时间片)<ul><li>Ready(正在等待CPU分配时间片)：其它线程调用了该对象的<code>start()</code>方法，该线程位于可运行线程池中，等待被线程调度选中，获取CPU使用权。</li><li>Running(正在执行)：就绪状态的线程在获得CPU时间片后变为运行中状态(running)</li></ul></li><li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片(timeslice)，执行程序代码</li><li>无限期等待(WAITING)：不会被分配CPU执行时间，需要被显示唤醒，进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)<ul><li>没有设置<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>没有设置<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li>限期等待(TIMED_WAITING)：在一定时间后会由系统自动唤醒<ul><li><code>Thread.sleep()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li>阻塞(BLOCKED)：等待获取排它锁，线程试图获取一个内部对象的<code>Monitor</code>（进入<code>synchronized</code>方法或<code>synchronized</code>块）但是其他线程已经抢先获取，那此线程被阻塞，知道其他线程释放<code>Monitor</code>并且线程调度器允许当前线程获取到<code>Monitor</code>，此线程就恢复到可运行状态。</li><li>结束(TERMINATED)：已终止线程的状态，线程已经结束执行</li></ol><img src="./线程的状态.png"><img src="./等待队列.png"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000016197831?utm_source=tag-newest">一文读懂Java线程状态转换</a></li></ul><p>下图为Oracle支持各个JDK版本所到的年限</p><img src="oracleJDK vs OpenJDK.png">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念回顾&quot;&gt;&lt;a href=&quot;#基本概念回顾&quot; class=&quot;headerlink&quot; title=&quot;基本概念回顾&quot;&gt;&lt;/a&gt;基本概念回顾&lt;/h2&gt;&lt;h3 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Back-end" scheme="http://yoursite.com/categories/Back-end/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>No216. Combination Sum II</title>
    <link href="http://yoursite.com/2022/10/30/LeetCode/No216.%20Combination%20Sum%20II/"/>
    <id>http://yoursite.com/2022/10/30/LeetCode/No216.%20Combination%20Sum%20II/</id>
    <published>2022-10-29T22:30:02.000Z</published>
    <updated>2023-03-26T08:21:11.150Z</updated>
    
    <content type="html"><![CDATA[<ol start="216"><li>Combination Sum III<br>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:<br>Only numbers 1 through 9 are used.<br>Each number is used at most once.<br>Return a list of all possible valid combinations.<br>The list must not contain the same combination twice, and the combinations may be returned in any order.</li></ol><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: k = 3, n = 7<br>Output: [[1,2,4]]<br></code></pre></td></tr></table></figure><p>Explanation:<br>1 + 2 + 4 &#x3D; 7<br>There are no other valid combinations.  </p><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: k = 3, n = 9<br>Output: [[1,2,6],[1,3,5],[2,3,4]]<br></code></pre></td></tr></table></figure><p>Explanation:<br>1 + 2 + 6 &#x3D; 9<br>1 + 3 + 5 &#x3D; 9<br>2 + 3 + 4 &#x3D; 9<br>There are no other valid combinations.  </p><p>Example 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: k = 4, n = 1<br>Output: []<br></code></pre></td></tr></table></figure><p>Explanation: There are no valid combinations.<br>Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 &#x3D; 10 and since 10 &gt; 1, there are no valid combination.</p><p>Constraints:<br>2 &lt;&#x3D; k &lt;&#x3D; 9<br>1 &lt;&#x3D; n &lt;&#x3D; 60  </p><p>给 元素重复 无序 数组，求满足条件的子数组，组合问题<br>需要子数组满足的条件：子数组元素和等于某个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinationSumIII</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(result, path, nums, <span class="hljs-number">0</span>, k, n);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> stillNeed)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stillNeed == <span class="hljs-number">0</span> &amp;&amp; level == <span class="hljs-number">0</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level &lt; <span class="hljs-number">0</span> || stillNeed &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            backtrack(result, path, nums, i+<span class="hljs-number">1</span>, level-<span class="hljs-number">1</span>, stillNeed-nums[i]);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;216&quot;&gt;
&lt;li&gt;Combination Sum III&lt;br&gt;Find all valid combinations of k numbers that sum up to n such that the following conditions are</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>No39. Combination Sum</title>
    <link href="http://yoursite.com/2022/10/30/LeetCode/No39.%20Combination%20Sum/"/>
    <id>http://yoursite.com/2022/10/30/LeetCode/No39.%20Combination%20Sum/</id>
    <published>2022-10-29T22:30:02.000Z</published>
    <updated>2023-03-26T08:21:00.003Z</updated>
    
    <content type="html"><![CDATA[<ol start="39"><li>Combination Sum</li></ol><p><a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations<br>of candidates where the chosen numbers sum to target. You may return the combinations in any order.<br>The same number may be chosen from candidates an unlimited number of times.<br>Two combinations are unique if the frequency of at least one of the chosen numbers is different.<br>The test cases are generated such that the number of unique combinations that sum up to target is less than 150<br>combinations for the given input.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: candidates = [2,3,6,7], target = 7<br>Output: [[2,2,3],[7]]<br></code></pre></td></tr></table></figure><p>Explanation:<br>2 and 3 are candidates, and 2 + 2 + 3 &#x3D; 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 &#x3D; 7.<br>These are the only two combinations.  </p><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: candidates = [2,3,5], target = 8<br>Output: [[2,2,2,2],[2,3,3],[3,5]]<br></code></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: candidates = [2], target = 1<br>Output: []<br></code></pre></td></tr></table></figure><p>给 元素不重复 无序 数组，求满足条件的子数组，组合问题<br>需要子数组满足的条件：子数组元素和等于某个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinationSum</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(result, candidates, path, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※</span><br><span class="hljs-comment">     * 2. 根据题意，确立结束条件</span><br><span class="hljs-comment">     * 3. 找准选择列表(与函数参数相关),与第一步紧密关联※</span><br><span class="hljs-comment">     * 4. 判断是否需要剪枝</span><br><span class="hljs-comment">     * 5. 作出选择，递归调用，进入下一层</span><br><span class="hljs-comment">     * 6. 撤销选择 返回上一层</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidates</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stillNeed</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="hljs-type">int</span>[] candidates, List&lt;Integer&gt; path, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> stillNeed)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stillNeed &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stillNeed == <span class="hljs-number">0</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>            path.add(candidates[i]);<br>            backtrack(result, candidates, path, i, stillNeed-candidates[i]);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;39&quot;&gt;
&lt;li&gt;Combination Sum&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum/&quot;&gt;https://leetcode.com/problems/com</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>No90. Subsets II</title>
    <link href="http://yoursite.com/2022/10/20/LeetCode/No90.%20Subsets%20II/"/>
    <id>http://yoursite.com/2022/10/20/LeetCode/No90.%20Subsets%20II/</id>
    <published>2022-10-19T23:02:02.000Z</published>
    <updated>2023-03-26T08:21:07.149Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/subsets-ii/">https://leetcode.com/problems/subsets-ii/</a></p><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).<br>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [1,2,2]<br>Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]<br></code></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [0]<br>Output: [[],[0]]<br></code></pre></td></tr></table></figure><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10  </p><p>给 元素重复 无序 数组，求所有的子数组，组合问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsetsII</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        backtrack(result, path, nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯法 选择可能性的N叉树，每个叉代表基于当前节点的一种选择可能性(数值一样的选择可能性视作同一种可能性要进行剪枝操作)</span><br><span class="hljs-comment">     * 怎么样写回溯算法(回溯法通用解题模板)</span><br><span class="hljs-comment">     * 1. 画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※: 状态变量start，用来标识当前的选择列表的起始位置。也就是标识每一层的状态</span><br><span class="hljs-comment">     * 2. 根据题意，确立结束条件: 因为每条路径都要加入结果集，所以是统计全路径。start越过数组边界的时候即是结束条件</span><br><span class="hljs-comment">     * 3. 找准选择列表(与函数参数相关),与第一步紧密关联※: 路径即子集</span><br><span class="hljs-comment">     * 4. 判断是否需要剪枝: 需要，因为存在同样的元素所以对于同一个节点往下分别选择一样的元素算同一种可能性</span><br><span class="hljs-comment">     * 5. 作出选择，递归调用，进入下一层</span><br><span class="hljs-comment">     * 6. 撤销选择 返回上一层</span><br><span class="hljs-comment">     * 参考：https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> result 用来记录全部可能的路径的结果 list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 从树的根节点开始往下走到全部叶子节点的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 题目给的集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前节点起始下标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 记得要深拷贝不然传引用的话result list里面全是存的同一个path list的地址</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i]) &#123; <span class="hljs-comment">// 剪枝: 同样的数字不必再进入子树了</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            backtrack(result, path, nums, i+<span class="hljs-number">1</span>);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                List&lt;Integer&gt; subset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i; index &lt;= j; index++) &#123;<br>                    subset.add(nums[index]);<br>                &#125;<br>                result.add(subset);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; subsets)</span> &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; subset : subsets) &#123;<br>            System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subset.size(); i++) &#123;<br>                System.out.print(subset.get(i));<br>                <span class="hljs-keyword">if</span> (i != subset.size()-<span class="hljs-number">1</span>)<br>                    System.out.print(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/subsets-ii/&quot;&gt;https://leetcode.com/problems/subsets-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given an integer array nums that</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>No78. Subsets</title>
    <link href="http://yoursite.com/2022/10/07/LeetCode/No78.Subsets/"/>
    <id>http://yoursite.com/2022/10/07/LeetCode/No78.Subsets/</id>
    <published>2022-10-07T09:02:02.000Z</published>
    <updated>2023-03-05T10:51:40.102Z</updated>
    
    <content type="html"><![CDATA[<p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [1,2,3]<br>Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br></code></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Input: nums = [0]<br>Output: [[],[0]]<br></code></pre></td></tr></table></figure><p>Constraints:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10  </p><p>All the numbers of nums are unique.</p><hr><p>给 元素不重复 无序 数组，求所有的子数组，组合问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.problems.medium;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subsets</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        backtrack(result, path, nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯法 求不重复元素数组的全组合 子集</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> result 全部子集列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 尝试选择元素的可能性树的从根节点开始到当前节点的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 不重复元素数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前准备开始尝试start index后的全部数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-comment">// 因为是求全部子数组，所以需要遍历完整棵树，递归出口就是 start == nums.length 可省略</span><br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 不需要剪枝，不存在重复元素</span><br>            path.add(nums[i]);<br>            backtrack(result, path, nums, i+<span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Given an integer array nums of unique elements, return all possible subsets (the power set).&lt;/p&gt;
&lt;p&gt;The solution set must not contain dup</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>JVM-12_执行引擎</title>
    <link href="http://yoursite.com/2022/08/24/JVM/JVM-12-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2022/08/24/JVM/JVM-12-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2022-08-24T02:14:37.000Z</published>
    <updated>2023-03-26T02:32:09.653Z</updated>
    
    <content type="html"><![CDATA[<p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><p><img src="/image-20200710082141643.png" alt="image-20200710082141643"><br><img src="image-20200710082141643.png" /></p><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><img src="image-20200710082433146.png" /><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><img src="image-20200710083036258.png" /><p>我们用一个总的图，来说说 解释器和编译器</p><img src="image-20200710083656277.png" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器&lt;/p&gt;
&lt;h2 id=&quot;Java代码编译和执行过程&quot;&gt;&lt;a href=&quot;#Java代码编译和执行过程&quot; class=&quot;headerlink&quot; title=&quot;Java代码编译和执行过程&quot;&gt;&lt;/a&gt;Java代码</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-2_类加载子系统</title>
    <link href="http://yoursite.com/2022/08/23/JVM/JVM-2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2022/08/23/JVM/JVM-2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-08-23T02:06:24.000Z</published>
    <updated>2023-03-26T08:32:13.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><img src="./内存结构概述.png"><img src="./内存结构.png"><p>类加载子系统负责从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p><p>加载的类信息存放在叫做方法区的内存空间。除了类信息外，方法区还存放运行时常量池信息，可能还有字符串和数字常量</p><p>class file加载到JVM中被称为DNA元数据模板，放在方法区</p><h3 id="字节码文件-class"><a href="#字节码文件-class" class="headerlink" title="字节码文件.class"></a>字节码文件.class</h3><p>使用二进制查看器打开任意字节码文件可以观察到期开头4个字节用十六进制表示为<code>CA FE BA BE</code>(可记为咖啡宝贝)，这是字节码文件固定头部</p><h3 id="1-加载-Loading"><a href="#1-加载-Loading" class="headerlink" title="1. 加载 Loading"></a>1. 加载 Loading</h3><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的今天存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>可以从哪些地方加载.class文件呢：</p><ul><li>本地文件加载</li><li>网络获取，典型场景：web Applet</li><li>zip压缩包中读取</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>其它文件生成，例如：JSP应用</li><li>专有数据库提取.class文件，少见</li><li>加密文件中获取，可防止class文件被反编译</li></ul><h3 id="2-链接-Linking"><a href="#2-链接-Linking" class="headerlink" title="2. 链接 Linking"></a>2. 链接 Linking</h3><p>该阶段分为以下几步：</p><ol><li>验证(Verify)</li></ol><ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：<ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol></li></ul><ol start="2"><li>准备(Prepare)</li></ol><ul><li>为变量分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到java堆中</li></ul><ol start="3"><li>解析(Resolve)</li></ol><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>解析操作往往伴随JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li></ul><h3 id="3-初始化-Initialization"><a href="#3-初始化-Initialization" class="headerlink" title="3. 初始化 Initialization"></a>3. 初始化 Initialization</h3><ul><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器<code>&lt;init&gt;()</code>，若一个类中没有静态变量和静态代码块则字节码文件中无<code>&lt;clinit&gt;()</code>方法</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClinitTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClinitTest</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译字节码文件可以看到存在<code>&lt;clinit&gt;()</code>和<code>&lt;init&gt;()</code></p><p><code>&lt;init&gt;</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> 0 aload_0<br> 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;<br> 4 aload_0<br> 5 iconst_1<br> 6 putfield #2 &lt;com/sicmatr1x/java/ClinitTest.a&gt;<br> 9 aload_0<br>10 bipush 10<br>12 putfield #2 &lt;com/sicmatr1x/java/ClinitTest.a&gt;<br>15 bipush 20<br>17 istore_1<br>18 return<br></code></pre></td></tr></table></figure><p>可以看到先给a赋值10再给d赋值20</p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>JVM支持两种类型的类加载器：</p><ol><li>引导类加载器(Bootstrap ClassLoader)</li><li>自定义类加载器(User-Defined ClassLoader)：所有派生于抽象类ClassLoader的类加载器都可划分为自定义类加载器</li></ol><p>启动类加载器(引导类加载器, Bootstrap ClassLoader)：</p><ul><li>使用C&#x2F;C++语言实现，嵌套在JVM内部</li><li>用于加载Java的核心库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar, resources.jar或sun.boot.class.path路径下的内容)</li><li>不继承于java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并制定为他们的父类加载器</li><li>处于安全考虑，Bootstrap启动类加载器只加载包名为java, javax, sun等开头的类</li></ul><p>扩展类加载器(Extension ClassLoader)</p><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录，也会自动由扩展类加载器加载。</li></ul><p>应用程序类加载器(系统类加载器, AppClassLoader)</p><ul><li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载器是程序中默认的类加载器，通常Java应用的类都由它来加载</li><li>通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取到该类加载器</li></ul><p>获取Bootstrap ClassLoader类加载器和Extension ClassLoader类加载器可以加载的路径和jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">import</span> sun.misc.Launcher;<br><span class="hljs-keyword">import</span> sun.misc.URLClassPath;<br><br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;引导类加载器：&quot;</span>);<br>        <span class="hljs-type">URLClassPath</span> <span class="hljs-variable">urlClassPath</span> <span class="hljs-operator">=</span> Launcher.getBootstrapClassPath();<br>        URL[] urls = urlClassPath.getURLs();<br>        <span class="hljs-keyword">for</span> (URL url : urls) &#123;<br>            System.out.println(url.toExternalForm());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;扩展类加载器：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">extDirs</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String dir : extDirs.split(<span class="hljs-string">&quot;;&quot;</span>)) &#123;<br>            System.out.println(dir);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">引导类加载器：<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/resources.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/sunrsasign.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jsse.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/charsets.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jfr.jar<br>file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/classes<br>扩展类加载器：<br>C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext<br>C:\Windows\Sun\Java\lib\ext<br></code></pre></td></tr></table></figure><p>用户自定义类加载器：</p><ul><li>什么时候需要用户自定义类加载器：<ul><li>隔离加载类：例如：确保应用中引用的jar包与中间件引用的第三方jar包不冲突</li><li>修改类加载方式：例如：需要时候动态加载</li><li>扩展加载源：例如：从数据库中加载</li><li>防止源码泄露</li></ul></li><li>用户自定义类加载器实现步骤：<ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式实现自己的类加载器</li><li>在JDK1.2之前，自定义类加载器需要继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载器。JDK1.2之后不建议用户覆盖loadClass()方法，建议把自定义的类加载逻辑写在findClass()方法中</li><li>编写自定义类加载器时若无过于复杂的需求建议直接继承URLClassLoader类，这样可以避免自己去编写findClass()方法及获取字节码流的方式，是自定义类加载器编写更加简洁</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] result = getClassFromCustomPath(name);<br>            <span class="hljs-keyword">if</span>(result == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> defineClass(name,result,<span class="hljs-number">0</span>,result.length);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassFromCustomPath(String name)&#123;<br>        <span class="hljs-comment">//从自定义路径中加载指定类:细节略</span><br>        <span class="hljs-comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CustomClassLoader</span> <span class="hljs-variable">customClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassLoader</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;One&quot;</span>,<span class="hljs-literal">true</span>,customClassLoader);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            System.out.println(obj.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>常用方法：</p><ul><li>getParent(): 返回该类加载器的超类加载器</li><li>loadClass(String name): 加载名称为name的类，返回结果为java.lang.Class类的实例</li><li>findClass(String name): 查找名称为name的类，返回结果为java.lang.Class类的实例</li><li>findLoadedClass(String name): 查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</li><li>defineClass(String name, byte[] b, int off, int len): 把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</li><li>resolveClass(Class&lt;?&gt; c): 连接指定的一个Java类</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>JVM对class文件采用按需加载的方式，即需要使用到该类时才会把class文件加载到内存生成class对象。而且在加载时JVM采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式。</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，若无法完成，子类加载器才会去加载。</li></ol><p>优点：</p><ul><li>避免类的重复加载：一旦一个类被父加载器加载则不会再被子加载器加载</li><li>保护程序安全，防止核心API被篡改：比如你自己定义一个java.lang.String就不会被AppClassLoader加载而是Bootstrap ClassLoader加载java的String</li></ul><p>沙箱安全机制：<br>自定义String类在加载的时候回率先使用引导类加载器加载，而引导类加载器会先加载JDK自带的文件rt.jar包中的java\lang\String.class，这样可以保证对java核心源代码的保护</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>JVM中表示两个class对象是否为同一个类存在的两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</li></ol><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><p>JVM知道一个类时由启动类加载器加载器加载的还是由用户类加载器加载的。若是由用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类到另一个类的时候，JVM需要保证这两个类的类加载器是相同的。</p><h3 id="类的主动使用与被动使用"><a href="#类的主动使用与被动使用" class="headerlink" title="类的主动使用与被动使用"></a>类的主动使用与被动使用</h3><p>主动使用的七种情况：</p><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供动态语言支持：</li></ol><ul><li>java.lang,invoke.MethodHandle实例的解析结果</li><li>REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了主动使用的七种情况外都算被动使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存与垃圾回收&quot;&gt;&lt;a href=&quot;#内存与垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;内存与垃圾回收&quot;&gt;&lt;/a&gt;内存与垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;内存结构概述&quot;&gt;&lt;a href=&quot;#内存结构概述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop</title>
    <link href="http://yoursite.com/2022/08/19/BigData/Hadoop/"/>
    <id>http://yoursite.com/2022/08/19/BigData/Hadoop/</id>
    <published>2022-08-19T09:38:04.000Z</published>
    <updated>2023-03-26T08:08:46.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Hadoop："><a href="#Hadoop：" class="headerlink" title="Hadoop："></a>Hadoop：</h3><p>Hadoop是一个框架，它是由Java语言来实现的。Hadoop是处理大数据技术.Hadoop可以处理云计算产生大数据。</p><p>CDH商业版：</p><p>Cloudera CDH是Hadoop的一个版本，比Apache Hadoop的优点如下：</p><ol><li>CDH基于稳定版Apache Hadoop，并应用了最新Bug修复或者Feature的Patch。Cloudera常年坚持季度发行Update版本，年度发行Release版本，更新速度比Apache官方快，而且在实际使用过程中CDH表现无比稳定，并没有引入新的问题。</li><li>Cloudera官方网站上安装、升级文档详细，省去Google时间。</li><li>CDH支持Yum&#x2F;Apt包，Tar包，RPM包，Cloudera Manager四种方式安装，总有一款适合您。官方网站推荐Yum&#x2F;Apt方式安装，其好处如下：</li></ol><ul><li>联网安装、升级，非常方便。当然你也可以下载rpm包到本地，使用Local Yum方式安装。</li><li>自动下载依赖软件包，比如要安装Hive，则会级联下载、安装Hadoop。</li><li>Hadoop生态系统包自动匹配，不需要你寻找与当前Hadoop匹配的Hbase，Flume，Hive等软件，Yum&#x2F;Apt会根据当前安装Hadoop版本自动寻找匹配版本的软件包，并保证兼容性。</li><li>自动创建相关目录并软链到合适的地方（如conf和logs等目录）；自动创建hdfs, mapred用户，hdfs用户是HDFS的最高权限用户，mapred用户则负责mapreduce执行过程中相关目录的权限。</li></ul><h3 id="大数据的4个V"><a href="#大数据的4个V" class="headerlink" title="大数据的4个V:"></a>大数据的4个V:</h3><ol><li>Velocity：实现快速的数据流传</li><li>Variety： 具有多样的数据类型</li><li>Volume： 存有海量的数据规模（TB，PB，EB级别）</li><li>Value：存在着巨大的价值</li></ol><hr><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><img src="Hadoop项目结构图.jpg" /><p>Hadoop实际上就是谷歌三宝的开源实现，</p><p>Hadoop MapReduce对应Google MapReduce，</p><p>HBase对应BigTable，</p><p>HDFS对应GFS。HDFS（或GFS）为上层提供高效的非结构化存储服务，</p><p>HBase（或BigTable）是提供结构化数据服务的分布式数据库，Hadoop MapReduce（或Google MapReduce）是一种并行计算的编程模型，用于作业调度。</p><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。</p><h3 id="HDFS-Hadoop-Distributed-File-System-："><a href="#HDFS-Hadoop-Distributed-File-System-：" class="headerlink" title="HDFS(Hadoop Distributed File System)："></a>HDFS(Hadoop Distributed File System)：</h3><ul><li>默认的最基本的存储单位是64M的数据块。</li><li>和普通文件系统相同的是，HDFS中的文件是被分成64M一块的数据块存储的。</li><li>不同于普通文件系统的是，HDFS中，如果一个文件小于一个数据块的大小，并不占用整个数据块存储空间。</li></ul><h3 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h3><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。</p><h3 id="联机事务处理OLTP-On-line-Transaction-Processing-、联机分析处理OLAP-On-Line-Analytical-Processing"><a href="#联机事务处理OLTP-On-line-Transaction-Processing-、联机分析处理OLAP-On-Line-Analytical-Processing" class="headerlink" title="联机事务处理OLTP(On-line Transaction Processing)、联机分析处理OLAP(On-Line Analytical Processing)"></a>联机事务处理OLTP(On-line Transaction Processing)、联机分析处理OLAP(On-Line Analytical Processing)</h3><p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 </p><img src="OLTP与OLAP之间的比较.jpg" /><p>分析型数据不允许update、delete操作</p><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><p>Sqoop(发音：skup)是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p><h3 id="ZooKepper"><a href="#ZooKepper" class="headerlink" title="ZooKepper"></a>ZooKepper</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。<br>ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p><h3 id="Mahout"><a href="#Mahout" class="headerlink" title="Mahout"></a>Mahout</h3><img src="Mahout.PNG" /><p>Mahout 是 Apache Software Foundation（ASF） 旗下的一个开源项目，提供一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。</p><h2 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h2><h3 id="支持平台"><a href="#支持平台" class="headerlink" title="支持平台"></a>支持平台</h3><ul><li>GNU&#x2F;Linux是产品开发和运行的平台。Hadoop已在有2000个节点的GNU&#x2F;Linux主机组成的集群系统上得到验证。</li><li>Win32平台是作为<code>开发平台</code>支持的。由于分布式操作尚未在Win32平台上充分测试，所以还不作为一个<code>生产平台</code>被支持。</li></ul><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><h4 id="安装-VMware"><a href="#安装-VMware" class="headerlink" title="安装 VMware"></a>安装 VMware</h4><h4 id="安装-Ubuntu"><a href="#安装-Ubuntu" class="headerlink" title="安装 Ubuntu"></a>安装 Ubuntu</h4><h4 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h4><p>解压<code>tar -vzfx jdk-1.7.0.tar.gz</code></p><p>配环境变量<code>sudo vim /etc/profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/home/master0/Desktop/jkd1.7.0_80<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>使配置文件生效：<code>source /etc/profile</code></p><h4 id="安装Hadoop-1"><a href="#安装Hadoop-1" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h4><p>配环境变量<code>sudo vim /etc/profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/home/master0/Desktop/jdk1.7.0_80<br><span class="hljs-built_in">export</span> HADOOP_HOME=/home/master0/Desktop/hadoop-2.6.0<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar:<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/common/hadoop-common-2.6.0.jar:<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-client-core-2.6.0.jar:<span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/common/lib/commons-1.2.jar:<span class="hljs-variable">$CLASSPATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HADOOP_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>配置<code>~/hadoop-2.6.0/etc/hadoop/hadoop-env.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># The java implementation to use.</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/home/master0/Desktop/jdk1.7.0_80<br></code></pre></td></tr></table></figure><h4 id="测试hadoop"><a href="#测试hadoop" class="headerlink" title="测试hadoop"></a>测试hadoop</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop version<br></code></pre></td></tr></table></figure><hr><h4 id="使用hadoop的本地单独模式"><a href="#使用hadoop的本地单独模式" class="headerlink" title="使用hadoop的本地单独模式"></a>使用hadoop的本地单独模式</h4><p>对某目录下的文档进行单词数的统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span>  /home/hadoop/<br>$ <span class="hljs-built_in">mkdir</span>  input<br>$ <span class="hljs-built_in">cp</span>   <span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop/*.xml   input/<br>$ hadoop  jar <span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar grep input output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span><br>$ <span class="hljs-built_in">cat</span> output/*<br></code></pre></td></tr></table></figure><h4 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h4><p>修改主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/hostname<br></code></pre></td></tr></table></figure><hr><h4 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/network/interfaces<br></code></pre></td></tr></table></figure><p>编辑-&gt;虚拟网络编辑器-&gt;查看NAT模式的子网地址</p><p>例如为：231</p><p>master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto eth0<br>iface eth0 inet static<br>address 192.168.231.129<br>netmask 255.255.255.0<br>network 192.168.231.0<br>boardcast 192.168.231.255<br>gateway 192.168.231.2<br>dns-nameservers 192.168.1.1 8.8.8.8 8.8.8.4<br><br>ping 192.168.231.130<br></code></pre></td></tr></table></figure><p>serve1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto eth0<br>iface eth0 inet static<br>address 192.168.231.130<br>netmask 255.255.255.0<br>network 192.168.231.0<br>boardcast 192.168.231.255<br>gateway 192.168.231.2<br>dns-nameservers 192.168.1.1 8.8.8.8 8.8.8.4<br><br>ping 192.168.231.129<br></code></pre></td></tr></table></figure><p>若访问不了网页的话可以将物理机的dns填写在dns-nameservers第一个</p><p>若拖文件拖不进虚拟机需检查：</p><p>虚拟机ping与其对应的模式的虚拟网卡可不可以ping通</p><p>主机ping与虚拟机可不可以ping通</p><p>VMware Network Adapter VMnet1:桥接模式虚拟网卡</p><p>VMware Network Adapter VMnet8:NAT模式虚拟网卡</p><h4 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/hosts<br><br>192.168.231.129  master<br>192.168.231.130  serve1<br>192.168.231.131  serve2<br></code></pre></td></tr></table></figure><h4 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ssh<br></code></pre></td></tr></table></figure><p>安装完毕就会出现<code>/home/master/.ssh</code>文件夹</p><p>然后需要生成了一个公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -P <span class="hljs-string">&#x27;&#x27;</span><br><br>会生成<br>id_rsa  id_rsa.pub  known_hosts<br></code></pre></td></tr></table></figure><p>id_rsa为私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">-----BEGIN RSA PRIVATE KEY-----<br>MIIEpAIBAAKCAQEAp6JLYxM9lm/ciNG5SuAd/0WBBY0VN98w1KLad5GrkZhM5iZ1<br>mKnl1JHhT14//QSqtJ/tAAo8P1EZspvziS1q77DVBF4L/kInl0KEZOiFWMUOKqDj<br>y+TWLSZmBK9uP5J2cb2wnIMZ4HeWw0y8hnaCpfg4FNVm8WL/EQh++EHx4VBQv0bt<br>4s3qZ9LgYM0MGDrizYKCZ92vRE2CVgLlpAzXvD2uFfxlFwJl02l35fjaIW2ed6PV<br>HrnT8D6BrpUIdKWzWsevj3W6IfO0upBtqOygJw0RxYSx646nDDdFXIk7bzdVFXdr<br>sOjOblsPGqTJs+aApEQB3avOUZI0EixCr2h7/wIDAQABAoIBAQCY1je1lQ1J46NG<br>ezBdPAkdfNktnnwB/NQginp1GbM7g4hZLid5kS2iqX6rRltA7MhW9pi2uJ5FfEPZ<br>vKZGI8qjzq3o1XZJ0zcVief7uKQbU06fPyFx/KnpcGEDVI9IFtk2yqQDjuRA68fh<br>OE2KqvJjL/Sxyf+ZhZDYjs50ums16PHxXlhAaP8EI78Dcff5sx+ZoKTVGum4Jrdl<br>h0cXeDBcxJZg7wEtHPEUrduaiwEv88fD7aw2QwsYdCuPECncltR57iPi95hr7uaW<br>XdtRZ+mAey5sBxJmZKrlPE6kK3yAvSs1tP0yz4R4azAYQqTpLmxcfMrqWRwb3IMA<br>9Rl98FIBAoGBANpNaYJgaTvDT2Nski6sTu1oPefow4tosvPE1jZ/gWXExJ9m1OiI<br>GcZGG0nM+UCx85+//B6gyLdvmUGgxN9vzmY3myuhQ9iesep7W+DiqDnz2J/VRM98<br>eEso6P1jevlC90WJh1wNrVIuzxuN/5A5LghjNNuHCnZzJTRuSKjISjRhAoGBAMSU<br>9hdNDliOXDIIRs/vjwiRuLvbECMFqETSyFdnc91dAi2cYfwlfKFlWGSPFO/LuTvL<br>9PfWaKgfuAzMiZ5JoMPlo5iX8atX1V4Naz7e3OBR9rhyD0oO4aNyKtvDv7tIWTxm<br>eWw/4hlmPp/wGYgfxlPOrbVfJcESYk9FmRxxeoxfAoGAP87ozCcKG2HXTqRphiLv<br>Xw1dKvAqWBFeXUpnor5aQDjnkAAqs100y3OqfkPfhz18jHE9bGZqxNNl5HztjrHL<br>jq0qOfKFNkgMkRFFpdIagfX4l59q4YrsTmvCzm3JgBpG1JiCbDHDO4ZbGx7CWJGe<br>Fu2IgbJTKJQ3h7/ElTEWH4ECgYEAoxOr/vJ2hzI5+2twSwlBT+uLI5P8FAGacNWn<br>SxLQRH/m0a2cf48dj8pCBNHJnZAUby2oX30nvujpRvza4UvVKQ20pF7QJcMshuR8<br>5l/9Pb3g/WvpkRc9SdjpAvylbpj7JicgbZOlXkq6gvWsSIeLgHTBF+gBquQ0V+y1<br>sqnU7uMCgYBMSR2QDG5TuSp7pNOFBFuqhOCrUHZmKqoHCZ7rSh3etxc8D5tLXciE<br>APNWfGqSE2aT/PJgqNoxl5p42bnZrv3cXJuiD9Wid6yFzDH0oUa9K66vy1SWV+B8<br>3rHha5wLzizgNUQZjh1XSndp1WekYCLjV+Bn8b/odBClcHKX7M/BOg==<br>-----END RSA PRIVATE KEY-----<br></code></pre></td></tr></table></figure><p>id_rsa.pub为公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCnoktjEz2Wb9yI0blK4B3/RYEFjRU33zDUotp3kauRmEzmJnWYqeXUkeFPXj/9BKq0n+0ACjw/URmym/OJLWrvsNUEXgv+QieXQoRk6IVYxQ4qoOPL5NYtJmYEr24/knZxvbCcgxngd5bDTLyGdoKl+DgU1WbxYv8RCH74QfHhUFC/Ru3izepn0uBgzQwYOuLNgoJn3a9ETYJWAuWkDNe8Pa4V/GUXAmXTaXfl+NohbZ53o9UeudPwPoGulQh0pbNax6+Pdboh87S6kG2o7KAnDRHFhLHrjqcMN0VciTtvN1UVd2uw6M5uWw8apMmz5oCkRAHdq85RkjQSLEKvaHv/ master@ubuntu<br></code></pre></td></tr></table></figure><p>要想免密登录则需要被免密登录方的公钥：这里可以先将各台分机的公钥发送给主机master，然后再由master合成一个文件再发送给分机。这样每台机器都会有其它所有机器的公钥</p><p>生成公钥文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">authorized_keys如下，其实和公钥相同：<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCnoktjEz2Wb9yI0blK4B3/RYEFjRU33zDUotp3kauRmEzmJnWYqeXUkeFPXj/9BKq0n+0ACjw/URmym/OJLWrvsNUEXgv+QieXQoRk6IVYxQ4qoOPL5NYtJmYEr24/knZxvbCcgxngd5bDTLyGdoKl+DgU1WbxYv8RCH74QfHhUFC/Ru3izepn0uBgzQwYOuLNgoJn3a9ETYJWAuWkDNe8Pa4V/GUXAmXTaXfl+NohbZ53o9UeudPwPoGulQh0pbNax6+Pdboh87S6kG2o7KAnDRHFhLHrjqcMN0VciTtvN1UVd2uw6M5uWw8apMmz5oCkRAHdq85RkjQSLEKvaHv/ master@ubuntu<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">分机serve1复制公钥到master主机上：<br>scp .ssh/id_rsa.pub master@master:/home/master/id_rsa_1.pub<br>将分机serve1的公钥追加到主机的authorized_keys上<br><span class="hljs-built_in">cat</span> id_rsa_1.pub &gt;&gt; .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>重复以上两步直到主机master的authorized_keys有所有分机的公钥，再进行分发操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp .ssh/authorized_keys master@serve1:/home/master/.ssh/authorized_keys<br>scp .ssh/authorized_keys master@serve2:/home/master/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>分发完毕后即可进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh master<br>ssh serve1<br>能连接成功即可<br></code></pre></td></tr></table></figure><p>SSH免密码设置失败解决</p><ol><li>权限问题</li></ol><p>.ssh目录，以及&#x2F;home&#x2F;当前用户 需要700权限，参考以下操作调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span>   <span class="hljs-built_in">chmod</span>   777   ~/.ssh<br><br><span class="hljs-variable">$sudo</span>  <span class="hljs-built_in">chmod</span> 700  /home/当前用户<br></code></pre></td></tr></table></figure><p>.ssh目录下的authorized_keys文件需要600或644权限，参考以下操作调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span> <span class="hljs-built_in">chmod</span>   644   ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><ol start="2"><li>StrictModes问题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span> gedit /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\<span class="hljs-comment">#StrictModes yes</span><br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">StrictModes no<br></code></pre></td></tr></table></figure><p>如果还不行，可以用<code>ssh -vvv 目标机器ip</code> 查看详情</p><h4 id="配置Hadoop集群"><a href="#配置Hadoop集群" class="headerlink" title="配置Hadoop集群"></a>配置Hadoop集群</h4><p>以下将会修改多个Hadoop配置文件均位于<code>hadoop-2.6.0/etc</code>目录下</p><p>修改：<code>hadoop-env.sh</code> 、<code>yarn-env.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/hadoop-env.sh<br><br><span class="hljs-comment"># The java implementation to use.</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/home/master/jdk1.7.0_80<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/yarn-env.sh<br></code></pre></td></tr></table></figure><p>core-site.xml</p><p>core-site.xml的完整参数请参考: <a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/core-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/core-default.xml</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/core-site.xml<br></code></pre></td></tr></table></figure><p><code>/home/hadoop/tmp</code> 目录如不存在，则先mkdir手动创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://master:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-comment">&lt;!--主机名:端口号--&gt;</span>     <br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-comment">&lt;!--/tmp/hadoop-$&#123;user.name&#125;--&gt;</span>   <br> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>hdfs-site.xml</p><p>hdfs-site.xml的完整参数请参考: <a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/hdfs-site.xml<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.ipc.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0.0.0.0:50020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.http.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0.0.0.0:50075<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/home/master/data/namenode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--元数据--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/home/master/data/datanode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据块--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>slave1:9001<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--备份数量--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.permissions<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--权限验证--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置slaves分机列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit etc/hadoop/slaves<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">master<br>serve1<br></code></pre></td></tr></table></figure><p>分发配置文件到集群的其它机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r hadoop-2.6.0/etc/hadoop/ master@serve1:/home/master/hadoop-2.6.0/etc/<br></code></pre></td></tr></table></figure><p>格式化hdfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs namenode -format<br></code></pre></td></tr></table></figure><p>等看到执行信息有has been successfully formatted表示格式化ok</p><p>启动 dfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-2.6.0/sbin/start-dfs.sh<br></code></pre></td></tr></table></figure><p>验证hadoop是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$jps</span><br>显示有：<br>4895 DataNode<br>4775 NameNode<br></code></pre></td></tr></table></figure><h4 id="安装-MapReduce"><a href="#安装-MapReduce" class="headerlink" title="安装 MapReduce"></a>安装 MapReduce</h4><p>mapred-site.xml的完整参数请参考<a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml</a></p><p>将mapred-site.xml.template改名成mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>yarn-site.xml</p><p>yarn-site.xml的完整参数请参考: <a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-yarn/hadoop-yarn-common/yarn-default.xml">http://hadoop.apache.org/docs/r2.6.0/hadoop-yarn/hadoop-yarn-common/yarn-default.xml</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8030<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8025<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>master:8040<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="启动yarn"><a href="#启动yarn" class="headerlink" title="启动yarn"></a>启动yarn</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-2.6.0/sbin/start-yarn.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$jps</span><br>多了ResourceManager和NodeManager表示启动yarn成功<br>SecondaryNameNode<br>ResourceManager<br>NameNode<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-2.6.0/sbin/start-dfs.sh<br>hadoop-2.6.0/sbin/start-yarn.sh<br><br>jps<br>master节点上有几下3个进程：<br>7482 ResourceManager<br>7335 SecondaryNameNode<br>7159 NameNode<br>slave1、slave2上有几下2个进程：<br>2296 DataNode<br>2398 NodeManager<br><br>hadoop-2.6.0/sbin/stop-dfs.sh<br>hadoop-2.6.0/sbin/stop-yarn.sh<br></code></pre></td></tr></table></figure><p>或打开浏览器访问：hdfs管理界面: <a href="http://master:50070/">http://master:50070</a></p><p>yarn的管理界面: <a href="http://master:8088/">http://master:8088/</a></p><p>查看hadoop状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfsadmin -report //查看hdfs的状态报告<br><br>yarn  node -list   //查看yarn的基本信息<br><br>Secondary// TODO<br>NameNode 元数据<br>DataNode 数据块<br></code></pre></td></tr></table></figure><hr><h2 id="HDFS文件系统"><a href="#HDFS文件系统" class="headerlink" title="HDFS文件系统"></a>HDFS文件系统</h2><p>hadoop实现了一个分布式文件系统HDFS(Hadoop Distributed File System)</p><img src="HDFS架构.png" /><p>元数据：用于描述数据的数据。</p><p>NameNode 主服务器，用来管理整个文件系统的命名空间和元数据，以及处理来自外界的文件访问请求。整个集群中只有一个。含有：</p><ol><li>命名空间：整个分布式文件系统的目录结构</li><li>数据块与文件名的映射表</li><li>每个数据块副本的位置信息(每个数据块默认3个副本)</li></ol><p>元数据保存在NameNode的内存当中(1G内存可存放1000000个块对应的元数据信息，缺省每块64M计算可对应64T实际数据)</p><p>DataNode通过心跳包(Heartbeats)与NameNode通讯</p><p>HA(High Available)高可用</p><p>DataNode 用来实际存储和管理文件的数据块</p><p>数据块-64M(128M)数据块+备份公用一个ID</p><p>主从架构：1个NameNode对应n个DataNode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>client-java app -&gt; data NameNode(客户端向NameNode发起请求)<br>client-sid datanode-&gt; datanode -&gt; r/w -&gt; dfs file(NameNode返回对应的DataNode给客户端让客户端来通过DataNode进行访问)<br>                   -&gt; namenode(向NameNode汇报情况)<br></code></pre></td></tr></table></figure><h3 id="JVM从HDFS读取文件流程"><a href="#JVM从HDFS读取文件流程" class="headerlink" title="JVM从HDFS读取文件流程"></a>JVM从HDFS读取文件流程</h3><img src="HDFS数据的读取过程.png" /><p>client会从距离最近的机子上读取</p><h4 id="HDFS文件存储的组织与读写："><a href="#HDFS文件存储的组织与读写：" class="headerlink" title="HDFS文件存储的组织与读写："></a>HDFS文件存储的组织与读写：</h4><p>数据写入</p><ol><li>客户端调用FileSystem 实例的create 方法，创建文件。NameNode 通过一些检查，比如文件是否存在，客户端是否拥有创建权限等;通过检查之后，在NameNode 添加文件信息。注意，因为此时文件没有数据，所以NameNode 上也没有文件数据块的信息。</li><li>创建结束之后， HDFS 会返回一个输出流DFSDataOutputStream 给客户端。</li><li>客户端调用输出流DFSDataOutputStream 的write 方法向HDFS 中对应的文件写入数据。</li><li>数据首先会被分包，这些分包会写人一个输出流的内部队列Data 队列中，接收完数据分包，输出流DFSDataOutputStream 会向NameNode 申请保存文件和副本数据块的若干个DataNode ， 这若干个DataNode 会形成一个数据传输管道。DFSDataOutputStream 将数据传输给距离上最短的DataNode ，这个DataNode 接收到数据包之后会传给下一个DataNode 。数据在各DataNode之间通过管道流动，而不是全部由输出流分发，以减少传输开销。</li><li>因为各DataNode 位于不同机器上，数据需要通过网络发送，所以，为了保证所有DataNode 的数据都是准确的，接收到数据的DataNode 要向发送者发送确认包(ACK Packet ) 。对于某个数据块，只有当DFSDataOutputStream 收到了所有DataNode 的正确ACK. 才能确认传输结束。DFSDataOutputStream 内部专门维护了一个等待ACK 队列，这一队列保存已经进入管道传输数据、但是并未被完全确认的数据包。</li><li>不断执行第3 - 5 步直到数据全部写完，客户端调用close 关闭文件。</li><li>DFSDataInputStream 继续等待直到所有数据写人完毕并被确认，调用complete 方法通知NameNode 文件写入完成。NameNode 接收到complete 消息之后，等待相应数量的副本写入完毕后，告知客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看文件<br>hadoop fs -<span class="hljs-built_in">cat</span> /output/part-00000<br>查看hadoop文件系统<br>hadoop fs -<span class="hljs-built_in">ls</span> /<br>hadoop fs -<span class="hljs-built_in">ls</span> -R /output<br>hadoop fs -<span class="hljs-built_in">ls</span> /output<br>创建文件夹<br>hadoop fs -<span class="hljs-built_in">mkdir</span> /tmp<br>hadoop fs -<span class="hljs-built_in">mkdir</span> /input<br>hadoop fs -<span class="hljs-built_in">mkdir</span> /output<br>将文件放到hadoop文件系统-put 当前路径 /home/master/input 放到的路径<br>hadoop fs -put /home/master/input/* /input<br>hadoop fs -get /output output<br><br>hadoop fs -<span class="hljs-built_in">rm</span> -R /input<br>hadoop fs -<span class="hljs-built_in">rm</span> -r /output/output<br>hadoop fs -<span class="hljs-built_in">mv</span> /output/output/part-r-00000 /output/part-r-00000<br></code></pre></td></tr></table></figure><p>运行例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop jar hadoop-2.6.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar grep /input /output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Hadoop-IO"><a href="#Hadoop-IO" class="headerlink" title="Hadoop IO"></a>Hadoop IO</h3><p>HDFS数据完整性</p><p>校验和+后台进程</p><p>文件数据结构-解决大量小文件</p><p>SequenceFile：用流来读写</p><p>MapFile</p><h2 id="MapReduce-1"><a href="#MapReduce-1" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>Map&#x2F;Reduce是一个用于大规模数据处理的分布式计算模型，它最初是由Google工程师设计并实现的，Google已经将它完整的MapReduce论文公开发布了。其中对它的定义是，Map&#x2F;Reduce是一个编程模型（programming model），是一个用于处理和生成大规模数据集（processing and generating large data sets）的相关的实现。用户定义一个map函数来处理一个key&#x2F;value对以生成一批中间的key&#x2F;value对，再定义一个reduce函数将所有这些中间的有着相同key的values合并起来。很多现实世界中的任务都可用这个模型来表达。</p><img src="how-hadoop-runs-a-mapreduce-kob.jpg" /><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><img src="hadoop-mapreduce-framework-architecture.jpg" /><p>Mapper、Reduce</p><blockquote><p>运行于Hadoop的MapReduce应用程序最基本的组成部分包括一个Mapper和一个Reducer类，以及一个创建JobConf的执行程序，在一些应用中还可以包括一个Combiner类，它实际也是Reducer的实现。</p></blockquote><p>JobTracker、TaskTracker</p><blockquote><p>它们都是由一个master服务JobTracker和多个运行于多个节点的slaver服务TaskTracker两个类提供的服务调度的。master负责调度job的每一个子任务task运行于slave上，并监控它们，如果发现有失败的task就重新运行它，slave则负责直接执行每一个task。TaskTracker都需要运行在HDFS的DataNode上，而JobTracker则不需要，一般情况应该把JobTracker部署在单独的机器上。</p></blockquote><p>JobClient</p><blockquote><p>每一个job都会在用户端通过JobClient类将应用程序以及配置参数Configuration打包成jar文件存储在HDFS，并把路径提交到JobTracker的master服务，然后由master创建每一个Task（即MapTask和ReduceTask）将它们分发到各个TaskTracker服务中去执行。</p></blockquote><p>JobInProgress</p><blockquote><p>JobClient提交job后，JobTracker会创建一个JobInProgress来跟踪和调度这个job，并把它添加到job队列里。JobInProgress会根据提交的job jar中定义的输入数据集（已分解成FileSplit）创建对应的一批TaskInProgress用于监控和调度MapTask，同时在创建指定数目的TaskInProgress用于监控和调度ReduceTask，缺省为1个ReduceTask。</p></blockquote><p>TaskInProgress</p><blockquote><p>JobTracker启动任务时通过每一个TaskInProgress来launchTask，这时会把Task对象（即MapTask和ReduceTask）序列化写入相应的TaskTracker服务中，TaskTracker收到后会创建对应的TaskInProgress（此TaskInProgress实现非JobTracker中使用的TaskInProgress，作用类似）用于监控和调度该Task。启动具体的Task进程是通过TaskInProgress管理的TaskRunner对象来运行的。TaskRunner会自动装载job jar，并设置好环境变量后启动一个独立的java child进程来执行Task，即MapTask或者ReduceTask，但它们不一定运行在同一个TaskTracker中。</p></blockquote><p>MapTask、ReduceTask</p><blockquote><p>一个完整的job会自动依次执行Mapper、Combiner（在JobConf指定了Combiner时执行）和Reducer，其中Mapper和Combiner是由MapTask调用执行，Reducer则由ReduceTask调用，Combiner实际也是Reducer接口类的实现。Mapper会根据job jar中定义的输入数据集按&lt;key1,value1&gt;对读入，处理完成生成临时的&lt;key2,value2&gt;对，如果定义了Combiner，MapTask会在Mapper完成调用该Combiner将相同key的值做合并处理，以减少输出结果集。MapTask的任务全完成即交给ReduceTask进程调用Reducer处理，生成最终结果&lt;key3,value3&gt;对。这个过程在下一部分再详细介绍。</p></blockquote><img src="mapreduce运行机制.jpg" /><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="单词统计案例"><a href="#单词统计案例" class="headerlink" title="单词统计案例"></a>单词统计案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Mapper&lt;LongWritable, Text, Text, IntWritable&gt;<br>public void map(LongWritable k1, Text v1, Context context)<br>输入LongWritable k1, Text v1(LongWritable, Text)：序号,行<br>处理：从行中split出每个单词，并将每个单词的值设为1<br>输出Context context(Text, IntWritable)：单词,所有该单词的值的集合(数组)<br><br>Reducer&lt;Text, IntWritable, Text, IntWritable&gt;<br>public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)<br>输入Text key, Iterable&lt;IntWritable&gt; values(Text, IntWritable)：单词,所有该单词的值的集合(数组)<br>处理：使用迭代器Iterator来迭代每个单词的值的数组并将数组中的每个元素相加，和作为该单词新的值<br>输出Context context(Text, IntWritable)：单词,单词出现次数<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mypro1;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;   <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWordCount</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;&#123;  <br><span class="hljs-comment">// 输入LongWritable k1, Text v1(LongWritable, Text)：序号,行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable k1, Text v1, Context context)</span> <br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br><span class="hljs-comment">// 处理：从行中split出每个单词，并将每个单词的值设为1</span><br>String[]  lines= v1.toString().split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br><span class="hljs-keyword">for</span>(String word: lines)&#123;<br><span class="hljs-comment">// 输出Context context(Text, IntWritable)：单词,所有该单词的值的集合(数组)</span><br>context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(word), <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(<span class="hljs-number">1</span>));<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt;&#123;<br><span class="hljs-comment">// 输入Text key, Iterable&lt;IntWritable&gt; values(Text, IntWritable)：单词,所有该单词的值的集合(数组)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span><br> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br><span class="hljs-comment">// 处理：使用迭代器Iterator来迭代每个单词的值的数组并将数组中的每个元素相加，和作为该单词新的值</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>Iterator&lt;IntWritable&gt;  it = values.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>sum+= it.next().get();<br>&#125;<br><span class="hljs-comment">// 输出Context context(Text, IntWritable)：单词,单词出现次数</span><br>context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(sum));    <br> <br>System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>);<br>&#125;<br>    <br>&#125;<br><br><span class="hljs-comment">// 定义输入文件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String INPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/input/hdfs-site.xml&quot;</span>;<br><span class="hljs-comment">// 定义输出结果到目录</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String OUTPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/output/c/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 加载配置文件</span><br>Configuration  conf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>FileSystem  fs=FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH),conf);<br> <span class="hljs-comment">// 若输出目录已存在则删除</span><br><span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br><span class="hljs-comment">// 开启一个作业</span><br><span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf,<span class="hljs-string">&quot;myjob&quot;</span>);<br><span class="hljs-comment">// 设置作业jar包</span><br>job.setJarByClass(MyWordCount.class);<br><span class="hljs-comment">// 设置作业Mapper类</span><br>job.setMapperClass(MyMapper.class);<br><span class="hljs-comment">// 设置作业Reducer类</span><br>job.setReducerClass(MyReduce.class);<br><br><span class="hljs-comment">// Mapper&lt;LongWritable, Text, MyK2, LongWritable&gt;定义Mapper泛型输出类</span><br><br><span class="hljs-comment">// Reducer&lt;Text, IntWritable, Text, IntWritable&gt;定义Reducer泛型输出类，因输入与输出相同可省略</span><br>job.setOutputKeyClass(Text.class);<br>job.setOutputValueClass(IntWritable.class);<br><br><span class="hljs-comment">// 使用文件读取系统读取文件到作业</span><br>FileInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH));<br><span class="hljs-comment">// 使用文件读取系统输出作业结果</span><br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 5<br>2 1<br>2 2<br>9 3<br>1 8<br>4 5<br>6 2<br>0 7<br><br>Mapper&lt;LongWritable, Text, MyK2, LongWritable&gt;<br>public void map(LongWritable k1, Text v1, Context context)<br>输入LongWritable k1, Text v1(LongWritable, Text)：序号,行<br>处理<br>输出Context context(MyK2, LongWritable)：两个数,后面那个数(与排序无关,为空都可以)<br><br>Reducer&lt;MyK2, LongWritable,LongWritable, LongWritable&gt;<br>public void reduce(MyK2 myk2, Iterable&lt;LongWritable&gt; v2s,Context context)<br>输入MyK2 myk2, Iterable&lt;LongWritable&gt; v2s(MyK2, LongWritable)：两个数，后面那个数(与排序无关,为空都可以)<br>处理<br>输出Context context(LongWritable, LongWritable)：第一个数,第二个数<br><br>07<br>18<br>21<br>22<br>45<br>62<br>75<br>93<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> demo;<br><br><span class="hljs-keyword">import</span> java.io.DataInput;<br><span class="hljs-keyword">import</span> java.io.DataOutput;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.WritableComparable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;   <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyK2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WritableComparable</span>&lt;MyK2&gt;&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> myk2;  <br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> myv2;  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyK2</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// TODO Auto-generated constructor stub  </span><br> &#125;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyK2</span><span class="hljs-params">(<span class="hljs-type">long</span> myk2, <span class="hljs-type">long</span> myv2)</span> &#123;  <br>     <span class="hljs-built_in">this</span>.myk2 = myk2;  <br>     <span class="hljs-built_in">this</span>.myv2 = myv2;  <br> &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFields</span><span class="hljs-params">(DataInput in)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-built_in">this</span>.myk2=in.readLong();  <br>        <span class="hljs-built_in">this</span>.myv2=in.readLong();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(DataOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>out.writeLong(myk2);  <br>        out.writeLong(myv2);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyK2 my)</span> &#123;<br><span class="hljs-type">long</span> temp=<span class="hljs-built_in">this</span>.myk2-my.myk2; <br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) temp; <br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.myv2-my.myv2);<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, MyK2, LongWritable&gt;&#123;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable k1, Text v1, Context context)</span> <br> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException<br> &#123;<br>String[]  lines= v1.toString().split(<span class="hljs-string">&quot;\\s&quot;</span>);<br><span class="hljs-type">MyK2</span> <span class="hljs-variable">myK2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyK2</span>(Long.parseLong(lines[<span class="hljs-number">0</span>]), Long.parseLong(lines[<span class="hljs-number">1</span>]));<br>context.write(myK2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(Long.parseLong(lines[<span class="hljs-number">0</span>])));<br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span>);<br> &#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;MyK2, LongWritable,LongWritable, LongWritable&gt;&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(MyK2 myk2, Iterable&lt;LongWritable&gt; v2s,Context context)</span> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException<br> &#123;<br> context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(myk2.myk2), <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongWritable</span>(myk2.myv2));    <br> System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>);<br> &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String INPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/input/num&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String OUTPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/output/num/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>Configuration  conf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>FileSystem  fs=FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH),conf);<br> <br><span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>Job  job=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf,<span class="hljs-string">&quot;myjob&quot;</span>);<br><br>job.setJarByClass(Sort.class);<br>job.setMapperClass(MyMapper.class);<br>job.setReducerClass(MyReduce.class);<br><br><span class="hljs-comment">// Mapper&lt;LongWritable, Text, MyK2, LongWritable&gt;定义Mapper泛型输出类</span><br>job.setMapOutputKeyClass(MyK2.class);<br>job.setMapOutputValueClass(LongWritable.class);<br><span class="hljs-comment">// Reducer&lt;MyK2, LongWritable,LongWritable, LongWritable&gt;定义Reducer泛型输出类</span><br>job.setOutputKeyClass(LongWritable.class);<br>job.setOutputValueClass(LongWritable.class);<br><br>FileInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH));<br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="图案例"><a href="#图案例" class="headerlink" title="图案例"></a>图案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：<br>childparent <br>TomLucy<br>TomJack<br>JoneLucy<br>JoneJack<br>LucyMary<br>LucyBen<br>Jack Alice<br>JackJesse<br>TerryAlice<br>TerryJesse<br>PhilipTerry<br>PhilipAlma<br>MarkTerry<br>MarkAlma<br>需求出输入中的所有的孙子与祖父母<br><br><br>Mapper&lt;LongWritable, Text, Text, Text&gt;<br>public void map(LongWritable k1, Text v1, Context context)<br>输入LongWritable k1, Text v1(LongWritable, Text)：序号,行<br>处理：读取行里的数据split，并以关系形式保存(以TomLucy为例)：<br>Tom,1,Tom,Lucy<br>Tom,2,Lucy,Tom<br>输出Context context(Text, Text)：人名，这个人与其他人的关系(数组)<br><br>Reducer&lt;Text, Text, Text, Text&gt;<br>public void reduce(Text key, Iterable&lt;Text&gt; values, Context context)<br>输入Text key, Iterable&lt;Text&gt; values(Text, Text)：人名，这个人与其他人的关系(数组)<br>处理：从数组中读出关系并将与该人有关的符合条件的人加入临时数组并输出<br>输出Context context(Text, Text)：孙子，祖父母<br><br>JoneAlice<br>JoneJesse<br>TomAlice<br>TomJesse<br>JoneMary<br>JoneBen<br>TomMary<br>TomBen<br>MarkAlice<br>MarkJesse<br>PhilipAlice<br>PhilipJesse<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mr;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem ;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.NullWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper.Context;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;   <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGL</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGLMapper</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt;&#123;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable k1, Text v1, Context context)</span> <br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br> <br><span class="hljs-comment">//  1   2  file   tab  ,</span><br>String[]  lines = v1.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br> <br><span class="hljs-keyword">if</span>(lines.length != <span class="hljs-number">2</span> || lines[<span class="hljs-number">0</span>].trim().equals(<span class="hljs-string">&quot;child&quot;</span>))<br><span class="hljs-keyword">return</span>;   <span class="hljs-comment">//child  parent</span><br><br><br>String word1=lines[<span class="hljs-number">0</span>].trim();  <span class="hljs-comment">//  tom</span><br>String word2=lines[<span class="hljs-number">1</span>].trim();  <span class="hljs-comment">//  lucy</span><br><br><br>context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(word1), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-string">&quot;,&quot;</span>+word1+<span class="hljs-string">&quot;,&quot;</span>+word2));<br>context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(word2), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;2&quot;</span>+<span class="hljs-string">&quot;,&quot;</span>+word1+<span class="hljs-string">&quot;,&quot;</span>+word2));<br>    System.out.println(<span class="hljs-string">&quot;map......&quot;</span>+word1+<span class="hljs-string">&quot;-&quot;</span>+word2);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyGLReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, Text, Text, Text&gt;&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* lucy   2+tom+lucy</span><br><span class="hljs-comment">* lucy   1+lucy+mary</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 2--&gt;split[1]  tom</span><br><span class="hljs-comment">* 1--&gt;split[2]  mary</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* k3=tom  v3=mary</span><br><span class="hljs-comment">* */</span><br>List&lt;String&gt;  grandch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>List&lt;String&gt;  grandpa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br> <br>Iterator&lt;Text&gt;  it=values.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>String  lines= it.next().toString();   <span class="hljs-comment">//2+tom+lucy</span><br>String[] words=lines.split(<span class="hljs-string">&quot;,&quot;</span>);      <span class="hljs-comment">//[&quot;2&quot;,&quot;tom&quot;,&quot;lucy&quot;]</span><br><span class="hljs-keyword">if</span>(words[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;<br>grandpa.add(words[<span class="hljs-number">2</span>]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(words[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;2&quot;</span>))&#123;<br>grandch.add(words[<span class="hljs-number">1</span>]);<br><br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span>;<br><br><br>&#125;<br> <br><span class="hljs-keyword">for</span>(String ch:grandch)<br><span class="hljs-keyword">for</span>(String pa:grandpa)&#123;<br>            context.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(ch), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(pa)); <br>            System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>+ch+<span class="hljs-string">&quot; - &quot;</span>+pa);<br>&#125;<br> <br>System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span>);<br>&#125;<br> <br>       <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(Context context)</span> <span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException&#123;<br> <br>       <br> <br> <br>&#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String INPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/input/gl.dat&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String OUTPUT_PATH=<span class="hljs-string">&quot;hdfs://master:9000/output/c/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>Configuration  conf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>FileSystem  fs=FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH),conf);<br> <br><span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>Job  job=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf,<span class="hljs-string">&quot;myjob&quot;</span>);<br><br>job.setJarByClass(MyGL.class);<br>job.setMapperClass(MyGLMapper.class);<br>job.setReducerClass(MyGLReduce.class);<br> <br> <br>job.setOutputKeyClass(Text.class);<br>job.setOutputValueClass(Text.class);<br><br> <br><br>FileInputFormat.addInputPath(job,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH));<br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><!--TODO:http://langyu.iteye.com/blog/992916--><!--TODO:http://www.cnblogs.com/zhangchaoyang/articles/2648815.html--><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>矩阵乘法公式：</p><img src="矩阵乘法公式.png" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">矩阵A(4*3)(i*n)<br>1,2,3<br>4,5,0<br>7,8,9<br>10,11,12<br><br>矩阵B(3*2)(n*j)<br>10,15<br>0,2<br>11,9<br><br>根据矩阵乘法的定义：矩阵A的列数=矩阵B的行数，即矩阵A和矩阵B都有相同的n<br>矩阵乘法的结果是产生(i*j)的矩阵C<br><br>矩阵C(4*2)(i*j)<br>43,46<br>40,70<br>169,202<br>232,280<br><br>1*10+2*0+3*11=43<br>1*15+2*2+3*9=46<br><br>计算每个矩阵C中的元素(i,j)都需要矩阵A的(i,r)与矩阵B的(r,j)相乘再加上下一个r取值[1,n]<br>接下来看看进行一个矩阵计算需要哪些信息：<br>因为每次计算r都是从1到n，所以r的值不需要保存进map，<br>需要：计算结果是在C的哪里即(i,j)，A矩阵对应的值，B矩阵对应的值，这个值来自哪个矩阵(A还是B)<br><br>那么如何唯一标识矩阵C的一个元素呢？使用矩阵C的坐标，将C的坐标(i,j)作为key<br>(哪个矩阵,对应的r,矩阵的值)作为value，这样就可以保存进行矩阵计算的全部信息了<br><br>分类讨论：<br>(i,j为计算C的第(i,j)个元素的值，r取值[1,n])<br>对于矩阵A的值：<br>key(i,j) value(a,A的列即r,A[i,r])<br>对于矩阵B的值：<br>key(i,j) value(b,B的列即r,B[r,j])<br><br>分类讨论的计算过程见下图<br></code></pre></td></tr></table></figure><img src="矩阵乘法.png" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> demo;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.LongWritable;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.Text;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileSplit;<br><span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MatrixProdect</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt; &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<span class="hljs-comment">// 矩阵A的行数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">colNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">// 矩阵B的列数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">rowIndexA</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 矩阵A，当前在第几行</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">rowIndexB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 矩阵B，当前在第几行</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text value, Context context)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException &#123;<br><br><span class="hljs-type">FileSplit</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> (FileSplit) context.getInputSplit();<br><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> fs.getPath().getName();<br><br>String[] tokens = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">// 读进一行数据</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(fileName)) &#123; <span class="hljs-comment">// 通过文件名判断是矩阵A还是矩阵B</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= colNum; j++) &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(rowIndexA + <span class="hljs-string">&quot;,&quot;</span> + j);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; tokens.length; r++) &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;a,&quot;</span> + (r + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;,&quot;</span> + tokens[r]);<br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span> + fileName + <span class="hljs-string">&quot;(&quot;</span> + k + <span class="hljs-string">&quot;)&quot;</span> + v);<br>context.write(k, v);<br>&#125;<br>&#125;<br>rowIndexA++;<span class="hljs-comment">// 每执行一次map方法，扫描矩阵的下一行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;b&quot;</span>.equals(fileName)) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= rowNum; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; tokens.length; r++) &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(i + <span class="hljs-string">&quot;,&quot;</span> + (r + <span class="hljs-number">1</span>));<br><span class="hljs-type">Text</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;b,&quot;</span> + rowIndexB + <span class="hljs-string">&quot;,&quot;</span> + tokens[r]);<br>System.out.println(<span class="hljs-string">&quot;map......&quot;</span> + fileName + <span class="hljs-string">&quot;(&quot;</span> + k + <span class="hljs-string">&quot;)&quot;</span> + v);<br>context.write(k, v);<br>&#125;<br>&#125;<br>rowIndexB++;<span class="hljs-comment">// 每执行一次map方法，扫描矩阵的下一行</span><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, Text, Text, IntWritable&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span><br><span class="hljs-keyword">throws</span> java.io.IOException, java.lang.InterruptedException &#123;<br><br>Map&lt;String, String&gt; mapA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>Map&lt;String, String&gt; mapB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br><br><span class="hljs-comment">// 根据矩阵来分类</span><br><span class="hljs-keyword">for</span> (Text value : values) &#123;<br>String[] val = value.toString().split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(val[<span class="hljs-number">0</span>])) &#123;<br>mapA.put(val[<span class="hljs-number">1</span>], val[<span class="hljs-number">2</span>]);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;b&quot;</span>.equals(val[<span class="hljs-number">0</span>])) &#123;<br>mapB.put(val[<span class="hljs-number">1</span>], val[<span class="hljs-number">2</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Iterator&lt;String&gt; mKeys = mapA.keySet().iterator();<br><span class="hljs-keyword">while</span> (mKeys.hasNext()) &#123; <span class="hljs-comment">// 取相同的r值的数相乘</span><br><span class="hljs-type">String</span> <span class="hljs-variable">mkey</span> <span class="hljs-operator">=</span> mKeys.next();<br><span class="hljs-keyword">if</span> (mapB.get(mkey) == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>result += Integer.parseInt(mapA.get(mkey)) * Integer.parseInt(mapB.get(mkey));<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;reduce......&quot;</span> + <span class="hljs-string">&quot;(&quot;</span> + key + <span class="hljs-string">&quot;)&quot;</span> + result);<br>context.write(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntWritable</span>(result));<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">INPUT_PATH_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://master:9000/input/a&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">INPUT_PATH_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://master:9000/input/b&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://master:9000/output/matrix/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br><span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(OUTPUT_PATH), conf);<br><br><span class="hljs-keyword">if</span> (fs.exists(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH)))<br>fs.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br><span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Job</span>(conf, <span class="hljs-string">&quot;myjob&quot;</span>);<br><br>job.setJarByClass(MatrixProdect.class);<br>job.setMapperClass(MyMapper.class);<br>job.setReducerClass(MyReduce.class);<br><br>job.setMapOutputKeyClass(Text.class);<br>job.setMapOutputValueClass(Text.class);<br><br>job.setOutputKeyClass(Text.class);<br>job.setOutputValueClass(IntWritable.class);<br><br>FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH_A));<br>FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(INPUT_PATH_B));<br>FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(OUTPUT_PATH));<br><br>job.waitForCompletion(<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>计算方法与上面一样，只是矩阵的存储结构不一样。省略了值为0的元素，对于较大且稀疏的矩阵所占存储空间较小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">行,列,值<br></code></pre></td></tr></table></figure><img src="矩阵乘法2.png" /><!--<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br></code></pre></td></tr></table></figure><p>–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;h3 id=&quot;Hadoop：&quot;&gt;&lt;a href=&quot;#Hadoop：&quot; class=&quot;headerlink&quot; title=&quot;Had</summary>
      
    
    
    
    <category term="Big Data" scheme="http://yoursite.com/categories/Big-Data/"/>
    
    
    <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
    <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
    <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Hive</title>
    <link href="http://yoursite.com/2022/08/17/BigData/Hive/"/>
    <id>http://yoursite.com/2022/08/17/BigData/Hive/</id>
    <published>2022-08-17T12:09:47.000Z</published>
    <updated>2023-03-26T08:08:51.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装hive"><a href="#安装hive" class="headerlink" title="安装hive"></a>安装hive</h2><p>hive–&gt;hql–&gt;hive引擎–&gt;mapreduce Task</p><h3 id="配置mysql数据库"><a href="#配置mysql数据库" class="headerlink" title="配置mysql数据库"></a>配置mysql数据库</h3><p>前置条件：安装数据库mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install mysql-server mysql-client<br></code></pre></td></tr></table></figure><p>启动停止mysql服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo start mysql<br>sudo stop mysql  <br></code></pre></td></tr></table></figure><p>取消本地监听</p><p>取消本地监听需要修改 my.cnf 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$sudo</span> vim /etc/mysql/my.cnf<br>// 找到如下内容，并注释<br><span class="hljs-comment">#bind-address = 127.0.0.1</span><br></code></pre></td></tr></table></figure><p>修改了配置文件后需要重启 mysqld 才能使这些修改生效。</p><p>检查 mysqld 进程是否已经开启： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$pgrep</span> mysqld<br></code></pre></td></tr></table></figure><p>如果进程开启，这个命令将会返回该进程的 id </p><p>root登录mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure><p>下载<a href="apache-hive-1.1.0-bin.tar.gz">apache-hive-1.1.0</a></p><p>解压到&#x2F;home&#x2F;master&#x2F;apache-hive-1.1.0</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/profile<br><br><span class="hljs-comment">#set hive environment</span><br>HIVE_HOME=/home/master/apache-hive-1.1.0<br>PATH=<span class="hljs-variable">$HIVE_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br>CLASSPATH=<span class="hljs-variable">$CLASSPATH</span>:<span class="hljs-variable">$HIVE_HOME</span>/lib<br><span class="hljs-built_in">export</span> HIVE_HOME<br><span class="hljs-built_in">export</span> PATH<br><span class="hljs-built_in">export</span> CLASSPATH<br><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>配置hive-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/master/apache-hive-1.1.0/conf<br><br>gedit hive-env.sh<br><br>HADOOP_HOME=/home/master/hadoop-2.6.0<br><br><span class="hljs-built_in">export</span> HIVE_CONF_DIR=/home/master/hadoop-2.6.0/conf<br></code></pre></td></tr></table></figure><p>配置hive-site.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> hive-default.xml.template hive-site.xml<br><br>sudo gedit hive-site.xml<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> /home/master/hive/warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>location of default database for the warehouse<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.exec.scratchdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> /home/master/hive/scratchdir<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Scratch space for Hive jobs<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.querylog.location<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span><br>    Location of Hive run time structured log file<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc:mysql://master:3306/hive_metadata?createDatabaseIfNotExist=true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>username to use against metastore database<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>password to use against metastore database<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.exec.local.scratchdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br>  <span class="hljs-comment">&lt;!--拼凑目录--&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/local/$&#123;system:user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Local scratch space for Hive jobs<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.downloaded.resources.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/local/$&#123;hive.session.id&#125;_resources<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Temporary local directory for added resources in theremote file system.<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.server2.logging.operation.log.location<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/master/apache-hive-1.1.0/logs/operation_logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Top leveldirectory where operation logs are stored if logging functionality isenabled<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在apache-hive-1.1.0目录下创建local目录mkdir local</p><h3 id="配置log4j"><a href="#配置log4j" class="headerlink" title="配置log4j"></a>配置log4j</h3><p>创建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> hive-exec-log4j.properties.template  hive-exec-log4j.properties<br><span class="hljs-built_in">cp</span> hive-log4j.properties.template  hive-log4j.properties<br></code></pre></td></tr></table></figure><p>修改上面两个文件中的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit hive-exec-log4j.properties<br>sudo gedit hive-log4j.properties<br><br>hive.log.dir=/home/master/apache-hive-1.1.0/logs<br>log4j.appender.EventCounter=org.apache.hadoop.log.metrics.EventCounter<br></code></pre></td></tr></table></figure><p>注意如果没有logs目录就建立一个 执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$mkdir</span> /home/master/apache-hive-1.1.0/logs<br></code></pre></td></tr></table></figure><h3 id="添加Mysql驱动包"><a href="#添加Mysql驱动包" class="headerlink" title="添加Mysql驱动包"></a>添加Mysql驱动包</h3><ol><li><p>下载驱动包<br>本实验使用的mysql是mysql 5.6 版本，配套的jdbc是<a href="mysql-connector-java-5.1.9.jar">mysql-connector-java-5.1.24-bin.jar</a><br>这个jar在网上下载就可以了，一定要根据mysql版本选择配套的版本</p></li><li><p>添加驱动包<br>把驱动包放到 $HIVE_HOME&#x2F;lib 目录下</p></li><li><p>修改hadoop的库文件<br>在$HADOOP_HOME&#x2F;share&#x2F;hadoop&#x2F;yarn&#x2F;lib下备份jline-0.9.94.jar</p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/master/hadoop-2.6.0/share/hadoop/yarn/lib<br><span class="hljs-variable">$mv</span> jline-0.9.94.jar jline-0.9.94.jar.bak<br></code></pre></td></tr></table></figure></li><li><p>Copy高版本的jline</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$cp</span> <span class="hljs-variable">$HIVE_HOME</span>/lib/jline-2.12.jar <span class="hljs-variable">$HADOOP_HOME</span>/share/hadoop/yarn/lib<br><span class="hljs-built_in">cp</span> /home/master/apache-hive-1.1.0/lib/jline-2.12.jar /home/master/hadoop-2.6.0/share/hadoop/yarn/lib<br></code></pre></td></tr></table></figure></li></ol><p>验证配置是否成功</p><p>启动hive</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hive<br></code></pre></td></tr></table></figure><p>没有报错且显示hinve&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">create table <span class="hljs-built_in">test</span>(<span class="hljs-built_in">id</span> int, name String);<br>show tables;<br>insert into <span class="hljs-built_in">test</span> values(0, <span class="hljs-string">&#x27;Sombra&#x27;</span>);<br>select * from <span class="hljs-built_in">test</span>;<br></code></pre></td></tr></table></figure><h3 id="从文件导入数据"><a href="#从文件导入数据" class="headerlink" title="从文件导入数据"></a>从文件导入数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">create table shakespaeare(child string, parent string)<br>row format delimited fields terminated by <span class="hljs-string">&#x27;,&#x27;</span><br>stored as textfile;<br><br>load data inpath <span class="hljs-string">&quot;hdfs://master:9000/input/gl.dat&quot;</span><br>into table shakespaeare;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装hive&quot;&gt;&lt;a href=&quot;#安装hive&quot; class=&quot;headerlink&quot; title=&quot;安装hive&quot;&gt;&lt;/a&gt;安装hive&lt;/h2&gt;&lt;p&gt;hive–&amp;gt;hql–&amp;gt;hive引擎–&amp;gt;mapreduce Task&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="Big Data" scheme="http://yoursite.com/categories/Big-Data/"/>
    
    
    <category term="Hive" scheme="http://yoursite.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>HDFS</title>
    <link href="http://yoursite.com/2022/08/13/BigData/HDFS/"/>
    <id>http://yoursite.com/2022/08/13/BigData/HDFS/</id>
    <published>2022-08-13T09:19:43.000Z</published>
    <updated>2023-03-26T08:08:54.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HDFS启动与关闭"><a href="#HDFS启动与关闭" class="headerlink" title="HDFS启动与关闭"></a>HDFS启动与关闭</h2><p>HDFS 和普通的硬盘上的文件系统不一样，是通过Java 虚拟机运行在整个集群当中的，<br>所以当Hadoop 程序写好之后，需要启动HDFS 文件系统，才能运行。</p><p>HDFS启动过程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/start-dfs.sh<br></code></pre></td></tr></table></figure><p>这一脚本会启动NameNode ， 然后根据conf&#x2F;slaves 中的记录逐个启动DataNode ，最后<br>根据conf&#x2F;masters 中记录的Secondary NameNode 地址启动SecondaryNameNode 。</p><p>HDFS 关闭过程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/stop-dfs.sh<br></code></pre></td></tr></table></figure><p>这一脚本的运行过程正好是bin&#x2F;start-dfs.sh 的逆过程，关闭Secondary NameNode ，然后<br>是每个DataNode ，最后是NameNode自身。</p><h2 id="HDFS命令基本格式"><a href="#HDFS命令基本格式" class="headerlink" title="HDFS命令基本格式:"></a>HDFS命令基本格式:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -cmd &lt; args &gt;<br></code></pre></td></tr></table></figure><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span>  /<br></code></pre></td></tr></table></figure><p>列出hdfs文件系统根目录下的目录和文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span> -R /<br></code></pre></td></tr></table></figure><p>列出hdfs文件系统所有的目录和文件</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a><code>put</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put &lt; <span class="hljs-built_in">local</span> file &gt; &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>hdfs file的父目录一定要存在，否则命令不会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put  &lt; <span class="hljs-built_in">local</span> file or <span class="hljs-built_in">dir</span> &gt;...&lt; hdfs <span class="hljs-built_in">dir</span> &gt;<br></code></pre></td></tr></table></figure><p>hdfs dir 一定要存在，否则命令不会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put - &lt; hdsf  file&gt;<br></code></pre></td></tr></table></figure><p>从键盘读取输入到hdfs file中，按Ctrl+D结束输入，hdfs file不能存在，否则命令不会执行</p><h3 id="moveFromLocal"><a href="#moveFromLocal" class="headerlink" title="moveFromLocal"></a><code>moveFromLocal</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -moveFromLocal  &lt; <span class="hljs-built_in">local</span> src &gt; ... &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>与put相类似，命令执行后源文件 local src 被删除，也可以从从键盘读取输入到hdfs file中</p><h3 id="copyFromLocal"><a href="#copyFromLocal" class="headerlink" title="copyFromLocal"></a><code>copyFromLocal</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -copyFromLocal  &lt; <span class="hljs-built_in">local</span> src &gt; ... &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>与put相类似，也可以从从键盘读取输入到hdfs file中</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -get &lt; hdfs file &gt; &lt; <span class="hljs-built_in">local</span> file or <span class="hljs-built_in">dir</span>&gt;<br></code></pre></td></tr></table></figure><p>local file不能和 hdfs file名字不能相同，否则会提示文件已存在，没有重名的文件会复制到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -get &lt; hdfs file or <span class="hljs-built_in">dir</span> &gt; ... &lt; <span class="hljs-built_in">local</span>  <span class="hljs-built_in">dir</span> &gt;<br></code></pre></td></tr></table></figure><p>拷贝多个文件或目录到本地时，本地要为文件夹路径</p><p><code>注意：</code>如果用户不是root， local 路径要为用户文件夹下的路径，否则会出现权限问题，</p><h3 id="moveToLocal"><a href="#moveToLocal" class="headerlink" title="moveToLocal"></a><code>moveToLocal</code></h3><p>当前版本中还未实现此命令</p><h3 id="copyToLocal"><a href="#copyToLocal" class="headerlink" title="copyToLocal"></a><code>copyToLocal</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -copyToLocal &lt; <span class="hljs-built_in">local</span> src &gt; ... &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>与get相类似</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">rm</span> &lt; hdfs file &gt; ...<br>hadoop fs -<span class="hljs-built_in">rm</span> -r &lt; hdfs <span class="hljs-built_in">dir</span>&gt;...<br></code></pre></td></tr></table></figure><p>每次可以删除多个文件或目录</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mkdir</span> &lt; hdfs path&gt;<br></code></pre></td></tr></table></figure><p>只能一级一级的建目录，父目录不存在的话使用这个命令会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mkdir</span> -p &lt; hdfs path&gt; <br></code></pre></td></tr></table></figure><p>所创建的目录如果父目录不存在就创建该父目录</p><h3 id="getmerge"><a href="#getmerge" class="headerlink" title="getmerge"></a><code>getmerge</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -getmerge &lt; hdfs <span class="hljs-built_in">dir</span> &gt;  &lt; <span class="hljs-built_in">local</span> file &gt;<br></code></pre></td></tr></table></figure><p>将hdfs指定目录下所有文件排序后合并到local指定的<code>文件</code>中，文件不存在时会自动创建，文件存在时会覆盖里面的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -getmerge -<span class="hljs-built_in">nl</span>  &lt; hdfs <span class="hljs-built_in">dir</span> &gt;  &lt; <span class="hljs-built_in">local</span> file &gt;<br></code></pre></td></tr></table></figure><p>加上nl后，合并到local file中的hdfs文件之间会空出一行</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">cp</span>  &lt; hdfs file &gt;  &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>目标文件不能存在，否则命令不能执行，相当于给文件重命名并保存，源文件还存在</p><p>hadoop fs -cp &lt; hdfs file or dir &gt;… &lt; hdfs dir &gt;</p><p>目标文件夹要存在，否则命令不能执行</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mv</span> &lt; hdfs file &gt;  &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>目标文件不能存在，否则命令不能执行，相当于给文件重命名并保存，源文件不存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mv</span>  &lt; hdfs file or <span class="hljs-built_in">dir</span> &gt;...  &lt; hdfs <span class="hljs-built_in">dir</span> &gt;<br></code></pre></td></tr></table></figure><p>源路径有多个时，目标路径必须为目录，且必须存在。</p><p><code>注意：</code>跨文件系统的移动（local到hdfs或者反过来）都是不允许的</p><h3 id="count"><a href="#count" class="headerlink" title="count"></a><code>count</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -count &lt; hdfs path &gt;<br></code></pre></td></tr></table></figure><p>统计hdfs对应路径下的目录个数，文件个数，文件总计大小</p><p>显示为目录个数，文件个数，文件总计大小，输入路径</p><h3 id="du"><a href="#du" class="headerlink" title="du"></a><code>du</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">du</span> &lt; hdsf path&gt; <br></code></pre></td></tr></table></figure><p>显示hdfs对应路径下每个文件夹和文件的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">du</span> -s &lt; hdsf path&gt; <br></code></pre></td></tr></table></figure><p>显示hdfs对应路径下所有文件和的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">du</span> - h &lt; hdsf path&gt; <br></code></pre></td></tr></table></figure><p>显示hdfs对应路径下每个文件夹和文件的大小,文件的大小用方便阅读的形式表示，例如用64M代替67108864</p><h3 id="text"><a href="#text" class="headerlink" title="text"></a><code>text</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -text &lt; hdsf file&gt;<br></code></pre></td></tr></table></figure><p>将文本文件或某些格式的非文本文件通过文本格式输出</p><h3 id="setrep"><a href="#setrep" class="headerlink" title="setrep"></a><code>setrep</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -setrep -R 3 &lt; hdfs path &gt;<br></code></pre></td></tr></table></figure><p>改变一个文件在hdfs中的副本个数，上述命令中数字3为所设置的副本个数，-R选项可以对一个人目录下的所有目录+文件递归执行改变副本个数的操作</p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a><code>stat</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdoop fs -<span class="hljs-built_in">stat</span> [format] &lt; hdfs path &gt;<br></code></pre></td></tr></table></figure><p>返回对应路径的状态信息</p><p>[format]可选参数有：%b（文件大小），%o（Block大小），%n（文件名），%r（副本个数），%y（最后一次修改日期和时间）</p><p>可以这样书写<code>hadoop fs -stat %b%o%n &lt; hdfs path &gt;</code>，不过不建议，这样每个字符输出的结果不是太容易分清楚</p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a><code>tail</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">tail</span> &lt; hdfs file &gt;<br></code></pre></td></tr></table></figure><p>在标准输出中显示文件末尾的1KB数据</p><h3 id="archive"><a href="#archive" class="headerlink" title="archive"></a><code>archive</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop archive -archiveName name.har -p &lt; hdfs parent <span class="hljs-built_in">dir</span> &gt; &lt; src &gt;* &lt; hdfs dst &gt;<br></code></pre></td></tr></table></figure><p>命令中参数name：压缩文件名，自己任意取；&lt; hdfs parent dir &gt; ：压缩文件所在的父目录；&lt; src &gt;：要压缩的文件名；&lt; hdfs dst &gt;：压缩文件存放路径</p><p>*示例：hadoop archive -archiveName hadoop.har -p &#x2F;user 1.txt 2.txt &#x2F;des</p><p>示例中将hdfs中&#x2F;user目录下的文件1.txt，2.txt压缩成一个名叫hadoop.har的文件存放在hdfs中&#x2F;des目录下，如果1.txt，2.txt不写就是将&#x2F;user目录下所有的目录和文件压缩成一个名叫hadoop.har的文件存放在hdfs中&#x2F;des目录下</p><p>显示har的内容可以用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span> /des/hadoop.jar<br></code></pre></td></tr></table></figure><p>显示har压缩的是那些文件可以用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">ls</span> -R har:///des/hadoop.har<br></code></pre></td></tr></table></figure><p><code>注意：</code>har文件不能进行二次压缩。如果想给.har加文件，只能找到原来的文件，重新创建一个。har文件中原来文件的数据并没有变化，har文件真正的作用是减少NameNode和DataNode过多的空间浪费。</p><h3 id="balancer"><a href="#balancer" class="headerlink" title="balancer"></a><code>balancer</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs balancer<br></code></pre></td></tr></table></figure><p>如果管理员发现某些DataNode保存数据过多，某些DataNode保存数据相对较少，可以使用上述命令手动启动内部的均衡过程</p><h3 id="dfsadmin"><a href="#dfsadmin" class="headerlink" title="dfsadmin"></a><code>dfsadmin</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfsadmin -<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>管理员可以通过dfsadmin管理HDFS，用法可以通过上述命令查看</p><p>hdfs dfsadmin -report</p><p>显示文件系统的基本数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfsadmin -safemode &lt; enter | leave | get | <span class="hljs-built_in">wait</span> &gt;<br></code></pre></td></tr></table></figure><p>enter：进入安全模式；leave：离开安全模式；get：获知是否开启安全模式；</p><p>wait：等待离开安全模式</p><h3 id="distcp"><a href="#distcp" class="headerlink" title="distcp"></a><code>distcp</code></h3><p>用来在两个HDFS之间拷贝数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HDFS启动与关闭&quot;&gt;&lt;a href=&quot;#HDFS启动与关闭&quot; class=&quot;headerlink&quot; title=&quot;HDFS启动与关闭&quot;&gt;&lt;/a&gt;HDFS启动与关闭&lt;/h2&gt;&lt;p&gt;HDFS 和普通的硬盘上的文件系统不一样，是通过Java 虚拟机运行在整个集群当中的</summary>
      
    
    
    
    <category term="Big Data" scheme="http://yoursite.com/categories/Big-Data/"/>
    
    
    <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://yoursite.com/2022/07/25/Java/Java-NIO/"/>
    <id>http://yoursite.com/2022/07/25/Java/Java-NIO/</id>
    <published>2022-07-25T02:25:07.000Z</published>
    <updated>2023-03-26T08:12:23.710Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO(New IO或Non Bloking IO)是从Java1.4版本开始引入的一个新的IO API，NIO支持面向缓冲区的、基于通道的IO操作，读写文件更加高效。</p><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>IO<ul><li>面向流(Stream Oriented)：相当于水管，一个steam一个方向出水的水管</li><li>阻塞IO(Blocking IO)</li><li>无选择器</li></ul></li><li>NIO<ul><li>面向缓冲区(Buffer Oriented)：相当于铁路，一条铁路上面有一个缓冲区可以装数据然后双向运输</li><li>非阻塞IO(Non Blocking IO)</li><li>选择器(Selectors)</li></ul></li></ul><p>NIO系统的核心：通道表示打开到IO设备的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。</p><h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><ol><li>缓冲区(Buffer):在NIO中复制数据的春秋，缓冲区就是数组。</li></ol><ul><li>根据数据类型的不同可以分配对应的缓冲区，boolean类型除外</li></ul><ol start="2"><li>缓冲区存取数据的两个核心方法：</li></ol><ul><li>put()</li><li>get()</li></ul><ol start="3"><li>缓冲区四个核心属性<ol><li>int capacity(容量): 表示缓冲区中最大存储数据的容量。一旦声明不能改变。</li><li>limit: 界限，表示缓冲区中可以操作数据的大小，即limit后的数据不能进行读写</li><li>position: 位置，表示缓冲区中正在操作数据的位置，且需满足(position &lt;&#x3D; limit &lt;&#x3D; capacity)</li><li>mark: 标记，标记当前position的位置，可以通过<code>reset()</code>恢复到mark的位置</li></ol></li></ol><p>这几个属性位于<code>java.nio.Buffer</code>类里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The characteristics of Spliterators that traverse and split elements</span><br><span class="hljs-comment">     * maintained in Buffers.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SPLITERATOR_CHARACTERISTICS</span> <span class="hljs-operator">=</span><br>        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;<br><br>    <span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br></code></pre></td></tr></table></figure><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br>    <span class="hljs-comment">// 分配一个指定大小的缓冲区</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 1024</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// 写数据</span><br>    buf.put(str.getBytes());<br>    System.out.println(buf.position()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 1024</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// 切换读取数据模式</span><br>    buf.flip();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// 读数据</span><br>    <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>    buf.get(dst);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, dst.length)); <span class="hljs-comment">// abcd</span><br>    System.out.println(buf.position()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// rewind() 可重复读数据</span><br>    buf.rewind();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 5</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>    <span class="hljs-comment">// clear() 清空缓冲区，但是数据依然存在且处于被遗忘状态</span><br>    buf.clear();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 0</span><br>    System.out.println(buf.limit()); <span class="hljs-comment">// 1024</span><br>    System.out.println(buf.capacity()); <span class="hljs-comment">// 1024</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    buf.put(str.getBytes());<br>    buf.flip();<br>    <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>    buf.get(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    System.out.println(buf.position()); <span class="hljs-comment">// 2</span><br>    buf.mark();<br>    buf.get(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    System.out.println(buf.position()); <span class="hljs-comment">// 4</span><br>    buf.reset();<br>    System.out.println(buf.position()); <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>直接缓冲区与非直接缓冲区</li></ol><ul><li>非直接缓冲区：通过<code>allocate()</code>方法分配的缓冲区，缓冲区建立在JVM的内存中</li><li>直接缓冲区：通过<code>allocateDirect()</code>方法分配的直接缓冲区或者使用FileChannel的map()方法返回MappedByteBuffer对象，将缓冲区建立在物理内存中。可以提高效率</li></ul><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><p>用于源节点和目标节点间的连接，在NIO中复制缓冲区中数据的传输。Channel本身不存储数据，需要配合缓冲区使用。</p><h4 id="通道主要实现类"><a href="#通道主要实现类" class="headerlink" title="通道主要实现类"></a>通道主要实现类</h4><ul><li>java.nio.channels.CHannel<ul><li>FileChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li><li>DatagramChannel</li></ul></li></ul><h4 id="获取通道的几种方式"><a href="#获取通道的几种方式" class="headerlink" title="获取通道的几种方式"></a>获取通道的几种方式</h4><ol><li>Java针对支持通道的类提供了<code>getChannel()</code>方法用于获取对应的通道</li></ol><ul><li>本地IO<ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li></ul></li><li>网络IO<ul><li>Socket</li><li>ServerSocket</li><li>DatagramSocket</li></ul></li></ul><ol start="2"><li>JDK1.7提供的NIO.2针对各个通道提供了静态方法<code>open()</code></li><li>JDK1.7中的NIO.2的Files工具类的<code>newByteChannel()</code>方法</li></ol><h4 id="通道使用案例"><a href="#通道使用案例" class="headerlink" title="通道使用案例"></a>通道使用案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 直接缓冲区：利用通道实现本地文件复制(内存映射文件)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;1.png&quot;</span>), StandardOpenOption.READ);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;3.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);<br>    <span class="hljs-comment">// 内存映射文件</span><br>    <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">inMappedBuffer</span> <span class="hljs-operator">=</span> inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());<br>    <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">outMappedBuffer</span> <span class="hljs-operator">=</span> outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());<br>    <span class="hljs-comment">// 直接对缓冲区进行数据的读写操作</span><br>    <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inMappedBuffer.limit()];<br>    inMappedBuffer.get(dst);<br>    outMappedBuffer.put(dst);<br><br>    inChannel.close();<br>    outChannel.close();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;1.png&quot;</span>), StandardOpenOption.READ);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;3.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);<br><br>    inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);<br><br>    inChannel.close();<br>    outChannel.close();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="分散-Scatter-于聚集-Gather"><a href="#分散-Scatter-于聚集-Gather" class="headerlink" title="分散(Scatter)于聚集(Gather)"></a>分散(Scatter)于聚集(Gather)</h4><ul><li>分散读取(Scattering Reads): 将通道中的数据分散到多个缓冲区中</li><li>聚集写入(Gathering Writes): 将多个缓冲区中的数据聚集到通道中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-comment">// 获取通道</span><br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel1</span> <span class="hljs-operator">=</span> raf1.getChannel();<br>    <span class="hljs-comment">// 分配多个缓冲区</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">100</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    <span class="hljs-comment">// 分散读取</span><br>    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;<br>    fileChannel1.read(bufs);<br><br>    <span class="hljs-keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;<br>        byteBuffer.flip();<br>    &#125;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufs[<span class="hljs-number">0</span>].array(), <span class="hljs-number">0</span>, bufs[<span class="hljs-number">0</span>].limit()));<br><br>    <span class="hljs-comment">// 聚集写入</span><br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel2</span> <span class="hljs-operator">=</span> raf2.getChannel();<br>    fileChannel2.write(bufs);<br><br>    fileChannel1.close();<br>    fileChannel2.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符集-Charset"><a href="#字符集-Charset" class="headerlink" title="字符集(Charset)"></a>字符集(Charset)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CharacterCodingException &#123;<br>    <span class="hljs-type">Charset</span> <span class="hljs-variable">cs1</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>);<br>    <span class="hljs-comment">// 获取编码器与解码器</span><br>    <span class="hljs-type">CharsetEncoder</span> <span class="hljs-variable">ce</span> <span class="hljs-operator">=</span> cs1.newEncoder();<br>    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> cs1.newDecoder();<br><br>    <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">1024</span>);<br>    buffer.put(<span class="hljs-string">&quot;获取编码器与&quot;</span>);<br>    buffer.flip();<br><br>    <span class="hljs-comment">// 编码</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bBuf</span> <span class="hljs-operator">=</span> ce.encode(buffer);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">12</span>; i++) &#123;<br>        System.out.println(bBuf.get());<br>    &#125;<br><br>    <span class="hljs-comment">// 解码</span><br>    bBuf.flip();<br>    <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">cBuf</span> <span class="hljs-operator">=</span> cd.decode(bBuf);<br>    System.out.println(cBuf.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h3><p>使用NIO完成网络通信需要：</p><ol><li>通道(Channel): 负责连接<ul><li>java.nio.channels.Channel接口<ul><li>SelectableChannel<ul><li>SocketChannel</li><li>ServerSocketChannel</li><li>DatagramChannel</li><li>Pipe.SinkChannel</li><li>Pipe.SourceChannel</li></ul></li></ul></li></ul></li><li>缓冲区(Buffer): 负责数据的存取</li><li>选择器(Selector): 是SelectableChannel的多路复用器。用于监控SelectableChannel的IO状况</li></ol><h3 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h3><h4 id="使用ServerSocketChannel"><a href="#使用ServerSocketChannel" class="headerlink" title="使用ServerSocketChannel"></a>使用ServerSocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.nio;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNonBlockingNIO</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));<br>        <span class="hljs-comment">// 切换成非阻塞模式</span><br>        sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 分配缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">// 发送数据</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span>(scanner.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.next();<br>            buf.put((LocalDateTime.now().toString() + <span class="hljs-string">&quot;:&quot;</span> + str).getBytes());<br>            buf.flip();<br>            sChannel.write(buf);<br>            buf.clear();<br>        &#125;<br><br>        sChannel.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-comment">// 切换成非阻塞模式</span><br>        ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 绑定连接</span><br>        ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br>        <span class="hljs-comment">// 获取选择器</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 将通道注册到选择器，并且指定监听事件</span><br>        ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        <span class="hljs-comment">// 轮询式的获取选择器上已经准备就绪的事件</span><br>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取当前选择器中所有注册的且已就绪的选择键</span><br>            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>            <span class="hljs-comment">// 迭代</span><br>            <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>                <span class="hljs-comment">// 获取准备就绪的事件</span><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-comment">// 判断是什么事件就绪</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">// 若为接收就绪</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> ssChannel.accept();<br>                    sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    sChannel.register(selector, SelectionKey.OP_READ);<br><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-comment">// 获取当前选择器上读就绪的通道</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> (SocketChannel)key.channel();<br><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>((len = sChannel.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                        buffer.flip();<br>                        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, len));<br>                        buffer.clear();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 取消选择键</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="使用DatagramChannel"><a href="#使用DatagramChannel" class="headerlink" title="使用DatagramChannel"></a>使用DatagramChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.nio;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.DatagramChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNonBlockingNIO2</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br><br>        dc.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-keyword">while</span>(scan.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scan.next();<br>            buffer.put((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString() + <span class="hljs-string">&quot;:&quot;</span> + str).getBytes());<br>            dc.send(buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));<br>            buffer.clear();<br>        &#125;<br>        dc.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br><br>        dc.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        dc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        dc.register(selector, SelectionKey.OP_READ);<br><br>        <span class="hljs-keyword">while</span>(selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> it.next();<br>                <span class="hljs-keyword">if</span>(key.isReadable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    dc.receive(buffer);<br>                    buffer.flip();<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, buffer.limit()));<br>                &#125;<br>            &#125;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.nio;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.Pipe;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPip</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取管道</span><br>        <span class="hljs-type">Pipe</span> <span class="hljs-variable">pipe</span> <span class="hljs-operator">=</span> Pipe.open();<br>        <span class="hljs-comment">// 将缓冲区中的数据写入管道</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        Pipe.<span class="hljs-type">SinkChannel</span> <span class="hljs-variable">sinkChannel</span> <span class="hljs-operator">=</span> pipe.sink();<br>        buffer.put(<span class="hljs-string">&quot;通过管道发送数据&quot;</span>.getBytes());<br>        buffer.flip();<br>        sinkChannel.write(buffer);<br><br>        <span class="hljs-comment">// 读取数据</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        Pipe.<span class="hljs-type">SourceChannel</span> <span class="hljs-variable">sourceChannel</span> <span class="hljs-operator">=</span> pipe.source();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sourceChannel.read(buffer1);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer1.array(), <span class="hljs-number">0</span>, len));<br><br>        sourceChannel.close();<br>        sinkChannel.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java NIO(New IO或Non Bloking IO)是从Java1.4版本开始引入的一个新的IO API，NIO支持面向缓冲区的、基于通道的IO操作，读写文件更加高效。&lt;/p&gt;
&lt;h2 id=&quot;Java-NIO&quot;&gt;&lt;a href=&quot;#Java-NIO&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Back-end" scheme="http://yoursite.com/tags/Back-end/"/>
    
  </entry>
  
  <entry>
    <title>JVM-11_直接内存</title>
    <link href="http://yoursite.com/2022/07/16/JVM/JVM-11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2022/07/16/JVM/JVM-11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</id>
    <published>2022-07-16T01:56:07.000Z</published>
    <updated>2023-03-05T10:43:37.682Z</updated>
    
    <content type="html"><![CDATA[<p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下列代码，直接分配本地内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">BUFFER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 1GB</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(BUFFER);<br></code></pre></td></tr></table></figure><h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><img src="image-20200709170907611.png"><p>NIO的方式使用了缓存区的概念</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致<code>outofMemoryError</code>异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于<code>-xmx</code>指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。<br>缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置</p><p>如果不指定，默认与堆的最大值<code>-xmx</code>参数值一致</p><img src="image-2020070923064.png">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。&lt;/p&gt;
&lt;p&gt;直接内存是在Java堆外的、直接向系统申请的内存区间。&lt;/p&gt;
&lt;p&gt;来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存&lt;/p&gt;
&lt;p&gt;通常，访问直接</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-10_对象实例化内存布局与访问定位</title>
    <link href="http://yoursite.com/2022/07/05/JVM/JVM-10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2022/07/05/JVM/JVM-10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2022-07-05T01:59:47.000Z</published>
    <updated>2023-03-05T10:43:33.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><img src="image-20200709095356247.png"><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h3 id="创建对象的步骤-共6步"><a href="#创建对象的步骤-共6步" class="headerlink" title="创建对象的步骤(共6步)"></a>创建对象的步骤(共6步)</h3><p>对象实例化的过程:</p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化"></a>1. 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出<code>ClassNotFoundException</code>异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>float, int 占4个字节</li><li>short, char 占2个字节</li><li>byte, boolean 占1个字节 </li><li>String 4 占4个字节</li><li>double, long 8 占4个字节</li></ul><p>为对象分配空间需要找到内存中至少存在一块足够大小的连续空间</p><p>判断内存是否规整</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能决定</strong>。</p><h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>在Eden区每个线程预先分配TLAB - 通过设置 <code>-XX:+UseTLAB</code>参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h3 id="4-初始化分配到的内存-属性的默认初始化"><a href="#4-初始化分配到的内存-属性的默认初始化" class="headerlink" title="4. 初始化分配到的内存(属性的默认初始化)"></a>4. 初始化分配到的内存(属性的默认初始化)</h3><p>给对象属性赋值的操作</p><ul><li><p>属性的默认初始化</p></li><li><p>显示初始化</p></li><li><p>代码块中的初始化</p></li><li><p>构造器初始化</p></li><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li></ul><h3 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p>稍后详细讲</p><h3 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6. 执行init方法进行初始化"></a>6. 执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><img src="image-20200709151033237.png"><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和 类型指针</p><ol><li>运行时元数据</li></ol><ul><li>哈希值(HashCode)：对象在堆空间里面的地址</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><ol start="2"><li>类型指针：指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</li></ol><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="image-20200709152801713.png"><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><img src="image-20200709164149920.png"><h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><img src="image-20200709164342002.png"><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><img src="image-20200709164350466.png"><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象实例化&quot;&gt;&lt;a href=&quot;#对象实例化&quot; class=&quot;headerlink&quot; title=&quot;对象实例化&quot;&gt;&lt;/a&gt;对象实例化&lt;/h2&gt;&lt;h3 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-9_方法区</title>
    <link href="http://yoursite.com/2022/06/20/JVM/JVM-9_%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://yoursite.com/2022/06/20/JVM/JVM-9_%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2022-06-20T01:26:30.000Z</published>
    <updated>2023-03-05T10:43:28.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是方法区"><a href="#什么是方法区" class="headerlink" title="什么是方法区"></a>什么是方法区</h3><h4 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h4><p>PermGen ， 就是 PermGen space ，全称是 Permanent Generation space ，是指内存的永久保存区域。这块内存主要是被JVM存放Class和Meta信息的， Class 在被 Loader 时就会被放到 PermGen space 中。</p><p>绝大部分 Java 程序员应该都见过 <code>java.lang.OutOfMemoryError: PermGen space</code> 这个异常。<br>这里的 PermGen space 其实指的就是 方法区 。不过方法区和 PermGen space又有着本质的区别。</p><p>方法区 是 JVM 的规范，所有虚拟机 必须遵守的。</p><p>PermGen space 则是 HotSpot 虚拟机 基于 JVM 规范对 方法区 的一个落地实现， 并且只有 HotSpot 才有 PermGen space。</p><p>而如 JRockit（Oracle）、J9（IBM） 虚拟机有 方法区 ，但是就没有 PermGen space。</p><p>PermGen space 是 JDK7及之前， HotSpot 虚拟机 对 方法区 的一个落地实现。在JDK8被移除。</p><p>Metaspace（元空间）是 JDK8及之后， HotSpot 虚拟机 对 方法区 的新的实现。</p><p><strong>JDK6、JDK7 时，方法区 就是 PermGen（永久代）。</strong></p><p><strong>JDK8 时，方法区就是 Metaspace（元空间）</strong></p><h3 id="复习一下Java运行时数据区"><a href="#复习一下Java运行时数据区" class="headerlink" title="复习一下Java运行时数据区"></a>复习一下Java运行时数据区</h3><img src="image-20200708093918121.png"><p>从线程共享与否的角度来看</p><img src="image-20200708094507624.png"><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h4 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h4><p>下面就涉及了对象的访问定位</p><img src="image-20200708094747667.png"><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p><a href="https://docs/roacle.com/javase/specs/jvms/se8/html">《Java虚拟机规范》</a>中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><img src="image-20200708095853544.png"><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError：PermGen space</code> 或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。            </p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过<code>-XX:MaxPermsize</code>上限）</p></blockquote><img src="image-20200708102919149.png"><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><img src="image-20200708103055914.png"><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。<strong>不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p><h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul><li>通过<code>-xx:Permsize</code>来设置永久代初始分配空间。默认值是20.75M</li><li><code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutofMemoryError:PermGen space</code>。</li></ul><img src="image-20200708111756800.png"><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</p><p>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的<code>-xx:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</p><h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li></ul><h4 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h4><ul><li><p>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</p></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ul><h4 id="内存溢出（Memory-Overflow）"><a href="#内存溢出（Memory-Overflow）" class="headerlink" title="内存溢出（Memory Overflow）"></a>内存溢出（Memory Overflow）</h4><img src="bd315c6034a85edf533cef2ef38ce826dc54756d.jpeg"><p>内存溢出排查</p><p>排查其实最主要的就是检查代码，而且内存溢出往往都是代码的问题。当然一下几点都是需要注意的：</p><ol><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>启动参数内存值设定的过小；</li></ol><p>最后就是解决了。</p><ol><li>修改JVM启动参数，直接增加内存。</li><li>检查错误日志</li><li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><img src="image-20200708161728320.png"><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><img src="image-20200708161856504.png"><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><p>JVM必须在方法区中保存类型的所有字段的相关信息以及字段的声明顺序。</p><p>字段的相关信息包括：字段名称、字段类型、字段修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同字段信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * non-final的类变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.hello();<br>        System.out.println(order.count);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p><h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><img src="image-20200708171151384.png"><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><img src="image-20200708172357052.png"><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、字段和方法的符号引用</p><h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将会被翻译成如下字节码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">new <span class="hljs-comment">#2  </span><br>dup<br>invokespecial<br></code></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备<strong>动态性</strong>。</p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p>如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        System.out.println(a+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码执行过程展示</p><img src="image-20200708204750374.png"><p>首先现将操作数500放入到操作数栈中</p><img src="image-20200708204953552.png"><p>然后存储到局部变量表中</p><img src="image-20200708205029376.png"><p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><img src="image-20200708205221737.png"><p>将500 和 100 进行一个除法运算，在把结果入栈</p><img src="image-20200708205413721.png"><p>在最后就是输出流，需要调用运行时常量池的常量</p><img src="image-20200708205708057.png"><p>最后调用invokevirtual（虚方法调用），然后返回</p><img src="image-20200708205909176.png"><p>返回时</p><img src="image-20200708210540696.png"><p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><img src="image-20200708211541300.png"><p>JDK7的时候</p><img src="image-20200708211609911.png"><p>JDK8的时候，元空间大小只受物理内存影响</p><img src="image-20200708211637952.png"><h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。<br>因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><img src="image-20200708215025527.png"><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><img src="image-20200708215218078.png"><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 <code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="image-20200708220303243.png"><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是方法区&quot;&gt;&lt;a href=&quot;#什么是方法区&quot; class=&quot;headerlink&quot; title=&quot;什么是方法区&quot;&gt;&lt;/a&gt;什么是方法区&lt;/h3&gt;&lt;h4 id=&quot;PermGen（永久代）&quot;&gt;&lt;a href=&quot;#PermGen（永久代）&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-8_堆</title>
    <link href="http://yoursite.com/2022/06/06/JVM/JVM-8_%E5%A0%86/"/>
    <id>http://yoursite.com/2022/06/06/JVM/JVM-8_%E5%A0%86/</id>
    <published>2022-06-06T07:45:52.000Z</published>
    <updated>2023-03-05T10:43:23.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：最小堆内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>下图就是使用：Java VisualVM(C:\Program Files\Java\jdk1.8.0_231\bin\jvisualvm.exe)查看堆空间的内容，通过 jdk bin提供的插件</p><img src="image-20200706200739392.png"><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p><blockquote><p>The heap is the run-time data area from which memory for all class instances and arrays is allocated</p></blockquote><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><img src="image-20200706201904057.png"><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>(Young Generation Space)新生区: Young&#x2F;New, 又被划分为Eden区和Survivor区</li><li>(Tenure generation space)养老区: Old&#x2F;Tenure</li><li>(Permanent Space)永久区: Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>(Young Generation Space)新生区: Young&#x2F;New, 又被划分为Eden区和Survivor区</li><li>(Tenure generation space)养老区: Old&#x2F;Tenure</li><li>(Meta Space)元空间: Meta</li></ul><p>约定同义词：</p><ul><li>Young Generation Space &#x3D; 新生区 &#x3D; 新生代 &#x3D; 年轻代 </li><li>Tenure generation space &#x3D; 养老区 &#x3D; 老年区 &#x3D; 老年代</li><li>Permanent Space &#x3D; 永久区 &#x3D; 永久代</li></ul><img src="image-20200706203419496.png"><p>堆空间内部结构，JDK1.8之前从永久代 -&gt;  元空间</p><img src="image-20200706203835403.png"><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li><code>-Xms</code>用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li><code>-Xmx</code>则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过<code>-xmx</code>所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将<code>-Xms</code>和<code>-Xmx</code>两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，避免频繁的扩容或释放，对系统造成额外的压力，从而提高性能</strong>。</p><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小&#x2F;64</li><li>最大内存大小：物理电脑内存大小&#x2F;4</li></ul><p>如何查看堆内存的内存分配情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jps  -&gt;  staat -gc  进程id<br></code></pre></td></tr></table></figure><p>在程序运行结束后打印堆空间详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Picture&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Picture</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Picture</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] pixels;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Picture</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pixels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后设置启动参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure><img src="javaw_s9VJ3r66ne.png"><p>错误提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space<br>at com.sicmatr1x.java.Picture.&lt;init&gt;(OOMTest.java:24)<br>at com.sicmatr1x.java.OOMTest.main(OOMTest.java:15)<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><img src="image-20200706211652779.png"><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><img src="image-20200707075847954.png"><p>下面这参数开发中一般不会调：</p><img src="image-20200707080154039.png"><ul><li><p>默认-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p></li><li><p>可以修改-XX:NewRatio&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p></li></ul><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p><p>查看新生代区占几份：<code>jinfo -flag NewRatio 60636</code></p><ul><li><code>-XX:NewRatio</code>: 设置新生代与老年代的比例。默认值是2.</li><li><code>-XX:SurvivorRatio</code>: 设置新生代中Eden区与Survivor区的比例。默认值是8。在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项<code>-xx:SurvivorRatio</code>调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></li><li><code>-XX:-UseAdaptiveSizePolicy</code>: 关闭自适应的内存分配策略  （暂时用不到）</li><li><code>-Xmn</code>: 设置新生代的空间的大小。 （一般不设置）</li></ul><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><img src="image-20200707084208115.png"><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li></ol><ul><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 Y(oung)GC &#x2F; Minor GC操作。<strong>注意：S0或S1区满的时候是不会触发YGC的。如果Survivor区满了后，将会触发一些特殊的规则(参考下面的对象分配的特殊情况)，也就是可能直接晋升老年代</strong></p><img src="image-20200707084714886.png"><ol><li>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</li></ol><img src="image-20200707085232646.png"><ol start="2"><li>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</li></ol><img src="image-20200707085737207.png"><ol start="3"><li>我们继续不断的进行对象生成 和垃圾回收，当Survivor中的对象的年龄达到15的时候(可以设置参数：<code>-Xx:MaxTenuringThreshold=15</code>进行设置，默认为15)，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象晋升到老年代中</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>针对Survivor区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生代收集，很少在老年代收集，几乎不在永久代&#x2F;元空间收集</li></ul><h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><img src="image-20200707091058346.png"><h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapInstanceTest</span> &#123;<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapInstanceTest</span>());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后设置JVM参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms600m -Xmx600m<br></code></pre></td></tr></table></figure><img src="垃圾回收.gif"><p>最终，在老年代和新生代都满了，就出现OOM</p><h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><p><a href="https://u062.com/dir/27497173-39290581-6bdf5f">城通网盘提取码：800763</a></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC&#x2F;YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC&#x2F;oldGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><img src="image-20200707095606813.png"><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发FullGC执行的情况有如下五种：</p><ul><li>调用<code>System.gc()</code>时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sicmatr1x&quot;</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                list.add(a);<br>                a = a + a;<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.getStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[GC (Allocation Failure) [PSYoungGen: 2005K-&gt;508K(2560K)] 2005K-&gt;832K(9728K), 0.0013790 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[GC (Allocation Failure) [PSYoungGen: 2512K-&gt;496K(2560K)] 2836K-&gt;1953K(9728K), 0.0016054 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[GC (Allocation Failure) [PSYoungGen: 1757K-&gt;482K(2560K)] 6670K-&gt;5991K(9728K), 0.0010749 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[GC (Allocation Failure) [PSYoungGen: 482K-&gt;498K(2560K)] 5991K-&gt;6015K(9728K), 0.0007589 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (Allocation Failure) [PSYoungGen: 498K-&gt;0K(2560K)] [ParOldGen: 5517K-&gt;4061K(7168K)] 6015K-&gt;4061K(9728K), [Metaspace: 3219K-&gt;3219K(1056768K)], 0.0064008 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] <br>[GC (Allocation Failure) [PSYoungGen: 34K-&gt;128K(2560K)] 6399K-&gt;6493K(9728K), 0.0016660 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (Ergonomics) [PSYoungGen: 128K-&gt;0K(2560K)] [ParOldGen: 6365K-&gt;5237K(7168K)] 6493K-&gt;5237K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0046603 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] <br>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 5237K-&gt;5237K(8704K), 0.0003621 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 5237K-&gt;5216K(7168K)] 5237K-&gt;5216K(8704K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0086411 secs] [Times: user=0.05 sys=0.02, real=0.01 secs] <br>Heap<br> PSYoungGen      total 1536K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)<br>  eden space 1024K, 6% used [0x00000000ffd00000,0x00000000ffd11ac8,0x00000000ffe00000)<br>  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)<br> ParOldGen       total 7168K, used 5216K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)<br>  object space 7168K, 72% used [0x00000000ff600000,0x00000000ffb180c0,0x00000000ffd00000)<br> Metaspace       used 3257K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 353K, capacity 388K, committed 512K, reserved 1048576K<br>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOfRange(Arrays.java:3664)<br>at java.lang.String.&lt;init&gt;(String.java:207)<br>at java.lang.StringBuilder.toString(StringBuilder.java:407)<br>at com.sicmatr1x.java.GCTest.main(GCTest.java:14)<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to，s0&#x2F;s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><img src="image-20200707101511025.png"><p>其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><img src="image-20200707101543871.png"><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项<code>-xx:MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： <code>-Xx:HandlePromotionFailure</code></p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><img src="image-20200707103547712.png"><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项<code>-Xx:UseTLAB</code>设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项<code>-Xx:TLABWasteTargetPercent</code>设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><img src="image-20200707104253530.png"><h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><ul><li><p>-<code>XX：+PrintFlagsInitial</code>：查看所有的参数的默认初始值</p></li><li><p><code>-XX：+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p><code>-Xms：初始堆空间内存</code>（默认为物理内存的1&#x2F;64）</p></li><li><p><code>-Xmx：最大堆空间内存</code>（默认为物理内存的1&#x2F;4）</p></li><li><p><code>-Xmn：设置新生代的大小</code>。（初始值及最大值）</p></li><li><p><code>-XX:NewRatio</code>：配置新生代与老年代在堆结构的占比</p></li><li><p><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0&#x2F;S1空间的比例</p></li><li><p><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄</p></li><li><p><code>-XX：+PrintGCDetails</code>：输出详细的GC处理日志</p><ul><li>打印gc简要信息：<ol><li>-Xx：+PrintGC</li><li>verbose:gc</li></ol></li></ul></li><li><p><code>-XX:HandlePromotionFalilure</code>：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析（Escape Analysis）</strong>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();<br>    <span class="hljs-comment">// use v</span><br>    <span class="hljs-comment">// ....</span><br>    v = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的逃逸分析代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 逃逸分析</span><br><span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> EscapeAnalysis obj;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>():obj;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();<br>        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项<code>-xx：+DoEscapeAnalysis</code>显式开启逃逸分析</li><li>通过选项<code>-xx：+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 栈上分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String phone;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackAllocation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br><br>        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        Thread.sleep(<span class="hljs-number">10000000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置JVM参数，表示未开启逃逸分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>运行结果，同时还触发了GC操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">花费的时间为：664 ms<br></code></pre></td></tr></table></figure><p>然后查看内存的情况，发现有大量的User存储在堆中</p><img src="image-20200707203038615.png"><p>我们在开启逃逸分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails<br></code></pre></td></tr></table></figure><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">花费的时间为：5 ms<br></code></pre></td></tr></table></figure><p>然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失</p><img src="image-20200707203441718.png"><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其转换成字节码</p><img src="image-20200707205634266.png"><h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><p>参数设置：<code>-XX:+EliminateAllocations</code>开启标量替换(默认打开)，允许将对象打散分配在栈上</p><h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations<br></code></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下(64bit下默认启动的是server模式，可用java -version查看)，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志。</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆的核心概念&quot;&gt;&lt;a href=&quot;#堆的核心概念&quot; class=&quot;headerlink&quot; title=&quot;堆的核心概念&quot;&gt;&lt;/a&gt;堆的核心概念&lt;/h2&gt;&lt;p&gt;堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-1_JVM与Java体系结构</title>
    <link href="http://yoursite.com/2022/05/27/JVM/JVM-1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2022/05/27/JVM/JVM-1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2022-05-27T02:04:40.000Z</published>
    <updated>2023-03-26T08:36:25.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于栈的指令集架构与基于寄存器的指令集架构"><a href="#基于栈的指令集架构与基于寄存器的指令集架构" class="headerlink" title="基于栈的指令集架构与基于寄存器的指令集架构"></a>基于栈的指令集架构与基于寄存器的指令集架构</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p><p>基于栈式架构：</p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持</li></ul><p>基于寄存器架构：</p><ul><li>例如x86的二进制指令集</li><li>指令集架构完全依赖硬件</li><li>性能优秀，执行更高效</li><li>花费更少指令完成一项操作</li><li>通常为一地址指令、二地址指令、三地址指令。</li></ul><p>例如：计算2+3</p><p>基于栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">iconst_2 // 常量2入栈<br>istore_1<br>iconst_3 // 常量3入栈<br>istore_2<br>iload_1<br>iload_2<br>iadd  // 常量2，3出栈，执行相加<br>istore_0 // 结果5入栈<br></code></pre></td></tr></table></figure><p>基于寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mov eax,2 // 将eax寄存器值设为2<br>add eax,3 // 使eax寄出器的值加3<br></code></pre></td></tr></table></figure><h3 id="反编译字节码案例"><a href="#反编译字节码案例" class="headerlink" title="反编译字节码案例"></a>反编译字节码案例</h3><p>StackStruTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sicmatr1x.java;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackStruTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用javap反编译指令反编译StackStruTest.class字节码文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">javap -v StackStruTest.class<br></code></pre></td></tr></table></figure><p>反编译结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  Last modified 2020-7-30; size 486 bytes<br>  MD5 checksum 618bcdd36b54bf88b6efa145bd258086<br>  Compiled from &quot;StackStruTest.java&quot;<br>public class com.sicmatr1x.java.StackStruTest<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #1 = Methodref          #3.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = Class              #22            // com/sicmatr1x/java/StackStruTest<br>   #3 = Class              #23            // java/lang/Object<br>   #4 = Utf8               &lt;init&gt;<br>   #5 = Utf8               ()V<br>   #6 = Utf8               Code<br>   #7 = Utf8               LineNumberTable<br>   #8 = Utf8               LocalVariableTable<br>   #9 = Utf8               this<br>  #10 = Utf8               Lcom/sicmatr1x/java/StackStruTest;<br>  #11 = Utf8               main<br>  #12 = Utf8               ([Ljava/lang/String;)V<br>  #13 = Utf8               args<br>  #14 = Utf8               [Ljava/lang/String;<br>  #15 = Utf8               i<br>  #16 = Utf8               I<br>  #17 = Utf8               j<br>  #18 = Utf8               k<br>  #19 = Utf8               SourceFile<br>  #20 = Utf8               StackStruTest.java<br>  #21 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V<br>  #22 = Utf8               com/sicmatr1x/java/StackStruTest<br>  #23 = Utf8               java/lang/Object<br>&#123;<br>  public com.sicmatr1x.java.StackStruTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         4: return<br>      LineNumberTable:<br>        line 3: 0<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       5     0  this   Lcom/sicmatr1x/java/StackStruTest;<br><br>  public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=4, args_size=1<br>         0: iconst_2<br>         1: istore_1<br>         2: iconst_3<br>         3: istore_2<br>         4: iload_1<br>         5: iload_2<br>         6: iadd<br>         7: istore_3<br>         8: return<br>      LineNumberTable:<br>        line 5: 0<br>        line 6: 2<br>        line 7: 4<br>        line 8: 8<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       9     0  args   [Ljava/lang/String;<br>            2       7     1     i   I<br>            4       5     2     j   I<br>            8       1     3     k   I<br>&#125;<br>SourceFile: &quot;StackStruTest.java&quot;<br></code></pre></td></tr></table></figure><p>看code部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Code:<br>    stack=2, locals=4, args_size=1<br>        0: iconst_2 // 定义常量2<br>        1: istore_1 // 保存到操作数1的栈中<br>        2: iconst_3 // 定义常量3<br>        3: istore_2 // 保存到操作数2的栈中<br>        4: iload_1 // 加载操作数1的值<br>        5: iload_2 // 加载操作数2的值<br>        6: iadd // 求和<br>        7: istore_3 // 保存到操作数3的栈中<br>        8: return<br></code></pre></td></tr></table></figure><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><ol><li>虚拟机的启动：JVM的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由JVM的具体实现指定的。</li><li>虚拟机的执行</li><li>虚拟机的终止：</li></ol><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到异常或错误而异常终止</li><li>操作系统出现错误而导致JVM进程终止</li><li>某线程调用Runtime类或System类的exit方法或Runtime类的halt方法，并且Java安全管理器也允许这个词exit或halt操作</li><li>JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载JVM时JVM的退出情况</li></ul><h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sum-Classic-VM"><a href="#Sum-Classic-VM" class="headerlink" title="Sum Classic VM"></a>Sum Classic VM</h3><p>世界上第一款商用Java虚拟机，虚拟机内部只提供了解释器</p><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>JDK1.2</p><p>准确式内存管理(Exact Memory Management)：虚拟机可以知道内存中某个位置的数据具体是什么类型</p><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>JDK1.3</p><p>是JDK6, JDK8默认虚拟机</p><h3 id="BEA的JRockit"><a href="#BEA的JRockit" class="headerlink" title="BEA的JRockit"></a>BEA的JRockit</h3><p>专注于服务器端应用</p><p>JRockit JVM是世界上最快的JVM</p><h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>IBM Techology for Java Virtual Machine简称IT4J，内部代号J9</p><h3 id="KVM和CDC-x2F-CLDC-Hotspot"><a href="#KVM和CDC-x2F-CLDC-Hotspot" class="headerlink" title="KVM和CDC&#x2F;CLDC Hotspot"></a>KVM和CDC&#x2F;CLDC Hotspot</h3><p>目前移动领域地位尴尬，KVM简单、轻量、高度可移植，面向低端可移动设备</p><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>Azul VM和BEA Liquid VM与特定硬件平台绑定、软硬件配合的专有虚拟机</p><p>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，提供在巨大内存内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等</p><h3 id="BEA-Liquid-VM"><a href="#BEA-Liquid-VM" class="headerlink" title="BEA Liquid VM"></a>BEA Liquid VM</h3><p>BEA开发用于自家Hypervisor系统，不需要操作系统的支持，它本身实现了一个专用操作系统的必要功能</p><h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><p>JDK1.5, JDK1.6</p><p>由IBM于Intel联合开发</p><h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>基于OpenJDK HotSpot VM深度定制且开源的高性能服务器</p><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>是虚拟机但不是Java虚拟机，不能直接执行Java的class文件，美原油遵循Java虚拟机规范</p><p>基于寄存器架构，不是JVM的栈架构，执行dex(Dalvik Executable)文件，可由class文件转化来</p><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用(包括：Java, Scala, Groovy, Kotlin; C, C++, JavaScript, Ruby, Python, R等)</p><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件。工作原理是将这些语言的源码或源码编译后的中间格式通过解释器转换成能被Graal VM接受的中间表示。</p><p>还提供Truffle工具集快速构建面向一种新语言的解释器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于栈的指令集架构与基于寄存器的指令集架构&quot;&gt;&lt;a href=&quot;#基于栈的指令集架构与基于寄存器的指令集架构&quot; class=&quot;headerlink&quot; title=&quot;基于栈的指令集架构与基于寄存器的指令集架构&quot;&gt;&lt;/a&gt;基于栈的指令集架构与基于寄存器的指令集架构&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
