<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Java后端速查表 |  
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/styles/vs2015.min.css"><!- highlight.js ->
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</head>

</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Java后端速查表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java后端速查表
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/02/20/Java%E5%90%8E%E7%AB%AF%E9%80%9F%E6%9F%A5%E8%A1%A8/" class="article-date">
  <time datetime="2022-02-20T02:04:40.000Z" itemprop="datePublished">2022-02-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">13.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">49 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java后端"><a href="#Java后端" class="headerlink" title="Java后端"></a>Java后端</h1><h3 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h3><ul>
<li>JDK(Java Development Kit)</li>
<li>JRE(Java Runtime Environment)</li>
</ul>
<p>面向对象三大特征:</p>
<ol>
<li>封装: 封装是指把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li>
<li>继承: 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。提高代码的重用，程序的可维护性</li>
<li>多态: 表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</li>
</ol>
<p>Java 和 C++的区别</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
</ul>
<p>为什么说 Java 语言编译与解释并存？</p>
<ul>
<li>编译型语言: 是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码</li>
<li>解释型语言: 是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</li>
<li>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。</li>
</ul>
<p>为什么重写<code>equals()</code>时必须重写<code>hashCode()</code>方法？</p>
<ul>
<li>两个对象调用 equals 方法返回 true, 那么调用 hashCode 返回的值也必须一样</li>
<li>反之 hashCode 返回值一样 equals 可以返回 false，这种情况为哈希碰撞</li>
</ul>
<p>重载(Overload)和重写(<code>@Override</code>)的</p>
<ul>
<li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</li>
<li>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</li>
</ul>
<p>深拷贝 vs 浅拷贝</p>
<ul>
<li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ul>
<h3 id="Java基本类"><a href="#Java基本类" class="headerlink" title="Java基本类"></a>Java基本类</h3><p>异常(Throwable)： </p>
<ul>
<li>Exception（异常）：是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。<ul>
<li>RuntimeException<ul>
<li>例如：ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）</li>
</ul>
</li>
</ul>
</li>
<li>Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。表示代码运行时 JVM（Java 虚拟机）出现的问题。<ul>
<li>例如：当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
</li>
</ul>
<p><code>java.util.HashMap</code></p>
<ul>
<li>JDK1.7: 数组+单链表 链地址法</li>
<li>JDK1.8: 数组+单链表+红黑树(当链表的深度达到8的时候，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O(n)变成O(logN)提高了效率)</li>
<li>put操作的流程：<ol>
<li><code>key.hashcode()</code>，时间复杂度O(1)</li>
<li>找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)</li>
<li>如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(n)</li>
<li>如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(logn)</li>
</ol>
</li>
</ul>
<p><code>java.util.concurrent.ConcurrentHashMap</code></p>
<ul>
<li>采用了分段锁技术</li>
<li>JDK7采用Segment分段锁(默认16个Segment)</li>
<li>JDK8改成了CAS+synchronized(这里只加锁在hashmap中的一个元素上面)</li>
<li>理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment</li>
<li>put(): <ol>
<li>通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put</li>
<li>尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁</li>
<li>重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取</li>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li>
<li>释放当前 Segment 的锁</li>
</ol>
</li>
<li>get():<ol>
<li>Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上</li>
<li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值</li>
</ol>
</li>
</ul>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>传统拷贝流程(下载文件为例):</p>
<ul>
<li>磁盘 -&gt; 内核缓冲区 -&gt; 用户缓冲区 -&gt; 网络堆栈相关的内核缓冲区 -&gt; 网卡</li>
<li>DMA从磁盘读取文件到内核缓冲区 -&gt; CPU从内核缓冲区拷贝到用户缓冲区 -&gt; 应用程序调write系统调用把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区 -&gt; socket把内核缓冲区的内容发送到网卡上</li>
</ul>
<p>零拷贝(下载文件为例):</p>
<ul>
<li>磁盘 -&gt; 内核缓冲区 -&gt; 网络堆栈相关的内核缓冲区 -&gt; 网卡</li>
<li>磁盘上的数据会通过DMA被拷贝的内核缓冲区 -&gt; 操作系统把内核缓冲区与应用程序共享 -&gt; 应用程序调write系统调用将内核缓冲区的内容拷贝到socket缓冲区中 -&gt; socket把内核缓冲区的内容发送到网卡上</li>
</ul>
<p>BIO(Blocked I/O): 面向流(单向); 同步阻塞I/O</p>
<ol>
<li>服务端: 通过ServerSocket注册端口</li>
<li>服务端: 调用<code>accept()</code>监听客户端Socket请求</li>
<li>客户端: 调用<code>connect()</code>连接服务端</li>
<li>服务端/客户端: 从Socket中获取字节输入流或输出流对数据进行读写操作</li>
</ol>
<p>NIO(Non-blocked I/O): 面向缓冲区(双向); 非阻塞I/O</p>
<ul>
<li>一个线程对应一个Selector选择器</li>
<li>一个Selector对应多个Channel通道</li>
<li>一个Channel对应一个Buffer(底层是一个数组)</li>
<li>直接缓冲区与非直接缓冲区<ul>
<li>直接缓冲区(非堆内存): 本地IO -&gt; 直接内存 -&gt; 本地IO</li>
<li>非直接缓冲区(堆内存): 本地IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地IO</li>
</ul>
</li>
</ul>
<p>Selector选择器</p>
<ul>
<li>可以通过Selector来实现一个I/O线程并发处理N个客户端连接和读写操作</li>
<li>Selector接多个Channel并监听这些Channel上的事件，使用选择器的事件迭代器遍历获取选择器监听到的事件并判断事件类型分别处理，处理完后清除事件</li>
</ul>
<p>AIO(Async-Blocked I/O): 异步非阻塞I/O</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程</p>
<ul>
<li>进程(资源分配的基本单位): 是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>
<li>线程(执行调度的基本单位): 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是多个线程可以共享同一块内存空间和一组系统资源(堆)，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。但是频繁的切换线程可能会消耗大量的CPU资源，因为需要频繁的保存和恢复线程运行上下文。<ul>
<li>特性<ol>
<li>可见性</li>
<li>有序性</li>
<li>原子性</li>
</ol>
</li>
</ul>
</li>
<li>纤程: </li>
</ul>
<p>线程撕裂者: 一个核里面可以跑多个线程</p>
<ul>
<li>一颗CPU可以有多个核，正常的CPU一个核可以同时跑一个线程</li>
<li>线程撕裂者就是一个核里面有一个ALU(arithmetic and logic unit)服务2寄存器组，ALU可以在2个寄存器组之间快速切换，一个寄存器组存一个线程的工作数据，这样一个核看起来就是同时跑2个线程。例如4核8线程</li>
</ul>
<p>并行与并发</p>
<ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>
<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力</li>
</ul>
<p>线程安全:<br>经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。</p>
<p>死锁:<br>产生死锁的四个必要条件</p>
<ol>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不可剥夺条件: 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)。</li>
<li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件: 存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有(i=0, 1, …, n-1)，Pn等待的资源被P0占有</li>
</ol>
<p>Java 中实现多线程的方法</p>
<ol>
<li>继承 <code>Thread</code> 类</li>
<li>实现 <code>Runnable</code> 接口: 如果一个类继承 Thread类，则不适合于多个线程共享资源，而实现了 Runnable 接口，就可以方便的实现资源的共享</li>
</ol>
<p>同步:<br>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入<code>synchronized</code>关键字。</p>
<p><code>synchronized</code>关键字:</p>
<ul>
<li><code>synchronized(expression) {// 同步代码块}</code>: 对表达式<code>expresssion</code>求值(值的类型须是引用类型reference type)，获取它所代表的对象，然后尝试获取这个对象的锁 -&gt; 如果能获取锁，则进入同步块执行，执行完后退出同步块，并归还对象的锁(异常退出也会归还); 如果不能获取锁，则阻塞在这里，直到能够获取锁;</li>
<li>特性:<ol>
<li>原子性: 同步代码块中的内容要么全部执行要么都不执行</li>
<li>可见性: 多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性。这点和<code>volatile</code>的实现类似，被<code>volatile</code>修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性</li>
<li>有序性: 程序执行的顺序按照代码先后执行，每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性</li>
<li>可重入性: <code>synchronized</code>关键字属于可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</li>
</ol>
</li>
<li>源码解读<ul>
<li>反编译使用了<code>synchronized</code>关键字的类的class文件可以看到两种实现方法:<ol>
<li>字节码指令(<code>monitorenter</code>,<code>monitorexit</code>): 修饰同步代码块<ul>
<li><code>synchronized</code>修饰在方法块: 通过 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令获取线程的执行权的。当方法执行完毕退出以后或者出现异常的情况下会自动释放锁</li>
<li>JVM执行到<code>monitorenter</code>指令时它会尝试获取对象的锁，如果该对象没有锁，或者当前线程已经拥有了这个对象的锁时，它会把计数器+1；然后当执行到<code>monitorexit</code> 指令时就会将计数器-1；然后当计数器为0时，锁就释放了。如果获取锁 失败，那么当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</li>
<li>反编译后可以看到一个<code>monitorenter</code>和两个<code>monitorexit</code>: 这是因为第二个<code>monitorexit</code>是给异常处理释放锁用的</li>
<li>monitor到底是什么: monitor它就是个监视器，底层源码是C++编写的2. <code>flag=ACC_SYNCHRONIZED</code>: 修饰同步方法</li>
<li>这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/realize_dream/article/details/106968443" target="_blank" rel="noopener">深入理解synchronized底层源码</a></p>
</blockquote>
<p>先行发生原则(happens-before): 在发生操作B之前，操作A产生的影响能被操作B观察到。先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据</p>
<p><code>volatile</code>关键字: 当一个变量定义为volatile之后，它将具备两种特性</p>
<ol>
<li>保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</li>
<li>禁止指令重排序优化</li>
</ol>
<p>JVM中对象实例的组成:</p>
<ol>
<li>对象头: <ul>
<li>Mark Word:<ul>
<li>对象的hashCode</li>
<li>锁信息: 记录对象锁当前的状态，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据<ul>
<li>JDK6之前: 无锁、有锁(重量级锁)</li>
<li>JDK6之后: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁(CAS) -&gt; 重量级锁<ul>
<li>偏向锁: 如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程ID等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作</li>
</ul>
</li>
<li>轻量级锁(2个线程版本的偏向锁): 当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块</li>
<li>重量级锁: 当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大</li>
</ul>
</li>
<li>分代年龄</li>
<li>GC标志</li>
</ul>
</li>
<li>Class Metadata Address: 类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例</li>
</ul>
</li>
<li>实例数据: 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐</li>
<li>对其填充</li>
</ol>
<p>ReentrantLock(可重入锁):</p>
<ul>
<li>指的是一个线程能够对一个临界资源重复加锁</li>
</ul>
<p>LongAdder</p>
<ul>
<li>采用分段CAS: 除了真正记录数值的base属性外，还有与base相同的数据类型的cell数组，如果存在多个线程同时对Lang做自增操作，则new一个cell元素放到cell数组里供新增的线程做操作(这里会根据线程数自动扩容或缩容cell数组)，使得同时对base做自增操作的线程数变少，自旋占用的CPU变少，最后再用sum求和操作对所有cell属性和base属性做求和操作并返回，这个求出来的和就是所有线程做的操作的总和</li>
</ul>
<p>线程的状态变化:</p>
<ol>
<li>New(创建状态): 在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时它已经有了相应的内存空间和其他资源(程序计数器、本地方法栈、虚拟机栈)，但还处于不可运行状态。新建一个线程对象可采用<code>Thread</code> 类的构造方法来实现，例如 <code>Thread thread=new Thread()</code></li>
<li>Ready(就绪状态): 新建线程对象后，调用该线程的 <code>start()</code> 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 调度，这表明它已经具备了运行条件</li>
<li>Running(运行状态): 当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 <code>run()</code> 方法。<code>run()</code> 方法定义该线程的操作和功能</li>
<li>Blocked(阻塞状态): 一个正在执行的线程遇到<code>synchronized</code>，会进入阻塞状态。线程都将进入阻塞状态，阻塞的线程进入调度队列entry set排队，获取到锁的线程才可以转入就绪状态</li>
<li>Waiting(等待): 调用<code>Object.wait()</code>, <code>Thread.join()</code>方法可使一个线程进入不带时限的等待状态，直到其它线程调用了方法<code>Object.notify()</code>或<code>Object.notifyAll()</code>唤醒了等待状态的线程，被唤醒后可能进入调度队列entry set继续等待获取锁(Blocked状态)或直接获取到锁(Runnable状态)</li>
<li>Time_Waiting(超时等待): 调用<code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>Thread.sleep(long)</code>方法可使一个线程进入带时限的等待状态，直到其它线程调用了方法<code>Object.notify()</code>或<code>Object.notifyAll()</code>唤醒了等待状态的线程</li>
<li>Terminated(死亡状态): 线程调用 <code>stop()</code> 方法时或 <code>run()</code> 方法执行结束后，即处于死亡状态。</li>
</ol>
<blockquote>
<p><a href="https://www.cnblogs.com/zhongchang/articles/10339134.html" target="_blank" rel="noopener">Java 线程状态之 WAITING</a></p>
</blockquote>
<p>常用的线程池<code>java.util.concurrent.Executors</code>类下静态方法:</p>
<ol>
<li><code>newSingleThreadExecutor()</code>: 创建了一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li>
<li><code>newFixedThreadPool(int nThreads)</code>: 创建了一个固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大值<code>nThreads</code>。线程池的大小一旦达到最大值后，再有新的任务提交时则放入无界阻塞队列中，等到有线程空闲时，再从队列中取出任务继续执行。</li>
<li><code>newCachedThreadPool()</code>: 创建了一个可缓存的线程池。当有新的任务提交时，有空闲线程则直接处理任务，没有空闲线程则创建新的线程处理任务，队列中不储存任务。线程池不对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。如果线程空闲时间超过了60秒就会被回收。</li>
</ol>
<pre><code class="java">public ThreadPoolExecutor(int corePoolSize, // 核心线程数
                          int maximumPoolSize, // 线程池最大线程数
                          long keepAliveTime, // 超出核心线程数的线程等待new task的时间，超过则terminated
                          TimeUnit unit, // keepAliveTime时间的单位
                          BlockingQueue&lt;Runnable&gt; workQueue, // 用于保存等待执行的任务的阻塞队列: 用于存放等待线程执行的task的队列只存放由execute方法提交的Runnable任务
                          RejectedExecutionHandler handler // 线程池对拒绝任务的处理策略
                          ); 

public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;())); // 本身是有界队列但是这里未设置其大小限制，默认Integer.MAX_VALUE，此时相当于无界队列
}
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
}
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;()); // 这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程
}</code></pre>
<p><code>Executors</code>存在什么问题</p>
<ul>
<li><code>SingleThreadPool</code>和<code>FixedThreadPool</code>使用的是无界队列，其请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求而导致OOM</li>
<li><code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能会大量创建线程而导致OOM</li>
</ul>
<p>创建线程池的正确姿势，直接使用<code>java.util.concurrent.ThreadPoolExecutor</code>类的构造方法来创建</p>
<pre><code class="java">ExecutorService executor = new ThreadPoolExecutor(10, 10, // 10个线程，最大也支持10个
        60L, TimeUnit.SECONDS, // 超时时间60秒
        new ArrayBlockingQueue(10)); // 有界队列，容量为10，最多容纳10个task</code></pre>
<p>Q: 线程池怎么设置核心线程数?</p>
<ul>
<li>如果是CPU密集型服务线程数量等于CPU核心数</li>
<li>如果是I/O密集型服务: 线程数 = ((工作时间+休息时间)/工作时间) * CPU核心数 * CPU利用率</li>
</ul>
<p>workQueue(工作队列): </p>
<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO（先进先出）原则对任务进行排序。使用该队列，线程池中能创建的最大线程数为<code>maximumPoolSize</code>。 </li>
<li><code>LinkedBlockingQueue</code>: 基于链表结构的无界阻塞队列，按FIFO（先进先出）原则对任务进行排序，吞吐量高于<code>ArrayBlockingQueue</code>。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li>
<li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列。添加任务的操作必须等到另一个线程的移除操作，否则添加操作一直处于阻塞状态。</li>
<li><code>PriorityBlockingQueue</code>: 一个支持优先级的无界阻塞队列。使用该队列，线程池中能创建的最大线程数为<code>corePoolSize</code>。</li>
</ul>
<p>handler(饱和策略，或者又称拒绝策略): 当队列和线程池都满了，即线程池饱和了，必须采取一种策略处理提交的新任务。</p>
<ul>
<li><code>AbortPolicy</code>: 无法处理新任务时，直接抛出异常，这是默认策略。 </li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中最靠前的一个任务，并执行当前任务。</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务。</li>
</ul>
<p>线程池的状态:</p>
<ol>
<li>RUNNING: 该状态的线程池既能接受新提交的任务，又能处理阻塞队列中任务。</li>
<li>SHUTDOWN: 该状态的线程池不能接收新提交的任务，但是能处理阻塞队列中的任务。处于 RUNNING 状态时，调用<code>shutdown()</code>方法会使线程池进入到该状态。 注意： <code>finalize()</code>方法在执行过程中也会隐式调用<code>shutdown()</code>方法。 </li>
<li>STOP: 该状态的线程池不接受新提交的任务，也不处理在阻塞队列中的任务，还会中断正在执行的任务。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 <code>shutdownNow()</code> 方法会使线程池进入到该状态</li>
<li>TIDYING: 如果所有的任务都已终止，workerCount(有效线程数)=0 。线程池进入该状态后会调用 <code>terminated()</code> 钩子方法进入TERMINATED 状态。</li>
<li>TERMINATED: 在<code>terminated()</code>钩子方法执行完后进入该状态，默认<code>terminated()</code>钩子方法中什么也没有做。</li>
</ol>
<p>线程池的关闭可通过<code>shutdown()</code>或者<code>shutdownNow()</code>方法 </p>
<ul>
<li><code>shutdown()</code>将线程池的状态设置为<code>SHUTDOWN</code>状态，只会中断空闲的工作线程</li>
<li><code>shutdownNow()</code>将线程池的状态设置为<code>STOP</code>状态，会中断所有工作线程，不管工作线程是否空闲</li>
<li>调用两者中任何一种方法，都会使<code>isShutdown()</code>方法的返回值为true；</li>
<li>线程池中所有的任务都关闭后，<code>isTerminated()</code>方法的返回值为true</li>
</ul>
<p>Q: 新的任务提交到线程池，线程池是怎样处理的？<br>步骤：</p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。</li>
<li>线程池判断工作队列是否已经满。如果没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p>Q: 父线程子线程怎么共享数据?</p>
<ul>
<li>可以使用<code>InheritableThreadLocals</code>可继承线程变量这个类来实现，<code>ThreadLocals</code>是线程变量，相当于一个map，每个线程是map的key，value是<code>set()</code>进去的值，一个线程使用<code>get()</code>只能get到它自己set进去的值，所以不可用于获取父线程的数据。而<code>InheritableThreadLocals</code>会在子线程new出来的时候就把自己的value复制进去，所以子线程可以使用这个来共享获取父线程的数 据</li>
</ul>
<p>AQS(AbstractQueuedSynchronized):</p>
<ul>
<li>抽象队列同步器AQS: 是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列. AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch</li>
<li>底层实现为: CAS + volatile</li>
</ul>
<p>CAS原理:</p>
<ul>
<li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li>
<li>CAS操作都是通过sun包下Unsafe类实现，而Unsafe类中的方法都是native方法CAS通过调用JNI(Java Native Interface)的c++代码实现的</li>
<li>unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 <code>Atomic::cmpxchg</code></li>
<li><code>Atomic::cmpxchg</code> 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>
<li>Atomic类中的value是<code>volatile</code>的，<code>volatile</code>可以保证可见性和有序性</li>
<li>Atomic类中设置值使用自旋锁，不断取内存中的value值，然后CAS更新，若失败则持续自旋重试更新操作</li>
<li>缺点:<ol>
<li>ABA问题:<ul>
<li>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<code>AtomicStampedReference</code>类具有版本号功能</li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作: 多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者把多个共享变量合并成一个共享变量来操作(JDK1.5之后提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作)</li>
</ol>
</li>
</ul>
<p><code>Atomic::cmpxchg</code></p>
<pre><code class="c++">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot;// 判断mp是否为多核CPU是则返回LOCK指令

inline jlong Atomic::cmpxchg (jlong exchange_value, volatile jlong* dest, jlong compare_value) {
  bool mp = os::is_MP(); // 
  __arm__ __volatile__ (LOCK_IF_MP(%4) &quot;cmpxchgq %1,(%3)&quot; // MP=mult prosser LOCK_IF_MP返回lock指令 汇编指令cmpxchgq执行原子的CAS
                        : &quot;=a&quot; (exchange_value)
                        : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                        : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
}</code></pre>
<ul>
<li>乐观锁底层实现: lock + cmpxchg 指令</li>
<li>悲观锁底层实现: lock 指令</li>
<li>volatile的底层实现也是用的: lock指令</li>
</ul>
<p>缓存一致性协议: 硬件级别的协议</p>
<ul>
<li>作用: 多核CPU有多个一级缓存，保证缓存内部数据的一致,不让系统数据混乱</li>
<li>Intel CPU对缓存一致性协议的实现(MESI = modified + exclusive + shared + invalid)</li>
<li>MESI中每个缓存行(Cache line:CPU中缓存存储数据的单元，一般为64字节)都有四个状态(假设线程 A 和线程 B 同时对一个变量执行 i++)<ol>
<li>核心 A 从内存中加载变量 i，并将缓存行设置为 E（独享），随后通过总线嗅探检查内存中对变量 i 的操作；</li>
<li>核心 B 从内存中加载变量 i，总线嗅探机制会将核心 A 与核心 B 的缓存行设置为 S（共享）</li>
<li>核心 A 对变量 i 进行修改，缓存行设置为 M（修改），而核心 B 被通知修改缓存行为 I（无 效）。如果存在高并发，则交给总线裁决</li>
<li>核心 A 将修改后数据同步回内存，并将变量设置为 E（独享）</li>
<li>核心 B 重新刷新缓存行，并将缓存行核心 A 和核心 B 的缓存行设置为 S（共享）</li>
</ol>
</li>
<li>CPU 是通过总线和内存进行数据传输的。在多核心时代下，多个核心通过同一条总线和内存以及其他硬件进行通信</li>
<li>通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行</li>
<li>伪共享问题: 伪共享是指多个线程同时读写同一个缓存行中的变量，而导致缓存行失效的问题。尽管多个线程分别访问的是不同的数据，但由于它们存在同一个缓存行中，只要任何一方修改都会使得缓存失效，降低了运算效率。解决方案: 字节填充，在变量前后填充多个字节使得 变量大小+填充的字节=64字节，这样这个变量肯定会独占一个缓存行。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/m18870420619/article/details/82431319" target="_blank" rel="noopener">CPU缓存一致性协议MESI</a><br><a href="https://www.cnblogs.com/jokerjason/p/9584402.html" target="_blank" rel="noopener">缓存行与MESI</a></p>
</blockquote>
<p>用户态内核态</p>
<ul>
<li>Linux操作系统的体系架构分为用户态和内核态</li>
<li>内核态: 本质上是一种软件，控制计算机硬件资源(CPU资源、存储资源、I/O资源等)</li>
<li>用户态: 上层应用程序的活动空间</li>
<li>上层应用想要访问计算机硬件资源需要通过内核提供的访问接口(系统调用)来调用</li>
<li>系统调用是操作系统的最小功能单位</li>
<li>从用户态到内核态切换可以通过三种方式:<ol>
<li>系统调用</li>
<li>异常: 如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常</li>
<li>外设中断: 当外设完成用户的请求时，会向CPU发送中断信号</li>
</ol>
</li>
</ul>
<h3 id="多线程框架"><a href="#多线程框架" class="headerlink" title="多线程框架"></a>多线程框架</h3><p>Disruptor 框架</p>
<ul>
<li>英国外汇交易公司LMAX开发的一个高性能队列。主要用于线程与线程之间的消息传递</li>
<li>QPS: 600w</li>
<li>为什么快:<ol>
<li>CAS: ArrayBlockingQueue使用了重量级锁(lock锁)，而Disruptor采用CAS操作</li>
<li>消除伪共享: 解决方案: 字节填充，在变量前后填充多个字节使得 变量大小+填充的字节=64字节，这样这个变量肯定会独占一个缓存行。</li>
<li>RingBuffer: 环形数组，没有删除操作，超过容量会直接覆盖原有数据，避免了垃圾回收。大小必须为2的n次方，因为取余运算直接使用的是位运算，使得元素定位更快。</li>
</ol>
</li>
<li></li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>类加载子系统: 根据给定的全限定名类名(如java.lang.Object)来装载class文件的内容到方法区(Method Area)</p>
<ol>
<li>Bootstrap ClassLoader(启动类加载器): <code>$JAVA_HOME</code>中<code>jre/lib/rt.jar</code>里所有的class，由C++实现</li>
<li>Extension ClassLoader(扩展类加载器): 负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME</code>中<code>jre/lib/*.jar</code>或<code>-D java.ext.dirs</code>指定目录下的jar包</li>
<li>App ClassLoader(系统类加载器): 负责加载classpath中指定的jar包及目录中class</li>
<li>Custom ClassLoader(用户自定义类加载器): 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</li>
</ol>
<p>双亲委派机制: JVM对class文件采用按需加载的方式，在加载时JVM采用的是双亲委派机制，即把请求交由父类处理，它是一种任务委派模式</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，若无法完成，子类加载器才会去加载。</li>
</ol>
<p>运行时数据区(Runtime Data Area)</p>
<ol>
<li>程序计数器(Program Counter Register) &lt;- 线程不共享</li>
<li>本地方法栈(Native Method Stack) &lt;- 线程不共享</li>
<li>虚拟机栈(Java Virtual Machine Stack) &lt;- 线程不共享</li>
<li>方法区(Method Area) &lt;- 线程共享</li>
<li>堆(Heap) &lt;- 线程共享</li>
</ol>
<p>堆(Heap): 年青代:老年代=1:2</p>
<ul>
<li>年青代(Young): Eden:From:To=8:1:1<ul>
<li>Eden: 新创建的对象绝大部分会分配在Eden区。当Eden区内存不够的时候，就会触发MinorGC</li>
<li>Survivor 0(From): 在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄到<code>15</code>，则直接分配到老年代。</li>
<li>Survivor 1(To)</li>
</ul>
</li>
<li>老年代(Tenured): 老年代存放从年轻代存活的对象。一般来说老年代存放的都是生命期较长的对象</li>
</ul>
<p>GC(Generational Collecting)垃圾回收:</p>
<ul>
<li>Minor GC: 当伊甸园的空间满时，程序又需要创建对象，触发Minor GC</li>
<li>Full GC: 当老年代内存不足时，对老年代进行垃圾回收。这时可能会伴随着STW(Stop The World)</li>
<li>STW(Stop The World): 停止所有线程，进行垃圾回收，这时候线程会被阻塞，直到垃圾回收完成<ul>
<li>Q: 为什么要STW？-&gt; A: 如果不执行STW的话在Full GC的过程中如果有一个线程执行完毕，那么这个线程的局部变量表里面所指向的在堆里的对象都会变成垃圾，但是此时Full GC还没执行完，那么这次Full GC执行所得到的结果是不准确的</li>
</ul>
</li>
</ul>
<p>JVM虚拟机调优:</p>
<ul>
<li>主要是减少STW发生的频率，因为发生STW的时候会阻塞全部的用户线程，在用户看来就是应用程序卡顿</li>
<li>能不能通过调整JVM参数是的几乎发生Full GC?<ul>
<li>默认年青代:老年代=1:2，改成2:1，那么当年轻代满的时候绝大部分昭生夕死的对象会被干掉，只有实在干不掉的才会挪到老年代</li>
</ul>
</li>
<li>jVisualVM: 可视化工具，可以查看JVM的内存使用情况，安装插件可以观察到堆分代模型的整个GC过程</li>
</ul>
<p>判断对象是否需要回收</p>
<ol>
<li>引用计数法: 给对象添加一个引用计数器。但是难以解决循环引用问题。</li>
<li>可达性分析法: 通过一系列的 <code>GC Roots</code> 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</li>
</ol>
<p>垃圾回收算法</p>
<ol>
<li>标记-清除算法(Mark-Sweep): <ul>
<li>分为两个阶段：标记阶段(标记出所有需要被回收的对象) -&gt; 清除阶段(回收被标记的对象所占用的空间)</li>
<li>缺点: 效率不高、空间会产生大量碎片</li>
</ul>
</li>
<li>复制算法(Copying): 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。Eden:From:To=8:1:1</li>
<li>标记-整理算法(Mark-Compact): 在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存</li>
<li>分代收集(Generational Collection): 根据对象的生命周期划分几块内存区，一般是分为新生代和老年代。新生代:老年代=1:2</li>
</ol>
<p>垃圾收集器:</p>
<ol>
<li>Serial/Serial Old收集器: 单线程收集器，进行垃圾收集时，必须暂停所有用户线程<ul>
<li>Serial: 新生代 Copying算法</li>
<li>Serial Old: 老年代 Mark-Compact算法</li>
</ul>
</li>
<li>ParNew收集器: Serial收集器的多线程版本</li>
<li>Parallel Scavenge收集器: 新生代的多线程收集器回收期间不需要暂停其他用户线程 Copying算法</li>
<li>Parallel Old收集器: 多线程 Mark-Compact算法</li>
<li>CMS(Concurrent Mark Sweep)收集器: 并发收集器，优点是最短回收停顿时间 Mark-Sweep算法</li>
<li>G1收集器: 并行与并发收集器，并且它能建立可预测的停顿时间模型</li>
</ol>
<p>程序计数器(Program Counter Register): 每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，若为native方法则为undefined</p>
<p>本地方法栈(Native Method Stack): 本地方法栈用于管理本地方法的调用</p>
<p>虚拟机栈(Java Virtual Machine Stack): </p>
<ul>
<li>线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)</li>
<li>栈帧的内部结构：<ol>
<li>局部变量表(Local Variables): 最基本的存储单元是Slot(变量槽)，容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>操作数栈(operand Stack)(或表达式栈): 用于保存计算过程的中间结果</li>
<li>动态链接(DynamicLinking)(或指向运行时常量池的方法引用): 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)</li>
<li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义): 存放调用该方法的pc寄存器的值</li>
</ol>
</li>
</ul>
<p>方法区(Method Area): 元空间(Metaspace)是其实现，元空间并不在虚拟机中，而是使用本地内存</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis单线程为什么快?</p>
<ol>
<li>纯内存操作: 数据存放在内存中，内存的响应时间大约是100纳秒</li>
<li>单线程: Redis是基于内存的操作，CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，同时避免了线程切换和竞态产生的消耗 </li>
<li>非阻塞I/O: Redis采用epoll做为I/O多路复用技术的实现 ，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间 </li>
<li>客户端调服务端:<ol>
<li>发送命令</li>
<li>执行命令: 每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题</li>
<li>返回结果</li>
</ol>
</li>
</ol>
<p>Redis数据结构底层实现</p>
<ul>
<li>String: Simple dynamic string(SDS)<ul>
<li><code>buf[]</code>字节数组，用于保存字符串, <code>len</code>保存字符串的长度, <code>free</code>buf 数组中未使用字节的数量</li>
<li>优点: 不用担心字符串变更造成的内存溢出问题</li>
</ul>
</li>
<li>链表: 双向链表上扩展了头、尾节点、元素数等属性<ul>
<li>优点: 可以直接获得头、尾节点</li>
</ul>
</li>
<li>字典(Hash): 数组+链表的基础上，进行了一些rehash优化<ul>
<li>采用链地址法来处理冲突，然后它没有使用红黑树优化</li>
<li>哈希表节点采用单链表结构</li>
<li>rehash优化: 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子(load factor)维持在一个合理的范围之内， 程序需要对哈希表的大小进行相应的扩展或者收缩</li>
</ul>
</li>
<li>有序集合:<ul>
<li>底层实现为跳跃表: 跳表其实就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了</li>
</ul>
</li>
</ul>
<p>分布式锁</p>
<ul>
<li>使用<code>setnx</code>命令实现: 在Redis中，<code>setnx</code>命令的作用是，如果key不存在，则设置key-value并返回true，如果key存在，则不做任何操作并返回false; 利用这一机制在获取锁为设置key，设置成功返回true表示获取到锁了，执行完业务逻辑之后删除掉设置的key即可</li>
</ul>
<p>epoll: linux内核下的一个高效的处理大批量的文件操作符的一个实现</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MyISAM</p>
<ul>
<li>非聚集索引: 索引文件与数据文件分开; <code>.MYI</code>文件存索引, <code>.MYD</code>文件存数据</li>
<li>底层数据结构: B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</li>
<li>主键: 可以没有</li>
<li>辅助索引(Secondary key): 结构上与主索引没有任何区别，辅助索引的 key 可以重复</li>
</ul>
<p>InnoDB</p>
<ul>
<li>聚集索引: 数据文件本身就是索引文件</li>
<li>底层数据结构: B+Tree 作为索引结构，叶节点的 data 域保存了完整的数据记录。索引的 key 是数据表的主键，因此InnoDB 要求表必须有主键</li>
<li>主键: 必须有主键。如果没有显式指定，则会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则自动为 InnoDB 表生成一个隐含字段作为主键，类型为长整形。尽量在采用自增字段做表的主键，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整</li>
<li>辅助索引(Secondary key): 辅助索引 data 域存储相应记录主键的值而不是地址。这使得辅助索引搜索需要检索两遍索引(回表):首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录。</li>
</ul>
<p>mysql索引数据结构为什么选择B+Tree?</p>
<ul>
<li>二叉树: 无平衡机制，插入递增元素，退化成链表</li>
<li>红黑树(是一种二叉平衡树): 数据量大时树的深度也会很深</li>
<li>B Tree: 多叉，从左到右依次递增，叶子节点都在同一层</li>
<li>B+ Tree: 非叶子节点不存储data，叶子节点包含所有索引字段并用指针从左往右链接成链表。</li>
</ul>
<p>B+ Tree: 每个节点大小16kb限制，16kb/每个节点大小(8字节索引元素+6字节孩子节点磁盘文件地址指针)=1170个索引</p>
<ul>
<li>索引全部加载到内存，找到后根据磁盘文件地址进行一次磁盘I/O读取对应的数据</li>
<li>只用3层的B+ Tree就支持上千万行数据的查找</li>
</ul>
<p>MVCC</p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>组成:</p>
<ol>
<li>Name Server: 名称服务充当路由消息的提供者，可集群部署，节点之间无任何信息同步，提供命名服务，更新和发现 Broker 服务</li>
<li>Producer(生产者): </li>
<li>Broker: 消息中转角色，负责存储消息，转发消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker</li>
<li>Consumer(消费者): </li>
</ol>
<ul>
<li>Topic: 表示消息的第一级类型，一条消息必须有一个Topic</li>
<li>Queue: Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元</li>
<li>tags: Tags是Topic下的次级消息类型/二级类型，可以在同一个Topic下基于Tags进行消息过滤。Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况</li>
<li>commitLog: 用于存储消息的文件。顺序写入，随机读写。消息只要被写入 commitlog 那么该消息就不会丢失。</li>
<li>ConsumeQueue: ConsumeQueue中并不需要存储消息的内容，而存储的是消息在CommitLog中的offset。通过broker保存的offset可以在ConsumeQueue中获取消息，从而快速的定位到commitLog的消息位置</li>
</ul>
<p>集群: 推荐多主多从</p>
<ul>
<li><p>多个master节点多个slave节点，一个master节点配一个slave节点，slave是master节点的备份</p>
</li>
<li><p>slave节点不接受生产者的消息，生产者的消息发给master节点</p>
</li>
<li><p>消费者一般从master节点消费消息</p>
</li>
<li><p>若master节点宕机，则消费者从对应的slave节点消费消息，注意：这里slave即使master宕机也不会升级，依然是slave节点</p>
</li>
<li><p>同步复制: 生产者发送同步消息需主节点和从节点都写入文件或内存(异步刷盘是内存，一般选择异步刷盘)之后才会返回确认信息给生产者</p>
</li>
<li><p>异步刷盘(高性能): 注意这里因为消息同时存在于主节点和从节点所以这里可以采用异步刷盘，丢失的概率不大</p>
</li>
<li><p>Topic: 表示消息的第一级类型，一条消息必须有一个Topic</p>
</li>
<li><p>Queue: Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元</p>
</li>
<li><p>tags: Tags是Topic下的次级消息类型/二级类型，可以在同一个Topic下基于Tags进行消息过滤。Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况</p>
</li>
<li><p>commitLog: 用于存储消息的文件。顺序写入，随机读写。消息只要被写入 commitLog 那么该消息就不会丢失。</p>
</li>
<li><p>ConsumeQueue: ConsumeQueue中并不需要存储消息的内容，而存储的是消息在CommitLog中的offset。通过broker保存的offset可以在ConsumeQueue中获取消息，从而快速的定位到commitLog的消息位置</p>
</li>
</ul>
<p>消息类型</p>
<ul>
<li>同步消息: 消息发送方发出数据后，生产者会阻塞直到MQ服务方发回响应消息，表示已经写入数据到queue里了</li>
<li>异步消息: MQ 的异步发送，需要用户实现异步发送回调接口(SendCallback)，在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应</li>
<li>单向(one-way)消息: 只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别</li>
</ul>
<p>消息丢失分析:</p>
<ul>
<li>生产者发送时丢失: 同步复制+重试</li>
<li>RocketMQ自身丢失: 主从架构+持久化</li>
<li>消费者消费消息丢失: 重试+死信队列</li>
</ul>
<p>消息重复消费问题:</p>
<ul>
<li>MVCC(Multi-Version Concurrency Control多版本并发控制): 生产者发送到queue的消息需要带上这个版本号，消费者在执行业务逻辑的同时带上版本号，sql的update语句的where带上version号保证语句的幂等性。<ul>
<li>缺点: 这意味着生产者在发送消息之前就需要查表拿到最新的版本号，增加了生产者和消费者的耦合度</li>
</ul>
</li>
<li>去重表方案: 每个消息带唯一id，然后消费者维护消息表，id设成唯一，消费消息的同时insert这张表，如果抛异常就把异常吃了直接返回，后续业务逻辑不继续进行了</li>
</ul>
<p>顺序消息消费问题:</p>
<ol>
<li>一个topic对应一个queue，这样需要顺序消费的消息就在同一条queue里</li>
<li>重试参数改成0</li>
</ol>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul>
<li>Partition: topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。</li>
</ul>
<p>消息传递模式</p>
<ul>
<li>点对点传递模式: 消息持久化到一个队列中，一个或多个消费者消费队列中的数据，一条消息只能被消费一次</li>
<li>发布-订阅模式: 消息被持久化到一个topic中，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除</li>
</ul>
<p>RocketMQ与Kafka的区别</p>
<ol>
<li>rocketMQ的NameServer和kafka的zookeeper对比<ul>
<li>kafka具备选举功能: Master/Slave的选举，有2步<ol>
<li>先通过ZK在所有机器中，选举出一个KafkaController</li>
<li>再由这个Controller，决定每个partition的Master是谁，Slave是谁</li>
</ol>
</li>
<li>因为有了选举功能，所以kafka某个partition的master挂了，该partition对应的某个slave会升级为主对外提供服务</li>
<li>rocketMQ不具备选举，Master/Slave的角色也是固定的。当一个Master挂了之后，你可以写到其他Master上，但不能让一个Slave切换成Master</li>
<li>rocketMq的所有broker节点的角色都是一样，上面分配的topic和对应的queue的数量也是一样的，Mq只能保证当一个broker挂了，把原本写到这个broker的请求迁移到其他broker上面</li>
</ul>
</li>
<li>kafka为什么比RocketMQ有更大的吞吐量<ul>
<li>kafka在消息存储过程中会根据topic和partition的数量创建物理文件，也就是说我们创建一个topic并指定了3个partition，那么就会有3个物理文件目录，也就说说partition的数量和对应的物理文件是一一对应的</li>
<li>RocketMQ在消息存储方式是采用commitLog，RocketMQ的queue的数量其实是在consumeQueue里面体现的，在真正存储消息的commitLog其实就只有一个物理文件</li>
<li>kafka的多文件并发写入 VS RocketMQ的单文件写入，性能差异kafka完胜可想而知</li>
<li>kafka的大量文件存储会导致一个问题，也就说在partition特别多的时候，磁盘的访问会发生很大的瓶颈，毕竟单个文件看着是append操作，但是多个文件之间必然会导致磁盘的寻道</li>
</ul>
</li>
</ol>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>一致性哈希算法</p>
<ul>
<li>假设你需要对文件进行缓存，你有缓存集群，对每个文件根据哈希对服务器数量取模，将每一张文件映射到一台缓存服务器上面。缺点: 如果你要增加一台服务器，那么需要对所有的文件都重新计算一遍，这样就会导致缓存雪崩，全部缓存到文件失效</li>
<li>为解决这个问题可以采用一致性哈希算法: 将服务器映射到一个环上面，然后根据哈希值取模，将文件映射到环上某个位置，然后这个文件存储的服务器就是映射位置顺时针遇到的第一个服务器，这样如果增加一台服务器也只会使得环上的一部分文件缓存失效，避免了缓存雪崩</li>
<li>缺点: 有时候可能会出现缓存不均匀的情况，即服务器映射到环上的位置是不均匀的，可以通过增加虚拟节点解决，文件顺时针遇到虚拟节点就放到虚拟节点对应的那个真实节点对应的服务器上</li>
</ul>
<h4 id="常用高并发相关工具"><a href="#常用高并发相关工具" class="headerlink" title="常用高并发相关工具"></a>常用高并发相关工具</h4><p>Apache JMeter</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2022/02/20/Java%E5%90%8E%E7%AB%AF%E9%80%9F%E6%9F%A5%E8%A1%A8/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/02/26/BIP39/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            BIP39助记词库
          
        </div>
      </a>
    
    
      <a href="/2020/10/07/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">算法-递归</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'db290dc011893521d885',
    clientSecret: '4cbc64d2114f4963d8090a55b508568b2f26075b',
    repo: 'blog-comments',
    owner: 'Sicmatr1x',
    admin: ['Sicmatr1x'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
  
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> Sicmatr1x
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Sicmatr1x"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~，ETH:0xDF06f28BcdD7DBb25c56f9560E184874d5FC0973</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="/js/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>
